<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言内存布局</title>
    <url>/post/908b7180/</url>
    <content><![CDATA[<h1 id="C语言程序的内存布局"><a href="#C语言程序的内存布局" class="headerlink" title="C语言程序的内存布局"></a>C语言程序的内存布局</h1><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><ul>
<li><p>在我们的计算机内存中，需要为程序存储的不同类型的数据分为不同的部分：</p>
<p><img src="/post/908b7180/memory_layout.png" alt></p>
<ul>
<li><strong>机器码</strong>部分是我们的已编译程序的二进制代码。当我们运行程序时，该代码将被加载到内存的“顶部”。</li>
<li><strong>全局变量</strong>是我们在程序中声明的全局变量或整个程序可以访问的其他共享变量。</li>
<li><strong>堆</strong>部分是一个空区域，<code>malloc</code>可以从中获取可用内存，供程序使用。<code>Dynamic Memory</code>动态申请的内存将存放在<strong>堆</strong>。</li>
<li><strong>栈</strong>部分由程序中的函数调用时使用。<code>function</code>任何函数和<code>Local Variables</code>本地变量 都将存放在<strong>栈</strong>，函数体内再进行函数调用将会在原本的栈区之上再叠一层，因为每个函数都有自己的主存区域。</li>
<li>例如，我们的<code>main</code>函数位于<strong>栈</strong>的最底部，而<code>main</code>调用的其他函数一层一层往上堆叠。</li>
</ul>
<hr>
<p>❌交换函数：交换的只是传入的变量的副本。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>例如，我们的<code>main</code>函数位于栈区的最底部，并且具有局部变量<code>x</code>和<code>y</code>。 调用交换函数时，它具有自己的存储框架或内存片，位于主存储器的顶部，具有局部变量<code>a</code>，<code>b</code>和<code>tmp</code>。</p>
</li>
<li><p>一旦函数交换返回，它所使用的内存将被释放以用于下一个函数调用，除了返回值，我们将丢失所做的所有事情，并且程序将返回称为交换的函数。</p>
</li>
</ul>
<p><img src="/post/908b7180/stack.png" alt></p>
<ul>
<li>因此，通过将<code>x</code>和<code>y</code>的地址从<code>main</code>传递到<code>swap</code>，我们实际上可以更改<code>x</code>和<code>y</code>的值：</li>
</ul>
<p><img src="/post/908b7180/pointers.png" alt></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    swap(&amp;x, &amp;y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li><code>x</code>和<code>y</code>的地址从<code>main</code>传递到<code>swap</code>，并且我们使用<code>int *a</code>语法声明我们的<code>swap</code>函数接受指针。 我们通过跟随指针<code>a</code>将<code>x</code>的值保存到<code>tmp</code>，然后通过跟随指针<code>b</code>取<code>y</code>的值，并将其存储到<code>a(x)</code>所指向的位置。 最后，我们将<code>tmp</code>的值存储到<code>b(y)</code>所指向的位置，然后完成。</li>
</ul>
</li>
<li>如果调用<code>malloc</code>的次数过多，则会发生堆溢出，最终导致溢出到栈区。 或者，如果调用的函数过多，则会发生堆溢出，其中堆也分配了过多的内存帧。 这两种类型的溢出通常称为缓冲区溢出，之后我们的程序（或整个计算机）可能崩溃。</li>
</ul>
<h3 id="未分配内存的指针"><a href="#未分配内存的指针" class="headerlink" title="未分配内存的指针"></a>未分配内存的指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x;</span><br><span class="line">    <span class="keyword">int</span> *y;</span><br><span class="line">    x = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *x = <span class="number">42</span>;</span><br><span class="line">    *y = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>y</code>没有被分配内存，最终程序将会出错。此时的<code>y</code>其实是garbage，保存了垃圾值。</p>
]]></content>
      <categories>
        <category>内存布局</category>
      </categories>
      <tags>
        <tag>memory layout</tag>
        <tag>stack</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>OSTEP4-进程</title>
    <url>/post/1ff66ec/</url>
    <content><![CDATA[<h1 id="抽象-进程-homework"><a href="#抽象-进程-homework" class="headerlink" title="[抽象: 进程_homework]"></a>[抽象: 进程_homework]</h1><p>1.<code>./process-run.py -l 5:100,5:100</code>。CPU利用率应为多少（例如，CPU使用时间的百分比？</p>
<p>  <img src="/post/1ff66ec/image-20201107162610895.png" alt="image-20201107162610895" style="zoom: 50%;"></p>
<p>  CPU利用率为100％，因为两个进程都没有I/O调用。</p>
<p>2.<code>./process-run.py -l 4:100,1:0</code>。完成这两个过程需要多长时间？</p>
<p>  <img src="/post/1ff66ec/image-20201107162713141.png" alt="image-20201107162713141" style="zoom: 50%;"></p>
<p>  默认I/O时间长度为5。这些进程按<code>-l</code>选项中列出的顺序开始。调度程序是非抢占式的。<br>          <code>Time=9</code>，第一个进程需要执行4条指令才能完成，然后第二个进程将准备运行I/O并消耗时间长度为5。<br>          模拟器添加最终的“空刻度”以进行10个刻度。</p>
<p>3.<code>./process-run.py -l 1:0,4:100</code>。现在会发生什么？切换顺序重要吗？为什么？</p>
<p>  <img src="/post/1ff66ec/image-20201107163039162.png" alt="image-20201107163039162" style="zoom:50%;"></p>
<p>  现在，这两个进程需要的时间长度为5，因为可以在第一个进程等待I/O的同时CPU执行第二个进程的指令。模拟器添加最终的“空刻度”以进行6个刻度。</p>
<p>4.现在，我们将探讨其他一些标志。一个重要的标志是<code>-S</code>，它确定进程发出I / O时系统的反应。将标记设置为时<code>SWITCH_ON_END</code>，系统在执行I / O时将不会切换到另一进程，而是等待该进程完全完成。当您运行以下两个进程时，会发生什么情况，一个进程执行I / O，另一个进程执行CPU工作？（<code>-l 1:0,4:100 -c -S SWITCH_ON_END</code>）</p>
<p>  <img src="/post/1ff66ec/image-20201107163348304.png" alt="image-20201107163348304" style="zoom:50%;"></p>
<p>  现在，资源使用情况统计信息与问题2中的统计信息几乎相同（两个进程均完成9个滴答声），唯一的区别是，首先执行IO的进程没有最终的“空滴答声”。</p>
<p>5.现在，运行相同的进程，但是将切换行为设置为只要正在等待I / O（<code>-l 1:0,4:100 -c -S SWITCH_ON_IO</code>）就切换到另一进程。怎么了？</p>
<p>  这正是问题3，<code>-S SWITCH_ON_IO</code>也是默认设置。</p>
<p>6.另一个重要的行为是I / O完成时应采取的措施。使用<code>-I IO_RUN_LATER</code>，当I / O完成时，发出该I / O的进程不必立即运行；相反，当时正在运行的任何东西都会继续运行。当您运行这些流程组合时会发生什么？（<code>./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p</code>）系统资源是否得到有效利用？</p>
<p>  第一个进程将等待IO，接下来的3个进程将依次完成。总运行时间为26个滴答声，最后还有一个额外的“空滴答声”。这不是对资源的有效利用，因为第一个进程可能已经在运行<em>所有</em>IO操作，而其他进程正在使用CPU。</p>
<p>7.现在运行相同的进程，但<code>-I IO_RUN_IMMEDIATE</code>运行set，立即运行发出I / O的进程。这种行为有何不同？为什么运行刚刚完成一个I / O的过程是一个好主意？</p>
<p>  在这种情况下，第一个进程将中断其他进程以启动其IO操作，从而减少了18个滴答的计算时间。资源使用率将类似地提高，CPU使用率将达到100％。</p>
<p>  运行刚刚完成一个I / O的进程是一个好主意，因为与其他进程相比，该进程更有可能发出另一个I / O语句（这是一个统计参数），并且在此模拟的情况下，最好执行尽快关闭I / O操作。</p>
<p>8.现在与某些随机生成的进程中运行，例如<code>-s 1 -l 3:50,3:50</code>，<code>-s 2 -l 3:50,3:50</code>，<code>-s 3 -l 3:50,3:50</code>。看看您是否可以预测跟踪结果。使用<code>-I IO_RUN_IMMEDIATE</code>vs.会发生什么<code>-I IO_RUN_LATER</code>？使用<code>-S SWITCH_ON_IO</code>vs.时会发生什么<code>-S SWITCH_ON_END</code></p>
<p>  <code>SWITCH_ON_IO</code>总是比更快的运行时间<code>SWITCH_ON_END</code>。对于给出的3个示例，<code>-I IO_RUN_IMMEDIATE</code>执行的顺序与完全相同<code>-I IO_RUN_LATER</code>。在所有3种情况下，相对于IO操作的时间长度（5个滴答声），少数几个可能的CPU指令（每个进程最多可以包含3条指令，因此每个进程最多可以包含3条CPU指令）意味着这些进程花费了大部分时间他们花费<code>WAITING</code>在IO上的时间，因此没有机会<code>IO_RUN_IMMEDIATE</code>退出当前正在运行的进程。</p>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>homework</tag>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>OSTEP7-进程调度</title>
    <url>/post/fe1a6b20/</url>
    <content><![CDATA[<h1 id="抽象-进程——答案"><a href="#抽象-进程——答案" class="headerlink" title="[抽象: 进程——答案]"></a>[抽象: 进程——答案]</h1><h3 id="1-工作负载假设"><a href="#1-工作负载假设" class="headerlink" title="1. 工作负载假设"></a>1. 工作负载假设</h3><p>对操作系统中运行的进程（有时也叫工作任务）做出如下的假设：</p>
<ol>
<li>每个工作运行相同的时间。</li>
<li>所有工作同时到达。</li>
<li>一旦开始，每个工作保持运行直到完成。</li>
<li>所有工作只使用CPU（即它们不执行IO操作）。</li>
<li>每个工作的运行时间是已知的。</li>
</ol>
<h3 id="2-调度指标"><a href="#2-调度指标" class="headerlink" title="2. 调度指标"></a>2. 调度指标</h3><p>调度指标：周转时间。</p>
<script type="math/tex; mode=display">
T(周转时间)=T(完成时间)-T(到达时间)</script><p>周转时间是一个性能指标，另一个指标是公平。性能和公平在调度系统往往是矛盾的。</p>
<h3 id="3-FIFO-FCFS"><a href="#3-FIFO-FCFS" class="headerlink" title="3. FIFO / FCFS"></a>3. FIFO / FCFS</h3><p>First In First Out / First Come First Served.</p>
<p>这是最基本的调度算法。</p>
<p>但是在护航效应（一些耗时较少的潜在资源消费者排在重量级的资源消费者之后）。我们可以看到，在此放宽了第一个假设：每个工作<strong>运行相同的时间</strong>。</p>
<h3 id="4-SJF"><a href="#4-SJF" class="headerlink" title="4. SJF"></a>4. SJF</h3><p>Shortest Job First.</p>
<p>这个简单的调度算法解决了上面的问题，先运行最短的任务，然后是次短的任务，如此下去。</p>
<p>考虑到<strong>所有工作同时到达</strong>的假设，可证SJF确实是一个最优的调度算法。</p>
<p>然而，这个假设是不切实际的。</p>
<p>现在再放宽假设2：<strong>所有工作同时到达</strong>，来考虑更切合实际的情况。例如：用时长的任务先达，用时短的任务随后到达，此时我们的周转时间依然堪忧。</p>
<h3 id="5-STCF"><a href="#5-STCF" class="headerlink" title="5. STCF"></a>5. STCF</h3><p>Shortest Time-to-Completion First.</p>
<p>为了解决这个问题，需要放宽假设条件3：每个工作<strong>保持运行直到完成</strong>。这意味着，调度程序可以<strong>抢占（preempt）</strong>进程/工作。SJF是一种非抢占式调度程序，因而存在上述的问题。</p>
<p>STCF只是向SJF添加抢占。每当新工作进入系统，他就会确定剩余工作和新工作中，谁的剩余时间少，然后调度该工作。</p>
<p>显然，STCF的周转时间符合我们的预期。</p>
<p>此时我们已经放宽了3个假设条件，接下来，我们考虑新的度量指标。</p>
<h3 id="6-新度量指标：响应时间"><a href="#6-新度量指标：响应时间" class="headerlink" title="6. 新度量指标：响应时间"></a>6. 新度量指标：响应时间</h3><p>对于早期的批处理系统STCF是一个很好的策略，但是现在，用户会坐在终端前，同时要求系统的交互性好。催生了新的度量标准：响应时间。</p>
<script type="math/tex; mode=display">
T(响应时间)=T(首次运行)-T(到达时间)</script><p>考虑一种情况：A先到达，B和C在时间10到达（ABC运行时间均为10）。如果恰好用户交互进程是C，那么我们不得不等待10s才能得到系统的回应。（前面的调度算法都并不是很好）</p>
<p>因此，如何构建对响应时间敏感的调度程序？</p>
<h3 id="7-RR"><a href="#7-RR" class="headerlink" title="7. RR"></a>7. RR</h3><p>Round-Robin.</p>
<p>RR在一个时间片（time slice，又是称为调度量子，schedule quantum）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务到结束，它反复执行，直到所有任务完成。时间片长度必须是时钟中断周期的倍速。</p>
<p>时间长度对于RR是至关重要的。越短，RR在响应时间上表现越好，然而，时间片太短也有问题：突然上下文切换的成本将影响整体性能。</p>
<p>系统设计者需要衡量时间片的长度，足够长方便<strong>摊销（amortize）</strong>上下文切换成本，又不致使系统响应不及时。</p>
<blockquote>
<p>当某些操作有固定成本时，通常会使用摊销技术（amortization）。通过减少成本的频度（执行较少次的操作），系统的总成本就会降低。<br>         例如：时间片:10ms，上下文切换成本:1ms，浪费时间10%；为了摊销，时间片增加到100ms，浪费时间仅有1%。</p>
</blockquote>
<p>然而，问题又来了，如果周转时间是我们的指标，RR将会是最糟糕的调度算法之一。甚至比FIFO更差（单从运行时间看，增加了频繁地上下文切换）。</p>
<p>我们学习了两种调度程序。第一种类型（SIF、STCF）优化周转时间，但对响应时间不利；第二种类型（RR）优化响应时间，但对周转时间不利。</p>
<p>接下来我们还要放宽假设4和5。（希望你没有忘记是什么）</p>
<h3 id="8-结合I-O"><a href="#8-结合I-O" class="headerlink" title="8. 结合I/O"></a>8. 结合I/O</h3><p>首先，放宽假设4：所有工作只使用CPU（即它们不执行IO操作）。</p>
<p>让我们来看一种情况，A和B都需要50ms的CPU时间，但是A运行10ms需要I/O操作（I/O占时10ms），B只使用CPU。</p>
<p>将周转时间当作指标，无论哪种算法效果都不好。</p>
<p>一种常见的方法是，将进程的每个I/O子工作视为一个独立的工作。这样做可以实现<strong>重叠（overlap）</strong>，一个进程在等待另一个进程的I/O完成时使用CPU，系统因此得到更好的利用。</p>
<p><img src="/post/fe1a6b20/image-20201109165657861.png" alt="image-20201109165657861" style="zoom: 80%;"></p>
<p>当这些交互式工作正在执行I/O时，其他密集型工作将运行，从而更好地利用CPU。</p>
<h3 id="9-无法预知"><a href="#9-无法预知" class="headerlink" title="9. 无法预知"></a>9. 无法预知</h3><p>来到最后的假设：每个工作的运行时间是已知的。</p>
<p>事实上，操作系统通常对每个工作的长度知之甚少。下一章我们将看到如果通过构建一个调度程序，利用最近的历史预测未来。</p>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>process</tag>
        <tag>process scheduling</tag>
      </tags>
  </entry>
  <entry>
    <title>Q&amp;A:RAM &amp; ROM &amp; Memory</title>
    <url>/post/17d0af8c/</url>
    <content><![CDATA[<h1 id="RAM为什么是随机存储？"><a href="#RAM为什么是随机存储？" class="headerlink" title="RAM为什么是随机存储？"></a>RAM为什么是随机存储？</h1><p>​        <strong>”随机“强调的是存取数据所花的时间与目标数据所在的物理位置无关</strong>。这是由RAM的结构决定的，RAM使用<strong>存储阵列</strong>来存储数据，只要给出<strong>行地址</strong>和<strong>列地址</strong>，就能<strong>确定目标数据</strong>，这一过程<strong>与目标数据所处的物理位置无关</strong>。</p>
<p>​        与“随机存取“相对的，是<strong>“串行访问”</strong>，指<strong>存取数据所花的时间与目标数据所在的物理位置有关</strong>。串行访问里面又分为<strong>顺序存取</strong>和<strong>直接存取</strong>。<strong>顺序存取如磁带</strong>，要想访问一个某一存储单元，<strong>必须先访问该单元前面的单元</strong>，（所以就有了听歌时倒磁带的痛苦经历）。<strong>直接存取如磁盘</strong>，磁头可以直接定位到目标存储单元，<strong>不需访问该单元前面的单元</strong>。需要注意的是，即使是直接定位，定位磁头所花的时间也是不同的，比如磁头当前在磁道0，定位到磁道2和磁道10000的时间肯定不同，所以存取数据所花的时间与目标数所在的物理位置仍然有关。</p>
<h1 id="明明可以往硬盘里写数据，为什么叫ROM呢？"><a href="#明明可以往硬盘里写数据，为什么叫ROM呢？" class="headerlink" title="明明可以往硬盘里写数据，为什么叫ROM呢？"></a>明明可以往硬盘里写数据，为什么叫ROM呢？</h1><p>​        首先，<strong>硬盘 ≠ ROM.</strong></p>
<p>​        在符合冯.诺依曼架构的计算机中，只读储存器ROM是相对于随机存储器RAM而存在的，<strong>所有的预程序从ROM读出存储在RAM上，工作时程序均在RAM中运行</strong>，而不是在ROM上，所以我们叫它只读储存器，<strong>运行在RAM中的数据在断电前会保存在可多次擦写的外储存器上，外储存器才是硬盘</strong>。</p>
<p>​        简而言之，对于计算机而言，从严格意义来讲<strong>ROM是用来存储输入输出系统</strong>，即<strong>BIOS</strong>，而<strong>硬盘叫外储存器，用来存放操作系统软件以及程序与数据</strong>。</p>
<p>​        对于手机而言，设定的Linux内核会<strong>从磁盘中划分一部分储存空间作为ROM区，用于开机时读取到RAM的映像，而ROM区域和程序以及数据存储区域共用一个介质</strong>，所以厂家为了简单宣传，会把整个ROM大小作为外储存器大小去宣传，但这个和PC是有一定区别的。</p>
<p>​        所以，<strong>这也从结构上顺便解释了为什么安卓手机抑或Linux系统不容易中毒的原因，因为系统作为ROM中的单纯映像，不授权的话是无法写入的</strong>，而Windows在外储存器以软件形式存在，且分界不明显，同时使用微内核结构桥接比较多，虽然方便更改系统配置但是对不熟悉者安全度低。</p>
<h1 id="EEPROM是一种“只读存储器”，为什么要对其进行写操作？"><a href="#EEPROM是一种“只读存储器”，为什么要对其进行写操作？" class="headerlink" title="EEPROM是一种“只读存储器”，为什么要对其进行写操作？"></a>EEPROM是一种“只读存储器”，为什么要对其进行写操作？</h1><p>EEPROM的首字母缩写具有随着技术的发展而发展的历史。</p>
<p><strong>ROM</strong>：只读存储器。写在工厂。</p>
<p><strong>PROM</strong>：可编程只读存储器，但可由用户编程（一次）。真正的一次性可编程，永远可读的存储器。弄错了，就丢了芯片。</p>
<p><strong>EPROM</strong>：可擦可编程只读存储器。可以写入多次，擦出需要使用紫外线照射。有点麻烦，但非常有用。</p>
<p><strong>EEPROM</strong>：电可擦可编程只读存储器。可以写入多次，通过编程电压进行修改。</p>
<p>​        所以，为什么在可写时将其称为eepROm？我怀疑，答案是，与<strong>RAM</strong>（随机存取存储器）不同，它在电源关闭时会保存其内容，因此，其行为更像<strong>ROM</strong>。</p>
<p>​        后来推出的<strong>闪存(Flash Memory)</strong>技术，它是一种广义上的EEPROM，手机上的eMMC和UFS都属于闪存技术，因此闪存也被人们称为ROM。</p>
<h1 id="「内存」这个名字误导性太强，为什么没有一个更精准上口的叫法？"><a href="#「内存」这个名字误导性太强，为什么没有一个更精准上口的叫法？" class="headerlink" title="「内存」这个名字误导性太强，为什么没有一个更精准上口的叫法？"></a>「内存」这个名字误导性太强，为什么没有一个更精准上口的叫法？</h1><p>​        在计算机专业领域，“内存”的全称是“内部储存器”，用于在运行时储存信息，CPU可以直接寻址，区别于永久保存数据、CPU仅通过硬件控制器读取数据的“外部储存器”。<strong>这两者是从计算机架构的角度说的</strong>。在通常语境下，“内存”只有主板上插的内存条一种，<strong>内存就成了“主板上的RAM”的代称</strong>。</p>
<p>​        RAM是Random Access Memory，随机访问储存器，特点是断电失效，可以直接通过电流刷新数据。现在一般只有内存条（DRAM）和CPU缓存（SRAM）使用这类芯片。</p>
<p>​        对应的ROM是Read-Only Memory，只读储存器，最开始的ROM真的是只读，不可写入，包括半导体ROM和CD-ROM，后来出现了紫外线擦除的EPROM，电擦除的EEPROM。</p>
<p>​        <strong>RAM和ROM是从技术实现的角度说的</strong>。</p>
<p>​        U盘、固态硬盘、手机固件使用的闪存芯片也是一种EEPROM，它依然是先擦除再写入，和RAM有原理上的区别。所以<strong>手机广告上的2G RAM + 16G ROM是正确的用法</strong>。（不要纠结flash到底是不是EEPROM了，它确实符合EEPROM定义，写入是通过电擦除-再写入实现的，不过EEPROM一般专指可以按字节擦除的那种，flash是按块擦除）</p>
<p>​        智能手机的组成和电脑一样，所以<strong>依据部件功能继承了电脑的称呼</strong>。不过硬盘换成了闪存芯片，所以手机里履行硬盘职能的部件可以被称作“闪存”。</p>
<p>​        内存和ROM混淆<strong>我认为</strong>来自于安卓系统（或者更早的塞班，我没用过），安卓文件管理器把手机空间分为“内部储存”和“SD卡”，这里的“内部储存”指的是ROM，但是也简称为“内存”。为了和这个“内存”做区别，RAM就变成了运行内存，“运存”。</p>
<p>所以对应关系如下：<br><strong>电脑：内存－硬盘</strong><br><strong>手机：RAM－ROM</strong><br>　　　<strong>内存－闪存</strong><br>　　　<strong>运存－内存</strong></p>
<p>​        至于把手机的“内存”又迁移回电脑上，指代硬盘，只能说误会久矣…</p>
]]></content>
      <categories>
        <category>内存布局</category>
      </categories>
      <tags>
        <tag>RAM</tag>
        <tag>ROM</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot入门</title>
    <url>/post/a06b7d48/</url>
    <content><![CDATA[<h1 id="Spring-Boot-入门"><a href="#Spring-Boot-入门" class="headerlink" title="[Spring Boot 入门]"></a>[Spring Boot 入门]</h1><p><a href="http://t.cn/AirXJZuO">百度百科</a></p>
<p><strong>优点</strong></p>
<blockquote>
<ul>
<li>快速创建独立运行的Spring项目以及与主流框架集成</li>
<li>使用嵌入式的Servlet容器，应用无需打成WAR包</li>
<li>starters自动依赖与版本控制</li>
<li>大量的自动配置，简化开发，也可修改默认值</li>
<li>无需配置XML，无代码生成，开箱即用</li>
<li>准生产环境的运行时应用监控</li>
<li>与云计算的天然集成</li>
</ul>
</blockquote>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="[微服务]"></a>[微服务]</h2><blockquote>
<p>2014，martin fowler</p>
<p>微服务：架构风格（服务微化）</p>
<p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p>
<p>单体应用：ALL IN ONE</p>
<p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p>
<p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa">详细参照微服务文档</a></p>
<p><a href="https://blog.csdn.net/qq_37788067/article/details/79250623">集群、分布式、微服务概念和区别</a></p>
</blockquote>
<h2 id="环境约束"><a href="#环境约束" class="headerlink" title="[环境约束]"></a>[环境约束]</h2><p>–jdk1.8：Spring Boot 推荐jdk1.7及以上；</p>
<p>–maven3.x：maven 3.3以上版本；</p>
<h2 id="Maven设置"><a href="#Maven设置" class="headerlink" title="[Maven设置]"></a>[Maven设置]</h2><p>给maven 的settings.xml配置文件的profiles标签添加：（设置使用的jdk版本）</p>
<p>开发工具中的maven设置为自己配置的maven</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="创建一个maven工程"><a href="#创建一个maven工程" class="headerlink" title="[创建一个maven工程]"></a>[创建一个maven工程]</h2><ol>
<li><p>导入spring boot相关的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写一个主程序；启动Spring Boot应用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> con.nolva.springboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * springBootApplication：标注一个主程序类，表示这个是一个Springboot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//启动</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写一个Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nolva.springboot.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RestController：是spring4里的新注解，是<span class="doctag">@ResponseBody</span>和<span class="doctag">@Controller</span>的缩写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello SpringBoot,this is my first Application&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行主程序Main方法测试</p>
</li>
<li><p>访问 <a href="http://localhost:8080/hello">localhost:8080/hello</a></p>
</li>
</ol>
<h2 id="简化部署"><a href="#简化部署" class="headerlink" title="[简化部署]"></a>[简化部署]</h2><ol>
<li><p>添加maven插件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用mvn package进行打包</p>
</li>
<li><p>进入打包好的jar包所在目录</p>
</li>
<li><p>使用 <code>java -jar jar包名称</code> 运行</p>
</li>
</ol>
<h2 id="Hello-World探究"><a href="#Hello-World探究" class="headerlink" title="[Hello World探究]"></a>[Hello World探究]</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="[依赖]"></a>[依赖]</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">  &lt;!--Hello World项目的父工程是org.springframework.boot--&gt;</span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;relativePath/&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!--</span><br><span class="line">      org.springframework.boot他的父项目是spring-boot-dependencies</span><br><span class="line">      他来真正管理Spring Boot应用里面的所有依赖版本；</span><br><span class="line">      Spring Boot的版本仲裁中心；</span><br><span class="line">      以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）</span><br><span class="line">  --&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">  &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>
<h3 id="启动器"><a href="#启动器" class="headerlink" title="[启动器]"></a>[启动器]</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>spring-boot-starter</strong>-<code>web</code>：</p>
<p> spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</p>
<p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p>
<h3 id="主程序类，主入口类"><a href="#主程序类，主入口类" class="headerlink" title="[主程序类，主入口类]"></a>[主程序类，主入口类]</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//启动</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@SpringBootApplication</code>: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<p>看一下<code>@SpringBootApplication</code>这个注解类的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span>    <span class="comment">//可以给一个类型进行注解，比如类、接口、枚举</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>    <span class="comment">//可以保留到程序运行的时候，它会被加载进入到 JVM 中</span></span><br><span class="line"><span class="meta">@Documented</span>    <span class="comment">//将注解中的元素包含到 Javadoc 中去。</span></span><br><span class="line"><span class="meta">@Inherited</span>    <span class="comment">//继承，比如A类上有该注解，B类继承A类，B类就也拥有该注解</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*创建一个配置类，在配置类上添加 @ComponentScan 注解。</span></span><br><span class="line"><span class="comment">*该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 &lt;context:component-scan&gt;。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>@SpringBootConfiguration</code>：Spring Boot的配置类；标注在某个类上，表示这是一个Spring Boot的配置类；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>@Configuration</code>：配置类上来标注这个注解；</p>
<p>配置类 ——- 配置文件；配置类也是容器中的一个组件；@Component</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>@EnableAutoConfiguration</code>：开启自动配置功能；</p>
<p>以前我们需要配置的东西，Spring Boot帮我们自动配置；@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能；这样自动配置才能生效；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>@AutoConfigurationPackage</code>：自动配置包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>@Import</code>：Spring的底层注解@Import，给容器中导入一个组件</p>
<p>导入的组件由<code>org.springframework.boot.autoconfigure.AutoConfigurationPackages.Registrar</code>将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</p>
<p><img src="/post/a06b7d48/1573637120233.png" alt="DEBUG"></p>
<p>这里controller包是在主程序所在的包下，所以会被扫描到，我们在springboot包下创建一个test包，把主程序放在test包下，这样启动就只会去扫描test包下的内容而controller包就不会被扫描到，再访问开始的hello就是404</p>
<p><img src="/post/a06b7d48/1573637728857.png" alt="DEBUG"></p>
</li>
</ul>
</li>
<li><p><code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code></p>
<p><code>AutoConfigurationImportSelector.class</code>将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；</p>
<p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</p>
<p><img src="/post/a06b7d48/1573638685562.png" alt="Configuration"></p>
</li>
</ul>
</li>
</ul>
<p>Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东西，自动配置类都帮我们完成了；</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot日志</title>
    <url>/post/defeb1f7/</url>
    <content><![CDATA[<h1 id="springboot日志配置"><a href="#springboot日志配置" class="headerlink" title="[springboot日志配置]"></a>[springboot日志配置]</h1><h2 id="市面上的日志框架"><a href="#市面上的日志框架" class="headerlink" title="[市面上的日志框架]"></a>[市面上的日志框架]</h2><p><code>JUL</code>、<code>JCL</code>、<code>Jboss-logging</code>、<code>logback</code>、<code>log4j</code>、<code>log4j2</code>、<code>slf4j</code>….</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>日志门面 （日志的抽象层）</th>
<th>日志实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><del>JCL（Jakarta Commons Logging）</del> <strong>SLF4j（Simple Logging Facade for Java）</strong> <del>jboss-loggi</del></td>
<td><del>JUL（java.util.logging）</del> Log4j Log4j2 <strong>Logback</strong></td>
</tr>
</tbody>
</table>
</div>
<p>左边选一个门面（抽象层）、右边来选一个实现；</p>
<p>Log4j2太新颖尚未完全适配，Logback是Log4j的升级版，JUL不如前面的好用</p>
<p>我们的选择：SLF4j—&gt;Logback</p>
<p>SpringBoot选用 <code>SLF4j</code>和<code>logback</code></p>
<h2 id="SLF4j使用"><a href="#SLF4j使用" class="headerlink" title="[SLF4j使用]"></a>[SLF4j使用]</h2><p>如何在系统中使用SLF4j ：<a href="https://www.slf4j.org/">https://www.slf4j.org</a></p>
<p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；（接口调用）</p>
<p>给系统里面导入slf4j的jar和 logback的实现jar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">    logger.info(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/post/defeb1f7/concrete-bindings.png" alt="日志"></p>
<p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件；</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="[遗留问题]"></a>[遗留问题]</h2><p>项目中依赖的框架可能使用不同的日志：</p>
<p>Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p>
<p>当项目是使用多种日志API时，可以统一适配到SLF4J，中间使用SLF4J或者第三方提供的日志适配器适配到SLF4J，SLF4J在底层用开发者想用的一个日志框架来进行日志系统的实现，从而达到了多种日志的统一实现。</p>
<p><img src="/post/defeb1f7/legacy.png" alt="统一日志"></p>
<h3 id="如何让系统中所有的日志都统一到slf4j"><a href="#如何让系统中所有的日志都统一到slf4j" class="headerlink" title="[如何让系统中所有的日志都统一到slf4j]"></a>[如何让系统中所有的日志都统一到slf4j]</h3><ol>
<li>将系统中其他日志框架先排除出去；但是只做排除会导致形如Spring框架无法运行；</li>
<li>用中间包来替换原有的日志框架（适配器的类名和包名与替换的被日志框架一致）；</li>
<li>导入slf4j抽象日志层；</li>
<li>再导入slf4j其他的实现；</li>
</ol>
<h2 id="SpringBoot日志关系"><a href="#SpringBoot日志关系" class="headerlink" title="[SpringBoot日志关系]"></a>[SpringBoot日志关系]</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>SpringBoot使用它来做日志功能；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>spring-boot-starter-logging底层依赖关系</p>
<p><img src="/post/defeb1f7/image-20200802223940215.png" alt="image-20200802223940215"></p>
<p>总结：</p>
<ol>
<li>SpringBoot底层也是使用slf4j+logback的方式进行日志记录</li>
<li>SpringBoot也把其他的日志都替换成了slf4j；</li>
<li>中间替换包？</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="string">&quot;http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> LogFactory logFactory = <span class="keyword">new</span> SLF4JLogFactory();</span><br></pre></td></tr></table></figure>
<p>如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p>
<p>Spring框架用的是commons-logging；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；</strong></p>
<h2 id="日志使用"><a href="#日志使用" class="headerlink" title="[日志使用]"></a>[日志使用]</h2><h3 id="默认配置"><a href="#默认配置" class="headerlink" title="[默认配置]"></a>[默认配置]</h3><p>SpringBoot默认帮我们配置好了日志；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        记录器</span></span><br><span class="line">        Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="comment">//        日志级别：trace &lt; debug &lt; info &lt; warn &lt; error</span></span><br><span class="line"><span class="comment">//        可以调整输出的日志级别，日志只在当前级别及以上才能生效</span></span><br><span class="line">        logger.trace(<span class="string">&quot;这是trace日志...&quot;</span>);</span><br><span class="line">        logger.debug(<span class="string">&quot;这是debug日志...&quot;</span>);</span><br><span class="line"><span class="comment">//        SpringBoot默认使用的是info级别，没有指定就使用默认的root级别</span></span><br><span class="line">        logger.info(<span class="string">&quot;这是info日志...&quot;</span>);</span><br><span class="line">        logger.warn(<span class="string">&quot;这是warn日志...&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;这是error日志...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line">    日志输出格式：</span><br><span class="line">        %d表示日期时间，</span><br><span class="line">        %thread表示线程名，</span><br><span class="line">        %-<span class="number">5l</span>evel：级别从左显示<span class="number">5</span>个字符宽度</span><br><span class="line">        %logger&#123;<span class="number">50</span>&#125; 表示logger名字最长<span class="number">50</span>个字符，否则按照句点分割。 </span><br><span class="line">        %msg：日志消息，</span><br><span class="line">        %n是换行符</span><br><span class="line">    --&gt;</span><br><span class="line">    %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-<span class="number">5l</span>evel %logger&#123;<span class="number">50</span>&#125; - %msg%n</span><br></pre></td></tr></table></figure>
<h3 id="SpringBoot修改日志的默认配置"><a href="#SpringBoot修改日志的默认配置" class="headerlink" title="[SpringBoot修改日志的默认配置]"></a>[SpringBoot修改日志的默认配置]</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 也可以指定一个包路径 logging.level.com.xxx=error</span></span><br><span class="line"><span class="meta">logging.level.root</span>=<span class="string">error</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.path=</span></span><br><span class="line"><span class="comment"># 不指定路径在当前项目下生成springboot.log日志</span></span><br><span class="line"><span class="comment"># 可以指定完整的路径；</span></span><br><span class="line"><span class="comment">#logging.file=G:/springboot.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件</span></span><br><span class="line"><span class="meta">logging.path</span>=<span class="string">/spring/log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  在控制台输出的日志的格式</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"><span class="comment"># 指定文件中日志输出的格式</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>logging.file</th>
<th>logging.path</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>(none)</td>
<td>(none)</td>
<td></td>
<td>只在控制台输出</td>
</tr>
<tr>
<td>指定文件名</td>
<td>(none)</td>
<td>my.log</td>
<td>输出日志到my.log文件</td>
</tr>
<tr>
<td>(none)</td>
<td>指定目录</td>
<td>/var/log</td>
<td>输出到指定目录的 spring.log 文件中</td>
</tr>
</tbody>
</table>
</div>
<h3 id="指定配置"><a href="#指定配置" class="headerlink" title="[指定配置]"></a>[指定配置]</h3><p>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Logging System</th>
<th>Customization</th>
</tr>
</thead>
<tbody>
<tr>
<td>Logback</td>
<td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> or <code>logback.groovy</code></td>
</tr>
<tr>
<td>Log4j2</td>
<td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td>
</tr>
<tr>
<td>JDK (Java Util Logging)</td>
<td><code>logging.properties</code></td>
</tr>
</tbody>
</table>
</div>
<p>logback.xml：直接就被日志框架识别了；</p>
<p><strong>logback-spring.xml</strong>：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;staging&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;</span></span><br><span class="line">      可以指定某段配置只在某个环境下生效</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;stdout&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        日志输出格式：</span></span><br><span class="line"><span class="comment">            %d表示日期时间，</span></span><br><span class="line"><span class="comment">            %thread表示线程名，</span></span><br><span class="line"><span class="comment">            %-5level：级别从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">            %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span></span><br><span class="line"><span class="comment">            %msg：日志消息，</span></span><br><span class="line"><span class="comment">            %n是换行符</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;!dev&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">no applicable action for [springProfile]</span><br></pre></td></tr></table></figure>
<h2 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="[切换日志框架]"></a>[切换日志框架]</h2><p>可以按照slf4j的日志适配图，进行相关的切换；</p>
<p>slf4j+log4j的方式；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 排除logback-classic和log4j-over-slf4j，因为我们就需要log4j，不用转换成slf4j。并添加slf4j-log4j12 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>切换为log4j2</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 排除starter-logging并添加spring-boot-starter-log4j2 --&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot的Web开发</title>
    <url>/post/a826c23d/</url>
    <content><![CDATA[<h1 id="SpringBoot-Web开发"><a href="#SpringBoot-Web开发" class="headerlink" title="[SpringBoot Web开发]"></a>[SpringBoot Web开发]</h1><ol>
<li>创建SpringBoot应用，选中我们需要的模块</li>
<li>SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来</li>
<li>自己编写业务代码</li>
</ol>
<h2 id="web自动配置规则"><a href="#web自动配置规则" class="headerlink" title="[web自动配置规则]"></a>[web自动配置规则]</h2><ol>
<li>WebMvcAutoConfiguration</li>
<li>WebMvcProperties</li>
<li>ViewResolver自动配置</li>
<li>静态资源自动映射</li>
<li>Formatter与Converter自动配置</li>
<li>HttpMessageConverter自动配置</li>
<li>静态首页</li>
<li>favicon</li>
<li>错误处理</li>
</ol>
<h2 id="SpringBoot对静态资源的映射规则"><a href="#SpringBoot对静态资源的映射规则" class="headerlink" title="[SpringBoot对静态资源的映射规则]"></a>[SpringBoot对静态资源的映射规则]</h2><p><code>WebMvcAutoConfiguration</code>类的<code>addResourceHandlers</code>方法：（添加资源映射）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">        CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">        <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">&quot;/webjars/**&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;/webjars/**&quot;</span>&#125;).addResourceLocations(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>&#125;).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">        <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations())).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有 <code>/webjars/**</code> ，都去 <code>classpath:/META-INF/resources/webjars/</code> 找资源</p>
<p><code>webjars</code>：以jar包的方式引入静态资源；</p>
<p><a href="https://www.webjars.org/">webjars官网</a></p>
<p><img src="/post/a826c23d/1573815091111.png" alt="1573815091111"></p>
<p>例如：添加jquery的webjars</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/post/a826c23d/1573815506777.png" alt="1573815506777"></p>
<p>访问地址对应就是：<a href="http://localhost:8080/webjars/jquery/3.4.1/jquery.js">http://localhost:8080/webjars/jquery/3.4.1/jquery.js</a></p>
<h2 id="非webjars，自己的静态资源怎么访问"><a href="#非webjars，自己的静态资源怎么访问" class="headerlink" title="[非webjars，自己的静态资源怎么访问]"></a>[非webjars，自己的静态资源怎么访问]</h2><p><strong>资源配置类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 说明可以在配置文件中配置静态资源的相关参数，缓存时间等</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(    </span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.resources&quot;,</span></span><br><span class="line"><span class="meta">    ignoreUnknownFields = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>, <span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> String[] staticLocations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> addMappings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties.Chain chain;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties.Cache cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line">        <span class="keyword">this</span>.addMappings = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.chain = <span class="keyword">new</span> ResourceProperties.Chain();</span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> ResourceProperties.Cache();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/post/a826c23d/1573817274649.png" alt="1573817274649"></p>
<p>上图中添加的映射访问路径<code>staticPathPattern</code>值是<code>/**</code>，对应的资源文件夹就是上面配置类<code>ResourceProperties</code>中的<code>CLASSPATH_RESOURCE_LOCATIONS</code>数组中的文件夹：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数组中的值（静态资源文件夹）</th>
<th>在项目中的位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>classpath:/META-INF/resources/</td>
<td>src/main/resources/META-INF/resources/</td>
</tr>
<tr>
<td>classpath:/resources/</td>
<td>src/main/resources/resources/</td>
</tr>
<tr>
<td>classpath:/static/</td>
<td>src/main/resources/static/</td>
</tr>
<tr>
<td>classpath:/public/</td>
<td>src/main/resources/public/</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/post/a826c23d/v2-d19fc37be2bc50c058752bdc1ae392b0_720w.jpg" alt="img" style="zoom:33%;"></p>
<p><code>/**</code>访问当前项目的任何资源，（静态资源文件夹）</p>
<p>当找不到相关映射处理的时候，默认从上面的静态资源文件夹</p>
<p>localhost:8080/asserts/js/Chart.min.js —-&gt; 去静态资源文件夹里面找Chart.min.js</p>
<h2 id="欢迎页映射"><a href="#欢迎页映射" class="headerlink" title="[欢迎页映射]"></a>[欢迎页映射]</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置欢迎页映射</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> </span>&#123;</span><br><span class="line">        WelcomePageHandlerMapping welcomePageHandlerMapping = <span class="keyword">new</span> WelcomePageHandlerMapping(<span class="keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, <span class="keyword">this</span>.getWelcomePage(), <span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">        welcomePageHandlerMapping.setInterceptors(<span class="keyword">this</span>.getInterceptors(mvcConversionService, mvcResourceUrlProvider));</span><br><span class="line">        welcomePageHandlerMapping.setCorsConfigurations(<span class="keyword">this</span>.getCorsConfigurations());</span><br><span class="line">        <span class="keyword">return</span> welcomePageHandlerMapping;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Optional&lt;Resource&gt; <span class="title">getWelcomePage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String[] locations = WebMvcAutoConfiguration.getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line">                <span class="keyword">return</span> Arrays.stream(locations).map(<span class="keyword">this</span>::getIndexHtml).filter(<span class="keyword">this</span>::isReadable).findFirst();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Resource <span class="title">getIndexHtml</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.resourceLoader.getResource(location + <span class="string">&quot;index.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/post/a826c23d/1573819949494.png" alt="1573819949494"></p>
<p><code>location</code>就是静态资源路径，所以欢迎页的页面就是上面静态资源下的<code>index.html</code>，被<code>/**</code>映射，因此直接访问项目localhost:8080就是访问欢迎页</p>
<h2 id="Spring-Boot不同版本对Favicon的支持"><a href="#Spring-Boot不同版本对Favicon的支持" class="headerlink" title="[Spring Boot不同版本对Favicon的支持]"></a>[Spring Boot不同版本对Favicon的支持]</h2><p>在早些版本中Spring Boot对Favicon进行了默认支持，并且通过如下配置进行关闭操作：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">spring.mvc.favicon.enabled=false ## 关闭</span><br></pre></td></tr></table></figure>
<p>默认显示效果如下：</p>
<p><img src="/post/a826c23d/favicon-1.jpg" alt="image"></p>
<p>但在Spring Boot项目的issues中提出，如果提供默认的Favicon可能会导致网站信息泄露。如果用户不进行自定义的Favicon的设置，而Spring Boot项目会提供默认的上图图标，那么势必会导致泄露网站的开发框架。</p>
<p>因此，在Spring Boot2.2.x中，将默认的favicon.ico移除，同时也不再提供上述application.properties中的属性配置。更多详细信息可查看对应的issue：<a href="https://github.com/spring-projects/spring-boot/issues/17925。">https://github.com/spring-projects/spring-boot/issues/17925。</a></p>
<h2 id="SpringBoot2-x项目中添加Favicon"><a href="#SpringBoot2-x项目中添加Favicon" class="headerlink" title="[SpringBoot2.x项目中添加Favicon]"></a>[SpringBoot2.x项目中添加Favicon]</h2><p>既然在当前版本中Spring Boot不支持默认的Favicon，我们就来看看如何自定义网站的Favicon。</p>
<p>我们可以在static目录下创建一个images目录，里面存放自己的Favicon.ico图标。</p>
<p><img src="/post/a826c23d/v2-f94a2b16cddf45ae68cc5db0cb7df5e0_720w.jpg" alt="img"></p>
<h2 id="html页面中添加"><a href="#html页面中添加" class="headerlink" title="[html页面中添加]"></a>[html页面中添加]</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Login&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; href=&quot;images/Favicon.ico&quot; type=&quot;image/x-icon&quot;/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;一一哥的登录页面...&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Thymeleaf页面中添加"><a href="#Thymeleaf页面中添加" class="headerlink" title="[Thymeleaf页面中添加]"></a>[Thymeleaf页面中添加]</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;/&gt;</span><br><span class="line">&lt;title&gt;Hello Favicon&lt;/title&gt;</span><br><span class="line">&lt;link rel=&quot;icon&quot; th:href=&quot;@&#123;/favicon.ico&#125;&quot; type=&quot;image/x-icon&quot;/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="重启项目测试"><a href="#重启项目测试" class="headerlink" title="[重启项目测试]"></a>[重启项目测试]</h2><p>我们重新访问页面，可以看到Favicon图标已经换成了我自己的图标。</p>
<p><img src="/post/a826c23d/v2-562e5e178dbd8a40875d989344c09623_720w.jpg" alt="img"></p>
<p>上述方式有一个弊端，那就是需要在每个展示的页面中都添加对应的代码。</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot的自动配置原理</title>
    <url>/post/7fc7b961/</url>
    <content><![CDATA[<h1 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="[自动配置原理]"></a>[自动配置原理]</h1><p>配置文件到底能写什么？怎么写？自动配置原理；</p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/htmlsingle/#common-application-properties">配置文件能配置的属性参照</a></p>
<p><strong>自动配置原理：</strong></p>
<p>SpringBoot启动的时候加载主配置类，开启了自动配置功能@<strong>EnableAutoConfiguration</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">    @EnableAutoConfiguration</span><br><span class="line">    	@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">    		AutoConfigurationImportSelector类</span><br></pre></td></tr></table></figure>
<h2 id="EnableAutoConfiguration-作用"><a href="#EnableAutoConfiguration-作用" class="headerlink" title="[@EnableAutoConfiguration 作用]"></a>[@EnableAutoConfiguration 作用]</h2><ul>
<li><p>利用EnableAutoConfigurationImportSelector给容器中导入一些组件</p>
</li>
<li><p>插入组件的selectImports方法调用了getAutoConfigurationEntry</p>
</li>
<li><p>getAutoConfigurationEntry方法中的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取候选的配置，经处理后返回</span><br><span class="line">List&lt;String&gt; configurations &#x3D; getCandidateConfigurations(annotationMetadata,attributes);</span><br></pre></td></tr></table></figure>
</li>
<li><p>getCandidateConfigurations方法中，SpringFactoriesLoader.loadFactoryNames()，扫描所有jar包类路径下 <code>META-INF/spring.factories</code>，把扫描到的这些文件的内容(url)包装成Properties对象，从Properties中获取到EnableAutoConfiguration.class（类名）对应的值，然后把它们添加在容器中.</p>
</li>
<li><p><strong>==将类路径下的 META-INFO/spring.fatories里面配置的所有EnableAutoConfiguration的值都加入到了容器==</strong></p>
<p><img src="/post/7fc7b961/image-20200802215739477.png![image-20200802215847773](Spring-Boot的自动配置原理/image-20200802215847773.png" alt="image-20200802215739477"></p>
</li>
<li><p>每一个这样的 <code>xxxAutoConfiguration</code>类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p>
</li>
<li><p>每一个自动配置类进行自动配置功能；</p>
</li>
</ul>
<h2 id="以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理"><a href="#以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理" class="headerlink" title="[以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理]"></a>[以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理]</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web.servlet;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动指定类的ConfigurationProperties功能；</span></span><br><span class="line"><span class="comment"> * 将配置文件中对应的值和HttpProperties绑定起来；</span></span><br><span class="line"><span class="comment"> * 并把HttpProperties加入到ioc容器中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;HttpProperties.class&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring底层<span class="doctag">@Conditional</span>注解</span></span><br><span class="line"><span class="comment"> * 根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；</span></span><br><span class="line"><span class="comment"> * 判断当前应用是否是web应用，如果是，当前配置类生效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(</span></span><br><span class="line"><span class="meta">    type = Type.SERVLET</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前项目有没有这个类</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment"> * 即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.http.encoding&quot;,</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;enabled&quot;&#125;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//它已经和SpringBoot的配置文件映射了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Encoding properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有一个有参构造器的情况下，参数的值会从容器中拿</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties.getEncoding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>     <span class="comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>    <span class="comment">//判断容器有没有这个组件？（容器中没有才会添加这个组件）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<ol>
<li>根据当前不同的条件判断，决定这个配置类是否生效</li>
<li>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</li>
</ol>
<p><strong>所有在配置文件中能配置的属性都是在<code>xxxxProperties</code>类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.http&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> logRequestDetails;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpProperties.Encoding encoding = <span class="keyword">new</span> HttpProperties.Encoding();</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="[总结]"></a>[总结]</h2><ul>
<li>SpringBoot启动会加载大量的自动配置类</li>
<li>我们看我们需要的功能有没有SpringBoot默认写好的自动配置类</li>
<li>再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</li>
<li>给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值</li>
</ul>
<p><code>xxxxAutoConfigurartion</code>：自动配置类；</p>
<p><code>xxxxProperties</code>：封装配置文件中相关属性；</p>
<h2 id="Conditional派生注解"><a href="#Conditional派生注解" class="headerlink" title="[@Conditional派生注解]"></a>[@Conditional派生注解]</h2><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>@Conditional扩展注解</th>
<th>作用（判断是否满足当前指定条件）</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ConditionalOnJava</td>
<td>系统的java版本是否符合要求</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>容器中存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>容器中不存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足SpEL表达式指定</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>系统中有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>系统中没有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定的属性是否有指定的值</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下是否存在指定资源文件</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前是web环境</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前不是web环境</td>
</tr>
<tr>
<td>@ConditionalOnJndi</td>
<td>JNDI存在指定项</td>
</tr>
</tbody>
</table>
</div>
<h2 id="查看那些自动配置类生效了"><a href="#查看那些自动配置类生效了" class="headerlink" title="[查看那些自动配置类生效了]"></a>[查看那些自动配置类生效了]</h2><p>自动配置类必须在一定的条件下才能生效；</p>
<p>我们怎么知道哪些自动配置类生效了；</p>
<p>我们可以通过配置文件启用 <code>debug=true</code>属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</p>
<ul>
<li><code>Positive matches</code> ：（自动配置类启用的）</li>
<li><code>Negative matches</code>：（没有启动，没有匹配成功的自动配置类）</li>
</ul>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot配置文件</title>
    <url>/post/99fd0336/</url>
    <content><![CDATA[<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="[配置文件]"></a>[配置文件]</h1><p>SpringBoot使用一个全局的配置文件，配置文件名<code>application</code>是固定的；</p>
<ul>
<li>application.properties</li>
<li>application.yml</li>
<li>application.yaml</li>
</ul>
<p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p>
<h2 id="YAML"><a href="#YAML" class="headerlink" title="[YAML]"></a>[YAML]</h2><p>YAML（YAML Ain’t Markup Language）</p>
<p> YAML A Markup Language：是一个标记语言</p>
<p> YAML isn’t Markup Language：不是一个标记语言；</p>
<p>标记语言：</p>
<p> 以前的配置文件；大多都使用的是 <strong>xxxx.xml</strong>文件；</p>
<p> YAML：<strong>以数据为中心</strong>，比json、xml等更适合做配置文件；</p>
<h3 id="YAML语法"><a href="#YAML语法" class="headerlink" title="[YAML语法]"></a>[YAML语法]</h3><p>以<code>空格</code>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p>
<p>次等级的前面是空格，不能使用制表符(tab)</p>
<p>冒号之后如果有值，那么冒号和值之间至少有一个空格，不能紧贴着</p>
<h3 id="字面量：普通的值（数字，字符串，布尔）"><a href="#字面量：普通的值（数字，字符串，布尔）" class="headerlink" title="[字面量：普通的值（数字，字符串，布尔）]"></a>[字面量：普通的值（数字，字符串，布尔）]</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k: v</span><br></pre></td></tr></table></figure>
<p>字符串默认不用加上单引号或者双引号；</p>
<p><code>&quot;&quot;</code>：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p>
<p><em>eg：</em> name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi</p>
<p><code>&#39;&#39;</code>：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p>
<p><em>eg：</em> name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi</p>
<h3 id="对象、Map（属性和值）"><a href="#对象、Map（属性和值）" class="headerlink" title="[对象、Map（属性和值）]"></a>[对象、Map（属性和值）]</h3><p><code>k: v</code>在下一行来写对象的属性和值的关系；注意缩进</p>
<ol>
<li>```yaml<br>person:<br>  name: 张三<br>  gender: 男<br>  age: 22<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 行内写法</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;yaml</span><br><span class="line">   person: &#123;name: 张三,gender: 男,age: 22&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数组（List、Set）"><a href="#数组（List、Set）" class="headerlink" title="[数组（List、Set）]"></a>[数组（List、Set）]</h3><ol>
<li>```<br>fruits: <ul>
<li>苹果</li>
<li>桃子</li>
<li>香蕉<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 行内写法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
fruits: [苹果,桃子,香蕉]<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## [配置文件值注入]</span><br><span class="line"></span><br><span class="line">&lt;details style&#x3D;&quot;-webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); text-size-adjust: none; box-sizing: border-box; user-select: text !important; text-shadow: transparent 0px 0px 0px, rgba(0, 0, 0, 0.68) 0px 0px 0px !important; font-size: 15px; color: rgb(52, 73, 94); font-family: &quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial;&quot;&gt;&lt;summary style&#x3D;&quot;-webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); text-size-adjust: none; box-sizing: border-box; user-select: text !important; text-shadow: transparent 0px 0px 0px, rgba(0, 0, 0, 0.68) 0px 0px 0px !important; font-weight: bold; color: green;&quot;&gt;JavaBean：&lt;&#x2F;summary&gt;&lt;&#x2F;details&gt;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;xml</span><br><span class="line">        &lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><strong>配置文件：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">张三</span></span><br><span class="line">  <span class="attr">gender:</span> <span class="string">男</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">36</span></span><br><span class="line">  <span class="attr">boss:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">1982</span><span class="string">/10/1</span></span><br><span class="line">  <span class="attr">maps:</span> &#123;<span class="attr">k1:</span> <span class="string">v1</span>,<span class="attr">k2:</span> <span class="string">v2</span>&#125;</span><br><span class="line">  <span class="attr">lists:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">apple</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">peach</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">banana</span></span><br><span class="line">  <span class="attr">pet:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">小狗</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nolva.initializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.nolva.initializer.bean.Person;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloworldquickstartApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="properties"><a href="#properties" class="headerlink" title="[properties]"></a>[properties]</h2><p>上面yaml对应的properties配置文件写法</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">person.name</span>=<span class="string">李四</span></span><br><span class="line"><span class="meta">person.age</span>=<span class="string">34</span></span><br><span class="line"><span class="meta">person.birth</span>=<span class="string">1986/09/12</span></span><br><span class="line"><span class="meta">person.boss</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">person.gender</span>=<span class="string">女</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">cat,dog,pig</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">v2</span></span><br><span class="line"><span class="meta">person.pet.name</span>=<span class="string">&quot;小黑&quot;</span></span><br><span class="line"><span class="meta">person.pet.age</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure>
<p>测试，发现中文会乱码，而且char类型还会抛出Failed to bind properties under ‘person.gender’ to java.lang.Character异常</p>
<h3 id="中文乱码解决方法"><a href="#中文乱码解决方法" class="headerlink" title="[中文乱码解决方法]"></a>[中文乱码解决方法]</h3><p>在设置中找到<code>File Encodings</code>，将配置文件字符集改为<code>UTF-8</code>，并勾选：</p>
<ul>
<li><code>Transparent native-to-ascii conversion</code></li>
</ul>
<p><img src="/post/99fd0336/1573695616496.png" alt="乱码解决"></p>
<p>yaml和properties配置文件同时存在，properties配置文件的内容会覆盖yaml配置文件的内容</p>
<h2 id="配置文件值注入两种方式对比"><a href="#配置文件值注入两种方式对比" class="headerlink" title="[配置文件值注入两种方式对比]"></a>[配置文件值注入两种方式对比]</h2><p>配置文件值注入有两种方式，一个是Spring Boot的<code>@ConfigurationProperties</code>注解，另一个是spring原先的<code>@value</code>注解</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能</td>
<td>批量注入配置文件中的属性</td>
<td>一个个指定</td>
</tr>
<tr>
<td>松散绑定（松散语法）</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
</div>
<p><strong>松散绑定</strong>：例如Person中有<code>lastName</code>属性，在配置文件中可以写成</p>
<p><code>lastName</code>或<code>lastname</code>或<code>last-name</code>或<code>last_name</code>等等</p>
<p><strong>SpEL</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##　properties配置文件</span><br><span class="line">persion.age&#x3D;#&#123;2019-1986+1&#125;</span><br><span class="line"></span><br><span class="line"># Person类</span><br><span class="line">#--------------------使用@ConfigurationProperties注解，会抛出异常--------------------</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--------------------使用@value注解 OK--------------------</span><br><span class="line">@Component</span><br><span class="line">public class Person &#123;</span><br><span class="line">    @Value(&quot;$&#123;person.age&#125;&quot;)</span><br><span class="line">    private Integer age;</span><br></pre></td></tr></table></figure>
<p><strong>JSR303数据校验</strong></p>
<p><code>@ConfigurationProperties</code>支持校验，如果校验不通过，会抛出异常</p>
<p><img src="/post/99fd0336/1573716216690.png" alt="数据校验"></p>
<p><code>@value</code>注解不支持数据校验</p>
<p><img src="/post/99fd0336/1573716427494.png" alt="数据校验"></p>
<p><strong>复杂类型封装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@value&#96;注解无法注入map等对象的复杂类型，但&#96;list、数组可以</span><br></pre></td></tr></table></figure>
<p><img src="/post/99fd0336/1573716770263.png" alt="1573716770263"></p>
<h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="[@PropertySource]"></a>[@PropertySource]</h2><p><code>@PropertySource</code>注解的作用是加载指定的配置文件，值可以是数组，也就是可以加载多个配置文件</p>
<p>springboot默认加载的配置文件名是<code>application</code>，如果配置文件名不是这个是不会被容器加载的，所以这里Person并没有被注入任何属性值</p>
<p><img src="/post/99fd0336/1573718577827.png" alt="1573718577827"></p>
<p>使用<code>@PropertySource(&#123;&quot;classpath:person.properties&quot;&#125;)</code>指定加载<code>person.properties</code>配置文件</p>
<p><img src="/post/99fd0336/1573718679208.png" alt="1573718679208"></p>
<p>使用这个注解加载配置文件就需要配置类使用@component等注解而不是等待@EnableConfigurationProperties激活m，而且不支持yaml，只能是properties</p>
<h2 id="ImportResource"><a href="#ImportResource" class="headerlink" title="[@ImportResource]"></a>[@ImportResource]</h2><p><code>@ImportResource</code>注解用于导入Spring的配置文件，让配置文件里面的内容生效；(就是以前写的springmvc.xml、applicationContext.xml)</p>
<p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；</p>
<p><img src="/post/99fd0336/1573719440710.png" alt="1573719440710"></p>
<p>想让Spring的配置文件生效，加载进来；@<strong>ImportResource</strong>标注在一个配置类上</p>
<p><img src="/post/99fd0336/1573720006428.png" alt="1573720006428"></p>
<p>注意！这个注解是放在主入口函数的类上，而不是测试类上</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="[@Configuration]"></a>[@Configuration]</h2><p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p>
<p>配置类<strong>@Configuration</strong> —-equals—-&gt; Spring配置文件</p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="[@Bean]"></a>[@Bean]</h3><p>使用<strong>@Bean</strong>给容器中添加组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nolva.initializer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.nolva.initializer.bean.Pet;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *相当于在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">myPet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Pet pet = <span class="keyword">new</span> Pet();</span><br><span class="line">        pet.setName(<span class="string">&quot;嘟嘟&quot;</span>);</span><br><span class="line">        pet.setAge(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> pet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="[配置文件占位符]"></a>[配置文件占位符]</h2><p><strong>随机</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;random.value&#125;</span><br><span class="line">$&#123;random.int&#125;</span><br><span class="line">$&#123;random.long&#125;</span><br><span class="line">$&#123;random.int(10)&#125;</span><br><span class="line">$&#123;random.int[1024,65536]&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/post/99fd0336/1573721695426.png" alt="1573721695426"></p>
<p>可以引用在配置文件中配置的其他属性的值，如果使用一个没有在配置文件中的属性，则会原样输出</p>
<p><img src="/post/99fd0336/1573722018302.png" alt="1573722018302"></p>
<p>可以使用<code>:</code>指定默认值</p>
<p><img src="/post/99fd0336/1573722098119.png" alt="1573722098119"></p>
<h2 id="Profile"><a href="#Profile" class="headerlink" title="[Profile]"></a>[Profile]</h2><p>Profile是Spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境</p>
<h3 id="多profile文件形式"><a href="#多profile文件形式" class="headerlink" title="[多profile文件形式]"></a>[多profile文件形式]</h3><p>文件名格式：application-{profile}.properties/yml，例如：</p>
<ul>
<li>application-dev.properties</li>
<li>application-prod.properties</li>
</ul>
<p><img src="/post/99fd0336/1573723830627.png" alt="1573723830627"></p>
<p>程序启动时会默认加载<code>application.properties</code>，启动的端口就是8080</p>
<p>可以在主配置文件中指定激活哪个配置文件</p>
<p><img src="/post/99fd0336/1573724084979.png" alt="1573724084979"></p>
<h3 id="yml支持多文档块方式"><a href="#yml支持多文档块方式" class="headerlink" title="[yml支持多文档块方式]"></a>[yml支持多文档块方式]</h3><p>每个文档块使用<code>---</code>分割</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure>
<p><img src="/post/99fd0336/1573724588671.png" alt="1573724588671"></p>
<h3 id="激活指定profile的三种方式"><a href="#激活指定profile的三种方式" class="headerlink" title="[激活指定profile的三种方式]"></a>[激活指定profile的三种方式]</h3><ol>
<li><p>在配置文件中指定 spring.profiles.active=dev（如上）</p>
</li>
<li><p>项目打包后在命令行启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar xxx.jar --spring.profiles.active=dev；</span><br></pre></td></tr></table></figure>
<p><img src="/post/99fd0336/1573724952868.png" alt="1573724952868"></p>
</li>
<li><p>虚拟机参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Dspring.profiles.active&#x3D;dev</span><br></pre></td></tr></table></figure>
<p><img src="/post/99fd0336/image-20200801130511865.png" alt="image-20200801130511865"></p>
</li>
</ol>
<h2 id="配置文件加载位置"><a href="#配置文件加载位置" class="headerlink" title="[配置文件加载位置]"></a>[配置文件加载位置]</h2><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- file: .&#x2F;config&#x2F;</span><br><span class="line"></span><br><span class="line">- file: .&#x2F;</span><br><span class="line"></span><br><span class="line">- classpath: &#x2F;config&#x2F;</span><br><span class="line"></span><br><span class="line">- classpath: &#x2F;</span><br></pre></td></tr></table></figure>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置（优先级低的先加载）；</p>
<p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置</strong>；</p>
<p><img src="/post/99fd0336/image-20200801130132269.png" alt="image-20200801130132269"></p>
<p>这里项目根路径下的配置文件maven编译时不会打包过去，需要修改pom</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>.<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yaml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们还可以通过<code>spring.config.location</code>来改变默认的配置文件位置</p>
<p><strong>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar xxx.jar --spring.config.location&#x3D;&#x2F;home&#x2F;cloudlandboy&#x2F;application.yamlCopy</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="外部配置加载顺序"><a href="#外部配置加载顺序" class="headerlink" title="[外部配置加载顺序]"></a>[外部配置加载顺序]</h2><p><strong>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</strong></p>
<ol>
<li><p><strong>命令行参数</strong> </p>
<p>所有的配置都可以在命令行上进行指定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar xxx.jar --server.port&#x3D;8087  --server.context-path&#x3D;&#x2F;abc</span><br></pre></td></tr></table></figure>
<p>多个配置用空格分开； —配置项=值</p>
</li>
<li><p>来自java:comp/env的JNDI属性 ⤴️</p>
</li>
<li><p>Java系统属性（System.getProperties()） ⤴️</p>
</li>
<li><p>操作系统环境变量 ⤴️</p>
</li>
<li><p>RandomValuePropertySource配置的random.*属性值 ⤴️</p>
</li>
</ol>
<p><strong>由jar包外向jar包内进行寻找</strong></p>
<p><strong>再来加载不带profile</strong></p>
<ol>
<li><p><strong>jar包外部的<code>application-&#123;profile&#125;.properties</code>或<code>application.yml</code>(带spring.profile)配置文件 ⤴️</strong></p>
</li>
<li><p><strong>jar包内部的<code>application-&#123;profile&#125;.properties</code>或<code>application.yml</code>(带spring.profile)配置文件 ⤴️</strong></p>
</li>
</ol>
<p><strong>优先加载带profile</strong></p>
<ol>
<li><p><strong>jar包外部的<code>application.properties</code>或<code>application.yml</code>(不带spring.profile)配置文件</strong> ⤴️</p>
</li>
<li><p><strong>jar包内部的<code>application.properties</code>或<code>application.yml</code>(不带spring.profile)配置文件 ⤴️</strong></p>
</li>
</ol>
<ol>
<li><p>@Configuration注解类上的@PropertySource ⤴️</p>
</li>
<li><p>通过SpringApplication.setDefaultProperties指定的默认属性 ⤴️</p>
</li>
</ol>
<p>所有支持的配置加载来源：</p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/htmlsingle/#boot-features-external-config">参考官方文档</a></p>
<p><img src="/post/99fd0336/1573735371567.png" alt="1573735371567"></p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Initializer快建项目</title>
    <url>/post/8340e3af/</url>
    <content><![CDATA[<h1 id="使用Spring-Initializer快速创建Spring-Boot项目"><a href="#使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="[使用Spring Initializer快速创建Spring Boot项目]"></a>[使用Spring Initializer快速创建Spring Boot项目]</h1><p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；</p>
<p>选择我们需要的模块；向导会联网创建Spring Boot项目；</p>
<p>需要联网</p>
<h2 id="IDEA"><a href="#IDEA" class="headerlink" title="[IDEA]"></a>[IDEA]</h2><ol>
<li><p>创建项目时选择Spring Initializr</p>
<p><img src="/post/8340e3af/1573639771931.png" alt="idea01"></p>
</li>
<li><p>完善项目信息</p>
<p><img src="/post/8340e3af/1573639923504.png" alt="idea02"></p>
<p>出现 <strong>Artifact contains illegal characters</strong> 是因为<code>Artifact</code>中使用了大写，只能是全小写，单词之间用<code>-</code>分隔</p>
</li>
<li><p>选择需要的starter</p>
<p><img src="/post/8340e3af/1573640773365.png" alt="idea03"></p>
</li>
<li><p>创建完成后 不要的文件可以删除</p>
<p><img src="/post/8340e3af/1573641023432.png" alt="idea04"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Stack&amp;Heap</title>
    <url>/post/e5494597/</url>
    <content><![CDATA[<h1 id="栈（Stack）和堆（Heap）"><a href="#栈（Stack）和堆（Heap）" class="headerlink" title="栈（Stack）和堆（Heap）"></a>栈（Stack）和堆（Heap）</h1><p>​        目前来说我们知道怎么去声明一个基础类型的变量，比如int，float，等等。以及复杂数据类型数组和结构，声明它们的时候C会把这些变量放在栈上。<strong>每个线程都有一个栈，而程序通常只有一个堆</strong>。</p>
<h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>  什么是栈？它是内存中一块特殊的区域，<strong>用于保存在函数中声明的零时变量</strong>（其中也包括<code>main()</code>函数）。栈是LIFO(Last in First Out 后进先出)的数据结构，进出操作是由CPU来管理和优化的。<strong>调用函数时就会使用栈。</strong>每当函数声明了一个变量，该变量就会被<strong>推入(Pushed)</strong>栈中。每当函数退出时，所有的变量都会被函数推出栈，并被<strong>释放掉(Free)</strong>。一旦变量被释放，该内存区域就可以被其他栈变量使用。<br>  使用栈的优势是它会为你管理内存，而不需要你手动去分配或者释放内存。更进一步说，由于CPU可以有效地管理栈内存，所以从栈中读写变量是很快的。<br>  理解栈的关键是需要知道函数什么时候退出，此时栈中所有的变量被推出，因此<strong>栈变量是局部的</strong>（也就是局部变量）。C中经常出现的一个错误就是，在函数返回以后去访问函数内部中栈变量。<br>  如果使用太多的栈空间会导致溢出，比如在使用递归的时候，该函数使用了太多的局部变量在递归过程中就有可能造成<strong>栈溢出</strong>。</p>
<blockquote>
<p>总结</p>
<ul>
<li>栈是LIFO数据结构；</li>
<li>CPU管理内存，而不需要手动去管理。正是因为这个原因从栈中读写变量<strong>很快</strong>的；</li>
<li>栈变量是局部的（也就是局部变量）；</li>
<li>栈的容量会随着函数的Push和Pop变化；</li>
</ul>
</blockquote>
<h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><p>  堆也是内存中一块特定区域，但是CPU并不会自动管理相关的操作，而且它的空间大小会有一定的浮动。在堆上分配内存的时候，在C中使用<code>malloc()</code>和<code>calloc()</code>函数。在不需要堆上这块内存之后，需要使用<code>free()</code>函数释放掉它。<strong>如果不释放的话就会造成内存泄漏</strong>，这块内存就会被闲置。<br>  和栈不同之处在于，<strong>堆内存数据的读写速度会比栈慢</strong>。</p>
<h3 id="栈（Stack）和堆（Heap）的差异"><a href="#栈（Stack）和堆（Heap）的差异" class="headerlink" title="栈（Stack）和堆（Heap）的差异"></a>栈（Stack）和堆（Heap）的差异</h3><h4 id="配置堆栈大小"><a href="#配置堆栈大小" class="headerlink" title="配置堆栈大小"></a>配置堆栈大小</h4><p>  堆的大小在程序启动时分配，数值在不同操作系统中可能有所不同。<br>  在Cocoa中想要修改线程的栈大小的话，可以使用<code>NSThread</code>的实例方法<code>setStackSize:</code>，如果使用POSIX线程技术创建的线程的话，想要设置栈大小的话使用<code>pthread_attr_setstacksize</code>函数。</p>
<blockquote>
<p>⚠️如果要设置栈大小就必须要在创建线程之前完成。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(backgroudMethod:) object:nil];</span><br><span class="line">[thread setStackSize:<span class="number">1024</span>];</span><br><span class="line">[thread start];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 第二种</span></span><br><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"><span class="keyword">pthread_t</span> posix_tread_id;</span><br><span class="line"><span class="keyword">int</span> returnVal;</span><br><span class="line">returnVal = pthread_attr_init(&amp;attr);</span><br><span class="line">returnVal = pthread_attr_setstacksize(&amp;attr, <span class="number">1024</span>);  <span class="comment">// 在创建线程前设置堆栈大小</span></span><br><span class="line"><span class="keyword">char</span> *data;</span><br><span class="line">data = <span class="string">&quot;To ensure that a thread knows what work to do&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> thread_error = pthread_create(&amp;posix_tread_id, &amp;attr, posix_thread_mainroutine, data);</span><br></pre></td></tr></table></figure>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>  栈是和线程相关联的，意思就是说当线程退出时，栈被回收。而堆通常是在启动程序时分配，当程序退出之后被回收。</p>
<h3 id="什么时候使用栈什么时候使用堆"><a href="#什么时候使用栈什么时候使用堆" class="headerlink" title="什么时候使用栈什么时候使用堆"></a>什么时候使用栈什么时候使用堆</h3><ul>
<li>需要申请较大内存空间（比如struct，array之类的），而且需要该变量存在较长时间，就是将该变量放在<strong>堆</strong>中；</li>
<li>如果需要动态修改struct或者array的大小，将该变量放在<strong>堆</strong>上。使用<code>malloc()</code>，<code>calloc()</code>，<code>realloc()</code>和<code>free()</code>等函数来管理内存；</li>
<li>如果使用相对较小的变量，并且只在函数中使用它们，此时该变量就存在于栈上。这样做会更快而且更简单。</li>
</ul>
]]></content>
      <categories>
        <category>内存布局</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetris C1-布尔逻辑</title>
    <url>/post/a2d606e7/</url>
    <content><![CDATA[<h1 id="布尔逻辑-Boolean-Logic"><a href="#布尔逻辑-Boolean-Logic" class="headerlink" title="[布尔逻辑 Boolean Logic]"></a>[布尔逻辑 Boolean Logic]</h1><p><strong>And/Or/Not</strong>算子都可以只用<strong>Nand</strong>或<strong>Nor</strong>函数来构建（可以单纯用Nand也可以单纯用Nor）</p>
<p><code>Nand</code>: 只有1-1为0，其他情况(0-0, 0-1, 1-0)均为1（Not And）</p>
<p><code>Nor</code>:   只有0-0为1，其他情况(0-1, 1-0, 1-1)均为0（Not Or）</p>
<a id="more"></a>
<p>eg: <code>x Or y</code> = <code>(x Nand x) Nand (y Nand y)</code></p>
<p>Or 和 And:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>x</th>
<th>0           0           1           1</th>
</tr>
</thead>
<tbody>
<tr>
<td>—————</td>
<td><strong>y</strong></td>
<td><strong>0           1           0           1</strong></td>
</tr>
<tr>
<td><code>(x Nand x) Nand (y Nand y)</code></td>
<td>Or</td>
<td>1           1           1           0</td>
</tr>
<tr>
<td><code>(x Nand y) Nand (x Nand y)</code></td>
<td>And</td>
<td>0           0           0           1</td>
</tr>
</tbody>
</table>
</div>
<p> Not:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>x</th>
<th>0           1</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(x Nand x)</code></td>
<td>Not</td>
<td>1           0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>既然每个布尔函数(P10)都能通过规范表示法由And、Or和Not构成，那么每个布尔函数也能仅使用Nand函数来构成</strong></p>
<p>Nand -&gt; (And、Or和Not) -&gt; (任意的布尔函数)：一生三，三生万物。</p>
<p>实际意义：一旦在物理上实现了Nand、功能，就可以使用很多这样的物理设备，通过 特定的连接方式（Function）来构建任何布尔函数的硬件实现。</p>
<p><strong>求解formula的方法：</strong></p>
<ol>
<li><p>Boolean Expression.布尔表达式</p>
</li>
<li><p>Truth Table.真值表</p>
<p>构造出满足取值为<code>1</code>的布尔表达式，通过<code>OR</code>连接所有的表达式</p>
</li>
</ol>
<h3 id="HDL实现基本门"><a href="#HDL实现基本门" class="headerlink" title="[HDL实现基本门]"></a>[HDL实现基本门]</h3><p>HDL: Hardware Description Language.</p>
<script type="math/tex; mode=display">\overline{x·x}=(x \ Nand \ x)</script><p><strong>Not:</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>in</th>
<th>0           1</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(in Nand true)</code></td>
<td>Not</td>
<td>1           0</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
out~=~\overline{in·true}</script><p><strong>Or / And / Xor:</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>x</th>
<th>0           0           1           1</th>
</tr>
</thead>
<tbody>
<tr>
<td>—————</td>
<td><strong>y</strong></td>
<td><strong>0           1           0           1</strong></td>
</tr>
<tr>
<td><code>(x Nand true) Nand (y Nand true)</code></td>
<td>Or</td>
<td>0           1           1           1</td>
</tr>
<tr>
<td><code>(x Nand y) Nand true</code></td>
<td>And</td>
<td>0           0           0           1</td>
</tr>
<tr>
<td><strong>—————————————————————</strong></td>
<td><strong>—</strong></td>
<td><strong>———————————</strong></td>
</tr>
<tr>
<td><code>Or( And(Not(x), y), And(x, Not(y)) )</code></td>
<td>Xor</td>
<td>0           1           1           0</td>
</tr>
</tbody>
</table>
</div>
<p><strong> Or:</strong>  </p>
<script type="math/tex; mode=display">
out~=~\overline{\overline{x}·\overline{y}}</script><p><strong> And:</strong> </p>
<script type="math/tex; mode=display">
out~=~\overline{\overline{x·y}·true}</script><p><strong> Xor:</strong> </p>
<script type="math/tex; mode=display">
out~=~\overline{x}·y~+~x·\overline{y}</script><h3 id="逻辑门"><a href="#逻辑门" class="headerlink" title="[逻辑门]"></a>[逻辑门]</h3><p><strong>Multiplexor:</strong> （多路复用，<strong>多路输入</strong>根据<strong>选择位</strong>进行选择性<strong>单路输出</strong>）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>x</th>
<th>0           0           1           1</th>
</tr>
</thead>
<tbody>
<tr>
<td>—————</td>
<td><strong>y</strong></td>
<td><strong>0           1           0           1</strong></td>
</tr>
<tr>
<td>—————</td>
<td><strong>sel</strong></td>
<td><strong>0           1</strong></td>
</tr>
<tr>
<td><code>Or(And(x, Not(sel)), And(b, sel) )</code></td>
<td>Multiplexor</td>
<td>8种可能[ 4 * (2-sel) ]</td>
</tr>
<tr>
<td><code>Not(sel)</code></td>
<td>—————</td>
<td>控制x, y运算结果不相同</td>
</tr>
<tr>
<td><code>And(x, Not(sel))</code></td>
<td>—————</td>
<td>控制sel = 0时输出x, 且只有1-1时out = 1</td>
</tr>
<tr>
<td><code>And(y, sel)</code></td>
<td>—————</td>
<td>控制sel = 1时输出y, 且只有1-1时out = 1</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
out~=~x·\overline{sel} + y·sel</script><p><strong>Demultiplexor:</strong> （解复用，将<strong>单路输入</strong>根据<strong>选择位</strong>划分为<strong>多路输出</strong>）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>in</th>
<th>0           0           1           1</th>
</tr>
</thead>
<tbody>
<tr>
<td>—————</td>
<td><strong>sel</strong></td>
<td><strong>0           1</strong></td>
</tr>
<tr>
<td><code>And(in, Not(sel)), And(in, sel)</code></td>
<td>Demultiplexor</td>
<td>4种可能</td>
</tr>
</tbody>
</table>
</div>
<p>4种可能: </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>in</th>
<th>sel</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
a~=~in·\overline{sel},~b~=~in·sel</script><h3 id="多位逻辑门"><a href="#多位逻辑门" class="headerlink" title="[多位逻辑门]"></a>[多位逻辑门]</h3><p><strong>Mux16:</strong> </p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Mux(a=a[<span class="number">1</span>], b=b[<span class="number">1</span>], sel=sel, out=out[<span class="number">1</span>]); </span><br><span class="line">…… </span><br><span class="line">Mux(a=a[<span class="number">15</span>], b=b[<span class="number">15</span>], sel=sel, out=out[<span class="number">15</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="多位多通道逻辑门"><a href="#多位多通道逻辑门" class="headerlink" title="[多位多通道逻辑门]"></a>[多位多通道逻辑门]</h3><p><code>m</code>个<code>n</code>位输入变量中选择一个并从其中单一的<code>n</code>位输出到 总线输出 上。</p>
<p>k个控制位指定选择，<code>k = log₂m</code></p>
<p><strong>Mux4way16:</strong> （选择输入以输出）</p>
<p><code>m = 4, n = 16, k = 2</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">IN a[<span class="number">16</span>], b[<span class="number">16</span>], c[<span class="number">16</span>], d[<span class="number">16</span>], sel[<span class="number">2</span>];</span><br><span class="line">OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">PARTS:<span class="type"></span></span><br><span class="line"><span class="type">Mux16</span>(a=a, b=b, sel=sel[<span class="number">0</span>], out=e);</span><br><span class="line">Mux16(a=c, b=d, sel=sel[<span class="number">0</span>], out=f);</span><br><span class="line">Mux16(a=e, b=f, sel=sel[<span class="number">1</span>], out=out);</span><br></pre></td></tr></table></figure>
<p><strong>Mux8way16:</strong> </p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">IN a[<span class="number">16</span>], b[<span class="number">16</span>], c[<span class="number">16</span>], d[<span class="number">16</span>],</span><br><span class="line">   e[<span class="number">16</span>], f[<span class="number">16</span>], g[<span class="number">16</span>], h[<span class="number">16</span>],</span><br><span class="line">   sel[<span class="number">3</span>];</span><br><span class="line">OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">PARTS:<span class="type"></span></span><br><span class="line"><span class="type"></span>// array cells [<span class="number">0.</span>.n]</span><br><span class="line">Mux4Way16(a=a, b=b, c=c, d=d, sel=sel[<span class="number">0.</span><span class="number">.1</span>], out=x1);</span><br><span class="line">Mux4Way16(a=e, b=f, c=g, d=h, sel=sel[<span class="number">0.</span><span class="number">.1</span>], out=x2);</span><br><span class="line">Mux16(a=x1, b=x2, sel=sel[<span class="number">2</span>], out=out);</span><br></pre></td></tr></table></figure>
<p><strong>DMux4Way</strong>：（选择通道以输出）</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">IN <span class="keyword">in</span>, sel[<span class="number">2</span>];</span><br><span class="line">OUT a, b, c, d;</span><br><span class="line"></span><br><span class="line">PART:<span class="type"></span></span><br><span class="line"><span class="type">Not</span>(<span class="keyword">in</span>=sel[<span class="number">0</span>], out=sel00);</span><br><span class="line">Not(<span class="keyword">in</span>=sel[<span class="number">1</span>], out=sel10);</span><br><span class="line"></span><br><span class="line">And(a=<span class="keyword">in</span>, b=sel10, out=a1);</span><br><span class="line">And(a=a1, b=sel00, out=a);</span><br><span class="line"></span><br><span class="line">And(a=<span class="keyword">in</span>, b=sel10, out=b1);</span><br><span class="line">And(a=b1, b=sel[<span class="number">0</span>], out=b);</span><br><span class="line"></span><br><span class="line">And(a=<span class="keyword">in</span>, b=sel[<span class="number">1</span>], out=c1);</span><br><span class="line">And(a=c1, b=sel00, out=c);</span><br><span class="line"></span><br><span class="line">And(a=<span class="keyword">in</span>, b=sel[<span class="number">0</span>], out=d1);</span><br><span class="line">And(a=d1, b=sel[<span class="number">1</span>], out=d);</span><br></pre></td></tr></table></figure>
<p><strong>DMux8Way:</strong> </p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">IN <span class="keyword">in</span>, sel[<span class="number">3</span>];</span><br><span class="line">OUT a, b, c, d, e, f, g, h;</span><br><span class="line"></span><br><span class="line">PARTS:<span class="type"></span></span><br><span class="line"><span class="type">DMux4Way</span>(<span class="keyword">in</span> = <span class="keyword">in</span>, sel = sel[<span class="number">1.</span><span class="number">.2</span>], a = o1, b = o2, c = o3, d = o4);</span><br><span class="line">DMux(<span class="keyword">in</span> = o1, sel = sel[<span class="number">0</span>], a = a, b = b);</span><br><span class="line">DMux(<span class="keyword">in</span> = o2, sel = sel[<span class="number">0</span>], a = c, b = d);</span><br><span class="line">DMux(<span class="keyword">in</span> = o3, sel = sel[<span class="number">0</span>], a = e, b = f);</span><br><span class="line">DMux(<span class="keyword">in</span> = o4, sel = sel[<span class="number">0</span>], a = g, b = h);</span><br></pre></td></tr></table></figure>
<p>DMux和Mux的区别与关联：</p>
<p><img src="/post/a2d606e7/v2-bb3f9b6f59a92fd0ede6b40bfb72332b_720w.jpg" alt="DMux &amp; Mux"></p>
<p>Picture source: 知乎@MixMay</p>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
        <tag>HDL</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetris C3-时序逻辑</title>
    <url>/post/5b81f62b/</url>
    <content><![CDATA[<h1 id="时序逻辑-Sequential-Logic"><a href="#时序逻辑-Sequential-Logic" class="headerlink" title="[时序逻辑 Sequential Logic]"></a>[时序逻辑 Sequential Logic]</h1><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><p><strong>时钟(Clock)</strong>: 计算机里时间的流逝是用主时针(master clock)来表示的，它提供连续的<strong>交变信号序列</strong>。硬件实现通常基于<strong>振荡器(oscillator)</strong>，其在两个信号值<strong>0-1</strong>，或称<strong>“低电平-高电平(low-high, tick-tock)”</strong>之间交替变化。两个相邻的上升沿之间的时间间隙称为时钟的<strong>周期(cycle)</strong>，每个时钟周期模塑一个<strong>离散的时间单元</strong>。通过硬件电路，这个信号同时被传送到计算机平台的每个时序芯片中。</p>
<p><strong>触发器(Flip-Flops)</strong>: 本书使用<strong>数据触发器(Data Flip-Flop, DFF或称D触发器)</strong>。实现基于时间的行为：</p>
<script type="math/tex; mode=display">
out(t) = in(t - 1)</script><p>t是当前时钟周期。换而言之，DFF能够简单的实现将前一个时间周期的输入值作为当前周期的输出值。</p>
<p><code>out(t) = in(t - 1)</code>是所有计算机硬件维持自身状态的基础，二进制单元 -&gt; 寄存器 -&gt; 任意大的随机存取记忆单元(RAM) 都是如此.</p>
<p><strong>寄存器(Registers)</strong>: 能够“储存”某一时刻的值，实现经典的存储行为：</p>
<script type="math/tex; mode=display">
out(t) = out(t - 1)</script><p>从另一个方面来说，DFF仅能够输出它前一时钟周期的输出，也就是<code>out(t) = in(t - 1)</code>。这提示了我们，可以通过DFF来实现寄存器，只需将后面的输出反馈到它的输入就可以了。</p>
<p><img src="/post/5b81f62b/image-20200818162126362.png" alt="image-20200818162126362" style="zoom: 50%;"></p>
<p>如此一来，在任何时刻<code>t</code>，这个设备的输出都会重现它在时刻<code>t-1</code>的值。</p>
<p>如图3.1右，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">load = 1, out(t) = in(t-1),  相当于wirte操作, 希望开始存储新值, 把值置于in输入口;</span><br><span class="line">load = 0, out(t) = out(t-1), 相当于read操作, 希望一直存储它的内部值直到新的指令到来</span><br></pre></td></tr></table></figure>
<p><img src="/post/5b81f62b/image-20200818163142204.png" alt="image-20200818163142204" style="zoom: 50%;"></p>
<p><strong>内存(Memories)</strong>: …… 随机存取内存(RAM, Random Acess Memory): 在RAM上能够随机访问被选择的字而不会受限于访问顺序。</p>
<p><img src="/post/5b81f62b/image-20200818163246416.png" alt="image-20200818163246416" style="zoom: 50%;"></p>
<p><strong>计数器(Counter)</strong>: 每经过一个时间周期计数器就增加1个单位，执行函数<code>out(t) = out(t-1) + c</code>，这里<code>c</code>就是1.</p>
<h3 id="时间问题"><a href="#时间问题" class="headerlink" title="[时间问题]"></a>[时间问题]</h3><p>至此本章介绍的芯片都是时序芯片(sequential chip)。简单来说，时序芯片就是直接或间接地嵌入一个或多个DFF门的芯片。</p>
<p>反馈回路：输出依赖于输入，而输入本身有依赖于输出，因此输出只依赖自身。</p>
<p><img src="/post/5b81f62b/image-20200818171444271.png" alt="image-20200818171444271" style="zoom: 50%;"></p>
<p>省略……</p>
<h3 id="规范详述"><a href="#规范详述" class="headerlink" title="[规范详述]"></a>[规范详述]</h3><ul>
<li><p>D触发器(DFFs)</p>
</li>
<li><p>寄存器 (基于DFFs)</p>
</li>
<li><p>存储块 (基于寄存器)</p>
</li>
<li><p>计数器芯片 (基于寄存器)</p>
<p>太多细节，几乎都是必看的，建议看书；避免抄书，在此省略……</p>
</li>
</ul>
<h3 id="实现硬件"><a href="#实现硬件" class="headerlink" title="[实现硬件]"></a>[实现硬件]</h3><p><strong>1Bit寄存器</strong>：</p>
<ul>
<li>If load[t] == 1 then out[t+1] = in[t]<ul>
<li>else out does not change (out[t+1] = out[t])</li>
</ul>
</li>
</ul>
<p><img src="/post/5b81f62b/image-20200822231745454.png" alt="image-20200822231745454" style="zoom: 50%;"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">CHIP Bit &#123;</span><br><span class="line">    IN <span class="keyword">in</span>, load;</span><br><span class="line">    OUT out;</span><br><span class="line"></span><br><span class="line">    PARTS:<span class="type"></span></span><br><span class="line"><span class="type">    </span>// lastOut is equal to the last time out, Assigned by DFF<span class="string">&#x27;s lastOut</span></span><br><span class="line"><span class="string">    Mux(a=lastOut, b=in, sel=load, out=muxOut);</span></span><br><span class="line"><span class="string">    // cause the out is distinct(Only use once), so we can add out to copy the out</span></span><br><span class="line"><span class="string">    DFF(in=muxOut, out=lastOut, out=out);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>n-Bits寄存器</strong>：</p>
<p>n个<strong>1Bit寄存器</strong>串联 和 <code>log(2)n</code>的address选择寄存器进行读写（取址执行的基础 ）。</p>
<p><strong>n-Bits RAM(Random Access Memory)</strong>：</p>
<p><img src="/post/5b81f62b/image-20200822234706201.png" alt="image-20200822234706201" style="zoom: 50%;"></p>
<p>address用于寻址：根据<code>address = i</code>找出需要载入的<strong>1Bit寄存器</strong>，此时该寄存器设置<code>load = 1，in = M</code>，并在下一个时间周期<code>out = M</code>，实现<code>out(t) = in(t-1)</code></p>
<p><img src="/post/5b81f62b/image-20200822235721818.png" alt="image-20200822235721818" style="zoom:50%;"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 16-bit register:</span></span><br><span class="line">CHIP Register &#123;</span><br><span class="line">    IN <span class="keyword">in</span>[<span class="number">16</span>], load;</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:<span class="type"></span></span><br><span class="line"><span class="type">    </span>// No Mux16, because DFF only accept <span class="number">1</span> bit input &amp; output.</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">0</span>], load=load, out=out[<span class="number">0</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">1</span>], load=load, out=out[<span class="number">1</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">2</span>], load=load, out=out[<span class="number">2</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">3</span>], load=load, out=out[<span class="number">3</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">4</span>], load=load, out=out[<span class="number">4</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">5</span>], load=load, out=out[<span class="number">5</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">6</span>], load=load, out=out[<span class="number">6</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">7</span>], load=load, out=out[<span class="number">7</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">8</span>], load=load, out=out[<span class="number">8</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">9</span>], load=load, out=out[<span class="number">9</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">10</span>], load=load, out=out[<span class="number">10</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">11</span>], load=load, out=out[<span class="number">11</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">12</span>], load=load, out=out[<span class="number">12</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">13</span>], load=load, out=out[<span class="number">13</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">14</span>], load=load, out=out[<span class="number">14</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">15</span>], load=load, out=out[<span class="number">15</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Memory of 8 registers, each 16 bit-wide.</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">CHIP RAM8 &#123;</span><br><span class="line">    IN <span class="keyword">in</span>[<span class="number">16</span>], load, address[<span class="number">3</span>];</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:<span class="type"></span></span><br><span class="line"><span class="type">    </span>// <span class="keyword">in</span> accordance with address, locate which register to load</span><br><span class="line">    DMux8Way(<span class="keyword">in</span>=<span class="keyword">in</span>, sel=address, a=in0, b=in1, c=in2, d=in3, e=in4, f=in5, g=in6, h=in7);</span><br><span class="line"></span><br><span class="line">    Register(<span class="keyword">in</span>=in0, load=load, out=out0);</span><br><span class="line">    Register(<span class="keyword">in</span>=in1, load=load, out=out1);</span><br><span class="line">    Register(<span class="keyword">in</span>=in2, load=load, out=out2);</span><br><span class="line">    Register(<span class="keyword">in</span>=in3, load=load, out=out3);</span><br><span class="line">    Register(<span class="keyword">in</span>=in4, load=load, out=out4);</span><br><span class="line">    Register(<span class="keyword">in</span>=in5, load=load, out=out5);</span><br><span class="line">    Register(<span class="keyword">in</span>=in6, load=load, out=out6);</span><br><span class="line">    Register(<span class="keyword">in</span>=in7, load=load, out=out7);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// in accordance with address, decide which register should output</span></span><br><span class="line">    Mux8Way16(a=out0, b=out1, c=out2, d=out3, e=out4, f=out5, g=out6, h=out7, sel=address, out=out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Couters</strong></p>
<p>三个基本功能：</p>
<ul>
<li>重置计数器</li>
<li>计数器自增</li>
<li>为计数器赋值</li>
</ul>
<p><img src="/post/5b81f62b/image-20200823000717282.png" alt="image-20200823000717282" style="zoom:50%;"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">CHIP PC &#123;</span><br><span class="line">    IN <span class="keyword">in</span>[<span class="number">16</span>],load,inc,reset;</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:<span class="type"></span></span><br><span class="line"><span class="type">    </span>// Order cant change</span><br><span class="line">    <span class="comment">// inc</span></span><br><span class="line">    Mux16(a=lastOut, b=incOut, sel=inc, out=out1);</span><br><span class="line">    <span class="comment">// laod</span></span><br><span class="line">    Mux16(a=out1, b=<span class="keyword">in</span>, sel=load, out=out2);</span><br><span class="line">    <span class="comment">// reset</span></span><br><span class="line">    Mux16(a=out2, b=<span class="literal">false</span>, sel=reset, out=out3);</span><br><span class="line"></span><br><span class="line">    Register(<span class="keyword">in</span>=out3, load=<span class="literal">true</span>, out=lastOut, out=out);</span><br><span class="line">    Inc16(<span class="keyword">in</span>=lastOut, out=incOut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>RAM</tag>
        <tag>nand2tetris</tag>
        <tag>HDL</tag>
        <tag>Register</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetris C2-布尔算法</title>
    <url>/post/c8f554f1/</url>
    <content><![CDATA[<h1 id="布尔算法运算-Boolean-Arithmetic"><a href="#布尔算法运算-Boolean-Arithmetic" class="headerlink" title="[布尔算法运算 Boolean Arithmetic]"></a>[布尔算法运算 Boolean Arithmetic]</h1><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><p>两个<code>n-</code>位数字二进制加法的计算机硬件可以由三位加法的逻辑门构建而成。（两个计算位加上一个进位）</p>
<p><strong>在4-位二进制系统中的有符号数的2-补码表示</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>正数</th>
<th>负数</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 – 0000</td>
<td></td>
</tr>
<tr>
<td>1 – 0001</td>
<td>1111 – (-1)</td>
</tr>
<tr>
<td>2 – 0010</td>
<td>1110 – (-2)</td>
</tr>
<tr>
<td>3 – 0011</td>
<td>1101 – (-3)</td>
</tr>
<tr>
<td>4 – 0100</td>
<td>1100 – (-4)</td>
</tr>
<tr>
<td>5 – 0101</td>
<td>1011 – (-5)</td>
</tr>
<tr>
<td>6 – 0110</td>
<td>1010 – (-6)</td>
</tr>
<tr>
<td>7 – 0111</td>
<td>1001 – (-7)</td>
</tr>
<tr>
<td></td>
<td>1000 – (-8)</td>
</tr>
</tbody>
</table>
</div>
<p>计算<code>-x</code>原理：</p>
<script type="math/tex; mode=display">
2^n-x = 1 + (2^n-1)-x</script><p>由此可知，用补码表示<code>n-</code>位二进制系统有如下属性：</p>
<ul>
<li>系统能对所有<strong>2^n^</strong>个有符号数进行编码，最大的数(0111)和最小的数(1000)分别为<strong>(2^n-1^-1)</strong>和<strong>(-2^n-1^)</strong>.</li>
<li>所有正整数的编码的首位是0.</li>
<li>所有负整数的编码的首位是1.</li>
<li><em>为了通过<code>x</code>的编码获得<code>-x</code>的编码，所有最右边的0和从左边起的第一个1保持不变，然后将剩余的位取反。</em>等价的捷径就是，<strong>对<code>x</code>的所有的位取反，然后加上1，这个方案更容易在硬件中实现.</strong></li>
</ul>
<p>这种表示法有个特别吸引人的特征：<strong>任何两个用补码表示的有符号数的加法和与正数的加法完全相同</strong>。</p>
<p>eg: </p>
<p>1.加法(-2) + (-3)</p>
<p>使用补码(<code>4-</code>位)表示：(1110)₂ + (1101)₂  = (1011)₂  ，(丢掉溢出位)</p>
<p>正好是-5的补码.</p>
<p><strong>我们不用去关心这些代码表示的数字（正数还是负数）</strong></p>
<p>2.减法可以看成<code>x - y = x + (-y)</code>，补码表示中，计算<code>-y</code>：所有位取反再加1</p>
<p><strong>以上意味着能用单一芯片（成为算术逻辑单元ALU，ALU即<code>Arithmetic Logical Unit</code>）将硬件执行的所有基本算术操作和逻辑操作封装起来</strong>.</p>
<h3 id="规范详述"><a href="#规范详述" class="headerlink" title="[规范详述]"></a>[规范详述]</h3><ol>
<li>加法器(Adders)<ul>
<li><strong>半加器</strong>(Half-Adders)</li>
<li><strong>全加器</strong>(Full-Adders)</li>
<li><strong>加法器</strong>(Adders)</li>
</ul>
</li>
</ol>
<ul>
<li><strong>半加器</strong>(Half-Adders)：用来进行<code>2-</code>位二进制数的加法.</li>
</ul>
<p><img src="/post/c8f554f1/image-20200816222258242.png" alt="image-20200816222258242" style="zoom:80%;"></p>
<ul>
<li><strong>全加器</strong>(Full-Adders)：用来进行<code>3-</code>位二进制数加法.  </li>
</ul>
<p><img src="/post/c8f554f1/image-20200816223202065.png" alt="image-20200816223202065" style="zoom:80%;"></p>
<ul>
<li><strong>加法器</strong>(Adders)：用来进行两个<code>n-</code>位加法.(图为16位)</li>
</ul>
<p><img src="/post/c8f554f1/image-20200816222654606.png" alt="image-20200816222654606" style="zoom:80%;"></p>
<ul>
<li><strong>增量器</strong>(incrementer)：用来对指定的数字加1.</li>
</ul>
<p><img src="/post/c8f554f1/image-20200816223012624.png" alt="image-20200816223012624" style="zoom:80%;"></p>
<h3 id="算术逻辑单元-ALU"><a href="#算术逻辑单元-ALU" class="headerlink" title="算术逻辑单元(ALU)"></a>算术逻辑单元(ALU)</h3><p><img src="/post/c8f554f1/image-20200817143329826.png" alt="image-20200817143329826" style="zoom:80%;"></p>
<p>Hack的ALU计算一组固定的函数<code>out = f(x, y)</code>，这里<code>x</code>和<code>y</code>是芯片的两个<code>16-</code>位输入，<code>out</code>是芯片的<code>16-</code>位输出，该函数表由18个固定函数组成，通过设置六个称为控制位(control bits)的输入位来告诉ALU用哪一个函数来进行何种函数计算。</p>
<p>ALU可以对2^6^=64个不同的函数进行操作。</p>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
        <tag>HDL</tag>
        <tag>ALU</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetris C8-虚拟机Ⅱ程序控制</title>
    <url>/post/26de550e/</url>
    <content><![CDATA[<h1 id="虚拟机Ⅱ-程序控制-Program-Control"><a href="#虚拟机Ⅱ-程序控制-Program-Control" class="headerlink" title="[虚拟机Ⅱ: 程序控制 Program Control]"></a>[虚拟机Ⅱ: 程序控制 Program Control]</h1><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><p>上一章介绍9个算术指令、逻辑指令以及内存访问指令(push/pop segment<8> index)是如何利用基本<strong>栈式机(stack machine)</strong>操作来进行计算的。本章将在上章基础上描述<strong>程序控制流(program flow)命令</strong>和<strong>子程序调用(subroutine calling)命令</strong>是如何在<strong>栈式机</strong>实现的。</8></p>
<p>对于在运行期的每个<strong>子程序调用</strong>，底层必须处理下面的一些细节。可以利用<strong>栈式机</strong>来方便的完成，事实上<strong>栈式结构</strong>本身的优势就在于处理类似的问题。</p>
<ul>
<li>将参数从调用者(caller)传递给被调用者(called subroutine)。（参数传递）</li>
<li>在跳转并执行被调用者之前，先保存调用者的状态。（现场保护）</li>
<li>为被调用者使用的局部变量分配内存空间。（内存分配）</li>
<li>跳转并执行被调用者。（子程序执行）</li>
<li>将被调用者的运行结果返回给调用者。（参数传递）</li>
<li>在从被调用者返回之前，回收其使用的内存空空间。（回收调用空间）</li>
<li>恢复调用者的状态。（恢复现场）</li>
<li>返回到调用语句之后的下一条语句继续执行。</li>
</ul>
<h3 id="程序控制流"><a href="#程序控制流" class="headerlink" title="[程序控制流]"></a>[程序控制流]</h3><p>​        主要有两种，<strong>无条件跳转</strong>和<strong>有条件跳转</strong>，这部分是很容易实现的。上一章VM的原始操作是如何计算任意给定的布尔表达式，并将其结果置于栈顶的。这种表达式与<code>goto</code>和<code>if-goto</code>命令相结合，就可以表示任何编程语言中的任何控制结构的流程。</p>
<p><img src="/post/26de550e/image-20200926193155407.png" alt="程序控制流的实现"></p>
<h3 id="子程序调用"><a href="#子程序调用" class="headerlink" title="[子程序调用]"></a>[子程序调用]</h3><p>​        子程序调用主要包含两种，调用内置指令和调用用户自己定义的子程序。调用内置指令，比如：<code>add</code>，<code>sub</code>等，在第7章都已经实现。调用用户自己定义的子程序与调用内置指令的区别在于需要使用关键字<code>call</code>。</p>
<p><img src="/post/26de550e/image-20200926200604522.png" alt="子程序调用流程" style="zoom:67%;"></p>
<p><img src="/post/26de550e/image-20200926200701237.png" alt="子程序流程2"></p>
<h4 id="如何实现嵌套调用和递归调用的内存管理机制？"><a href="#如何实现嵌套调用和递归调用的内存管理机制？" class="headerlink" title="如何实现嵌套调用和递归调用的内存管理机制？"></a>如何实现嵌套调用和递归调用的内存管理机制？</h4><p>​        主程序会调用子程序，子程序还会调用子程序，子程序也会调用子程序自身，这就形成了<strong>嵌套调用</strong>和<strong>递归调用</strong>。<br>​        这里要介绍一个概念：<strong>帧</strong>，它表示<strong>子程序的局部变量的集合</strong>。在这一章中，栈是指全局栈结构，它<strong>包括所有子程序的帧组成的栈</strong>，包含了第7章中介绍的栈结构，但又大于之前的栈结构。</p>
<h4 id="函数调用协议-规范"><a href="#函数调用协议-规范" class="headerlink" title="函数调用协议(规范)"></a>函数调用协议(规范)</h4><p><img src="/post/26de550e/image-20200926214313405.png" alt="函数调用协议(规范)"></p>
<ul>
<li>虽然子程序调用链可以具有任意深度，可以有任意的递归，但是<strong>在任何时刻，只有调用链顶部的子程序才能被执行</strong>，而处于调用链中其他子程序将一直等待到该子程序执行完毕才能继续执行。子程序调用的实现过程中，这种<strong>后进先出</strong>的处理方式和<strong>栈区</strong>数据结构的操作方式吻合。</li>
</ul>
<p><img src="/post/26de550e/image-20200924203308549.png" alt="后进先出" style="zoom:67%;"></p>
<h4 id="✨✨✨函数调用协议的实现"><a href="#✨✨✨函数调用协议的实现" class="headerlink" title="✨✨✨函数调用协议的实现"></a>✨✨✨函数调用协议的实现</h4><ul>
<li>函数调用协议及其对应的全局栈区结构能够通过执行下图中给出的(用Hack汇编代码写出的)伪指令在Hack平台上实现。（CodeWriter的实现部分）</li>
</ul>
<p><img src="/post/26de550e/image-20200924204022900.png" alt="函数命令的VM实现"></p>
<ul>
<li>下图显示了三个调用相关的栈区状态：</li>
</ul>
<p><img src="/post/26de550e/image-20200924204140804.png" alt="全局栈区"></p>
<h4 id="Hack平台的RAM标准映射"><a href="#Hack平台的RAM标准映射" class="headerlink" title="Hack平台的RAM标准映射"></a>Hack平台的RAM标准映射</h4><p><img src="/post/26de550e/image-20200926215722605.png" alt="映射"></p>
<p><img src="/post/26de550e/image-20200926215830908.png" alt="汇编语言符号"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="[实现]"></a>[实现]</h2><p><em>Parser.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于Chap7，追加实现解析本章新增的6个VM指令</span></span><br></pre></td></tr></table></figure>
<p><em>VMTranslator</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在遍历Parser的数组链表之前增加指示: .asm是否已写入bootstrap程序代码</span></span><br><span class="line"><span class="comment">// 在遍历过程中，若程序并未写入bootstrap，调用函数并置指示为true</span></span><br></pre></td></tr></table></figure>
<p>将VM程序代码翻译成ASM汇编代码</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标签</span></span><br><span class="line">`label LOOP</span><br><span class="line">(LOOP)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无条件跳转</span></span><br><span class="line">`goto LOOP</span><br><span class="line">@LOOP</span><br><span class="line"><span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件跳转</span></span><br><span class="line">`<span class="keyword">if</span>-goto END</span><br><span class="line">@SP</span><br><span class="line">AM=M<span class="number">-1</span></span><br><span class="line">D=M</span><br><span class="line">@END</span><br><span class="line">D;JNE						<span class="comment">// 不相等则跳转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">call functionName numArgs	<span class="comment">// 根据上图8.5(call f n)的VM实现翻译</span></span><br><span class="line">`call mult <span class="number">2</span></span><br><span class="line">@RETURN_ADD_index</span><br><span class="line">D=A</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>CodeWriter</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeWriter</span></span>&#123;</span><br><span class="line">    <span class="comment">// writeLabel(String): 写入label指令的汇编代码</span></span><br><span class="line">    <span class="comment">// eg:label LOOP -&gt; (LOOP)</span></span><br><span class="line">    <span class="comment">// writeGoto(String): 写入goto指令的汇编代码，eg:goto LOOP -&gt; @LOOP,0;jmp</span></span><br><span class="line">    <span class="comment">// writeIf(String): 写入if-goto指令的汇编代码，eg:if-goto</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reference: <a href="https://github.com/jahnagoldman">jahnagoldman</a></p>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
        <tag>VirtualMachine</tag>
        <tag>vm code</tag>
      </tags>
  </entry>
  <entry>
    <title>thymeleaf模板引擎</title>
    <url>/post/c96c8ccf/</url>
    <content><![CDATA[<h1 id="模板引擎"><a href="#模板引擎" class="headerlink" title="[模板引擎]"></a>[模板引擎]</h1><p>常见的模板引擎有<code>JSP</code>、<code>Velocity</code>、<code>Freemarker</code>、<code>Thymeleaf</code></p>
<p><img src="/post/c96c8ccf/template-engine.png" alt="template-engine"></p>
<p>SpringBoot推荐使用Thymeleaf；语法更简单，功能更强大</p>
<h2 id="引入thymeleaf"><a href="#引入thymeleaf" class="headerlink" title="[引入thymeleaf]"></a>[引入thymeleaf]</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>如需切换thymeleaf版本：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thymeleaf.version</span>&gt;</span>3.X.X.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf.version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- thymeleaf2   layout1--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span>2.X.X<span class="tag">&lt;/<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Thymeleaf使用"><a href="#Thymeleaf使用" class="headerlink" title="[Thymeleaf使用]"></a>[Thymeleaf使用]</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.thymeleaf;</span><br><span class="line">......</span><br><span class="line"><span class="meta">@ConfigurationProperties(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.thymeleaf&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_ENCODING;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">&quot;classpath:/templates/&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">&quot;.html&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> checkTemplate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> checkTemplateLocation = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> String prefix = <span class="string">&quot;classpath:/templates/&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String suffix = <span class="string">&quot;.html&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String mode = <span class="string">&quot;HTML&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>默认只要我们把HTML页面放在<code>classpath:/templates/</code>，thymeleaf就能自动渲染；</p>
<ol>
<li><p>创建模板文件<code>t1.html</code>，并导入thymeleaf的名称空间</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用模板</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>[[$&#123;title&#125;]]<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;title&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;info&#125;&quot;</span>&gt;</span>这里的文本之后将会被覆盖<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在controller中准备数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/ht&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ht</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;hello Thymeleaf&quot;</span>)</span><br><span class="line">             .addAttribute(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;this is first thymeleaf test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;t1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="[语法规则]"></a>[语法规则]</h2><p><code>th:text</code> —&gt; 改变当前元素里面的文本内容；</p>
<p><code>th：任意html属性</code> —&gt; 来替换原生属性的值</p>
<p><img src="/post/c96c8ccf/2018-02-04_123955.png" alt="thymeleaf"></p>
<p>更多配置参考官方文档：<a href="https://www.thymeleaf.org/documentation.html">https://www.thymeleaf.org/documentation.html</a></p>
<p>中文参考书册：<a href="https://www.lanzous.com/i7dzr2j">https://www.lanzous.com/i7dzr2j</a></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">简单表达式的语法：</span></span><br><span class="line">	<span class="attr">变量表达式：$&#123;...&#125;：后去变量值；OGNL</span></span><br><span class="line">		<span class="meta">1.</span> <span class="string">获取对象的属性、调用方法</span></span><br><span class="line">		<span class="meta">2.</span> <span class="string">使用内置的基本对象：</span></span><br><span class="line"><span class="comment">			#ctx：上下⽂对象。 </span></span><br><span class="line"><span class="comment">			#vars：上下⽂变量。 </span></span><br><span class="line"><span class="comment">			#locale：上下⽂区域设置。 </span></span><br><span class="line"><span class="comment">			#request:(仅在Web	Contexts中）HttpServletRequest对象。 </span></span><br><span class="line"><span class="comment">			#response：（仅在Web上下⽂中）HttpServletResponse对象。 </span></span><br><span class="line"><span class="comment">			#session:(仅在Web上下⽂中）HttpSession对象。 </span></span><br><span class="line"><span class="comment">			#servletContext:(仅在Web上下⽂中）ServletContext对象。</span></span><br><span class="line">			</span><br><span class="line">			<span class="attr">eg</span>:<span class="string">$&#123;session.foo&#125;  // 获取session的&#x27;foo&#x27;属性</span></span><br><span class="line">		<span class="meta">3.</span> <span class="string">内置的一些工具对象：</span></span><br><span class="line"><span class="comment">		   #execInfo：有关正在处理的模板的信息。</span></span><br><span class="line"><span class="comment">            #messages：⽤于在变量表达式中获取外部化消息的⽅法，与使⽤＃&#123;...&#125;语法获得的⽅式相同。 </span></span><br><span class="line"><span class="comment">            #uris：转义URL/URI部分的⽅法 </span></span><br><span class="line"><span class="comment">            #conversions：执⾏配置的转换服务（如果有的话）的⽅法。 </span></span><br><span class="line"><span class="comment">            #dates：java.util.Date对象的⽅法：格式化，组件提取等 </span></span><br><span class="line"><span class="comment">            #calendars：类似于#dates，但对于java.util.Calendar对象。 </span></span><br><span class="line"><span class="comment">            #numbers：⽤于格式化数字对象的⽅法。 </span></span><br><span class="line"><span class="comment">            #strings：String对象的⽅法：contains，startsWith，prepending/appending等 </span></span><br><span class="line"><span class="comment">            #objects：⼀般对象的⽅法。 </span></span><br><span class="line"><span class="comment">            #bools：布尔评估的⽅法。 </span></span><br><span class="line"><span class="comment">            #arrays：数组的⽅法。 </span></span><br><span class="line"><span class="comment">            #lists：列表的⽅法。 </span></span><br><span class="line"><span class="comment">            #sets：集合的⽅法。 </span></span><br><span class="line"><span class="comment">            #maps：地图⽅法。</span></span><br><span class="line"><span class="comment">            #aggregates：在数组或集合上创建聚合的⽅法。 </span></span><br><span class="line"><span class="comment">            #ids：处理可能重复的id属性的⽅法（例如，作为迭代的结果</span></span><br><span class="line">            </span><br><span class="line">            <span class="attr">eg</span>:<span class="string">$&#123;#strings.toString(obj)&#125;  // 使用String对象的方法</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">选择变量表达式：*&#123;...&#125;</span>  <span class="string">和$&#123;...&#125;在功能上是一样的；</span></span><br><span class="line">		<span class="meta">补充：配合</span> <span class="string">th:object=&quot;$&#123;session.object&#125;&quot;</span></span><br><span class="line">            <span class="attr">eg</span>:<span class="string"></span></span><br><span class="line">                <span class="meta">&lt;div</span> <span class="string">th:object=&quot;$&#123;session.user&#125;&quot; &gt;</span></span><br><span class="line">                <span class="meta">&lt;p&gt;Name</span>: <span class="string">&lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt; .&lt;/p&gt;		</span></span><br><span class="line">                <span class="meta">&lt;p&gt;Surname</span>:	<span class="string">&lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;. &lt;/p&gt;			</span></span><br><span class="line">                <span class="meta">&lt;p&gt;Nationality</span>:	<span class="string">&lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt; /span&gt;.&lt;/p&gt;</span></span><br><span class="line">                <span class="attr">&lt;/div&gt;</span></span><br><span class="line">                        </span><br><span class="line">	<span class="attr">消息表达式：＃&#123;...&#125;：获取国际化内容</span></span><br><span class="line">	<span class="attr">链接⽹址表达式：@&#123;...&#125;：定义URL链接</span></span><br><span class="line">		   <span class="attr">eg</span>: <span class="string">@&#123;/order/process(execId=$&#123;execId&#125;,execType=&#x27;FAST&#x27;)&#125;</span></span><br><span class="line">	<span class="attr">⽚段表达式：〜&#123;...&#125;：片段引用表达式</span></span><br><span class="line">		   <span class="attr">eg</span>: <span class="string">&lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt;</span></span><br><span class="line">		   </span><br><span class="line"><span class="attr">⽂字：</span></span><br><span class="line">    <span class="meta">⽂字⽂字：&#x27;one</span> <span class="string">text&#x27;, &#x27;Another one!&#x27;	</span></span><br><span class="line">    <span class="attr">数字字⾯值：0,34,3.0,12.3，...</span></span><br><span class="line">    <span class="attr">布尔⽂字：true，false</span></span><br><span class="line">    <span class="attr">空字⾯值：null</span></span><br><span class="line">    <span class="attr">Token：one，sometext，main，...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">⽂本操作：</span></span><br><span class="line">    <span class="attr">字符串连接：+</span></span><br><span class="line">    <span class="meta">⽂本替换：|The</span> <span class="string">name is $&#123;name&#125;|</span></span><br><span class="line"></span><br><span class="line"><span class="attr">算术运算符：</span></span><br><span class="line">    <span class="attr">运算符：+，-，\*，/，%</span></span><br><span class="line"></span><br><span class="line"><span class="attr">负号（⼀元运算符）：-</span></span><br><span class="line"></span><br><span class="line"><span class="attr">布尔运算符：</span></span><br><span class="line">    <span class="attr">运算符：and，or</span></span><br><span class="line">    <span class="attr">布尔否定（⼀元运算符）：！，not</span></span><br><span class="line"></span><br><span class="line"><span class="attr">⽐较和相等运算符：</span></span><br><span class="line">	<span class="meta">⽐较运算符：&gt;;，&lt;;，&gt;</span>=<span class="string">，&lt;=（gt，lt，ge，le）</span></span><br><span class="line">	<span class="meta">相等运算符：</span>=<span class="string">=，！=（eq，ne）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">条件运算符：</span></span><br><span class="line">	<span class="meta">If-then</span>:<span class="string">(if) ? (then)</span></span><br><span class="line">	<span class="meta">If-then-else</span>:<span class="string">(if) ? (then) : (else)</span></span><br><span class="line">	<span class="attr">Default</span>:<span class="string">(value) ?: (defaultvalue)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">特殊符号：</span></span><br><span class="line">	<span class="attr">无操作的符号：_</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly综合研究</title>
    <url>/post/e9163f9a/</url>
    <content><![CDATA[<!-- 
hexo-generator-index從 2.0.0 開始，已經支持文章置頂功能。
你可以直接在文章的front-matter區域裏添加sticky: 1屬性來把這篇文章置頂。
數值越大，置頂的優先級越大。 
-->
<h2 id="部分实验代码"><a href="#部分实验代码" class="headerlink" title="部分实验代码"></a>部分实验代码</h2><ul>
<li>仅供参考: <a href="https://github.com/A1va/x86-Assembly">部分实验代码</a></li>
</ul>
<h2 id="研究试验1-搭建一个精简的C语言开发环境"><a href="#研究试验1-搭建一个精简的C语言开发环境" class="headerlink" title="研究试验1 搭建一个精简的C语言开发环境"></a>研究试验1 搭建一个精简的C语言开发环境</h2><ul>
<li>这里使用TC.EXE以及当前必要的依赖搭建这个精简的环境<ul>
<li>C0S.OBJ</li>
<li>CS.LIB</li>
<li>EMU.LIB</li>
<li>GRAPHICS.LIB</li>
<li>MATHS.LIB</li>
</ul>
</li>
</ul>
<h2 id="研究试验2-使用寄存器"><a href="#研究试验2-使用寄存器" class="headerlink" title="研究试验2 使用寄存器"></a>研究试验2 使用寄存器</h2><ol>
<li><p>用Debug加载ur1.exe，用u命令查看ur1.exe编译后的机器码和汇编代码。<br>思考：<code>main</code>函数的代码在什么段中？用Debug怎样找到ur1.exe中<code>main</code>函数的代码？<br>回答：<code>main</code>函数的代码在CS段中，需要知道<code>main</code>函数的偏移地址才能找到<code>main</code>函数的代码。</p>
</li>
<li><p>用下面的方法打印出ur1.exe被加载运行时，<code>main</code>函数在代码段中的偏移地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main ()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;main:%x\n&quot;</span>, main);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main:1fa</span></span><br></pre></td></tr></table></figure>
<p><img src="/post/e9163f9a/image-20201015170942432.png" alt="image-20201015170942432" style="zoom: 80%;"></p>
<p>思考：为什么这个程序能够打印出<code>main</code>函数在代码段中的偏移地址？</p>
<blockquote>
<p>函数名作为表达式，经历函数到指针隐式转换，变成指向函数的指针值，转换后的指针值即函数的入口地址。</p>
</blockquote>
</li>
<li><p>用Debug加载url.exe，根据上面打印出的<code>main</code>函数的偏移地址，用<code>u</code>命令察看<code>main</code>函数的汇编代码。仔细找到ur1.c中每条C语句对应的汇编代码。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PUSH BP</span></span><br><span class="line"><span class="comment">// MOV BP,SP</span></span><br><span class="line">main()&#123;</span><br><span class="line">    _AX=<span class="number">1</span>;						<span class="comment">// mov ax,0001</span></span><br><span class="line">    _BX=<span class="number">1</span>;						<span class="comment">// mov bx,0001</span></span><br><span class="line">    _CX=<span class="number">2</span>;						<span class="comment">// mov cx,0002</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mov ax,bx</span></span><br><span class="line"><span class="comment">     * add ax,cx</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    _AX=_BX+_CX;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mov ah,bl</span></span><br><span class="line"><span class="comment">     * add ah,cl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    _AH=_BL+_CL;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mov al,bh</span></span><br><span class="line"><span class="comment">     * add al,cx</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    _AL=_BH+_CH;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pop bp</span></span><br><span class="line"><span class="comment">     * ret</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/post/e9163f9a/image-20201015171341778.png" alt="image-20201015171341778" style="zoom:67%;"></p>
<p>注意：在这里，对于<code>main</code>函数汇编代码开始处的<code>push bp mov bp,sp</code>和结尾处的<code>pop bp</code>，这里只了解到：这是C编译器安排的为函数中可能使用到bp寄存器而设置的，就可以了。</p>
<ol>
<li>通过<code>main</code>函数后面有<code>ret</code>指令，我们可以设想：C语言将函数实现为汇编语言中的子程序。研究下面程序的汇编代码，<strong>验证</strong>我们的设想。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">main() &#123;</span><br><span class="line">    _AX=<span class="number">1</span>;</span><br><span class="line">    _BX=<span class="number">1</span>;</span><br><span class="line">    _CX=<span class="number">2</span>;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    _AX=_BX+_CX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/post/e9163f9a/test2验证C语言将函数实现为汇编语言中的子程序.png" alt="test2验证C语言将函数实现为汇编语言中的子程序" style="zoom: 67%;"></p>
<h2 id="研究试验3-使用内存空间"><a href="#研究试验3-使用内存空间" class="headerlink" title="研究试验3 使用内存空间"></a>研究试验3 使用内存空间</h2><ol>
<li>编一个程序um1.c：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">    *(<span class="keyword">char</span> *)<span class="number">0x2000</span>=<span class="string">&#x27;a&#x27;</span>;					<span class="comment">// mov byte ptr [2000],61</span></span><br><span class="line">    *(<span class="keyword">int</span> *)<span class="number">0x2000</span>=<span class="number">0xf</span>;						<span class="comment">// mov word ptr [2000],000F</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mov bx,2000</span></span><br><span class="line"><span class="comment">     * mov es,bx</span></span><br><span class="line"><span class="comment">     * mov bx,1000</span></span><br><span class="line"><span class="comment">     * ES:           	--?(段地址从es获取)</span></span><br><span class="line"><span class="comment">     * mov byte ptr [bx],61</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *(<span class="keyword">char</span> far *)<span class="number">0x20001000</span>=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    _AX=<span class="number">0x2000</span>;								<span class="comment">// mov ax,2000H</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mov bx,ax</span></span><br><span class="line"><span class="comment">     * mov byte ptr [bx],62</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *(<span class="keyword">char</span> *)_AX=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    _BX=<span class="number">0x1000</span>;								<span class="comment">// mov bx,1000H</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add bx,bx</span></span><br><span class="line"><span class="comment">     * mov byte ptr [bx],61</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *(<span class="keyword">char</span> *)(_BX + _BX) = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mov bx,ax</span></span><br><span class="line"><span class="comment">     * mov al,[bx]		取ax地址的值存储在al，char--byte</span></span><br><span class="line"><span class="comment">     * xor cx,cx		将cx和CF置零，以存储高位加法结果(段地址)</span></span><br><span class="line"><span class="comment">     * add bx,1000</span></span><br><span class="line"><span class="comment">     * adc cx,2000		adc = cx + 2000 + CF(可能的进位)</span></span><br><span class="line"><span class="comment">     * mov es,cx</span></span><br><span class="line"><span class="comment">     * ES:           	--?(段地址从es获取)</span></span><br><span class="line"><span class="comment">     * mov [bx],al</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *(<span class="keyword">char</span> far *)(<span class="number">0x20001000</span> + _BX) = *(<span class="keyword">char</span> *)_AX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>编一个程序，用一条C语句实现在屏幕的中间显示一个绿色的字符<code>a</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">    *(<span class="keyword">int</span> far *)<span class="number">0xB80007D0</span> = <span class="number">0x261</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>分析下面程序中所有函数的汇编代码，思考相关问题。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a1,a2,a3;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="keyword">int</span> b1,b2,b3;</span><br><span class="line">    a1 = <span class="number">0xa1</span>;a2 = <span class="number">0xa2</span>;a3 = <span class="number">0xa3</span>;</span><br><span class="line">    b1 = <span class="number">0xb1</span>;b2 = <span class="number">0xb2</span>;b3 = <span class="number">0xb3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c1,c2,c3;</span><br><span class="line">    a1 = <span class="number">0xfa1</span>;a2 = <span class="number">0xfa2</span>;a3 = <span class="number">0xfa3</span>;</span><br><span class="line">    c1 = <span class="number">0xfc1</span>;c2 = <span class="number">0xfc2</span>;c3 = <span class="number">0xfc3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/post/e9163f9a/image-20201015213236182.png" alt="image-20201015213236182" style="zoom: 50%;"></p>
<p>问题：C语言将全局变量存放在哪？将局部变量存放在哪？每个函数开头的<code>push bp</code>和<code>mov bp,sp</code>有何含义？</p>
<p>​    C语言将全局变量存放在内存区DS，将局部变量存放在栈。</p>
<ol>
<li>保护现场，以便还原</li>
<li>BP存储栈底，SP存储栈顶 (基于局部变量的数量改变SP)</li>
</ol>
<ol>
<li>分析下面程序的汇编代码，思考相关的问题。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a,b,ab;</span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c=f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ab = a+b;</span><br><span class="line">    <span class="keyword">return</span> ab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/post/e9163f9a/image-20201015220239951.png" alt="image-20201015220239951" style="zoom: 67%;"></p>
<p>问题：C语言将函数的返回值存放在哪里？</p>
<p>​            <strong>存放在通用寄存器AX。</strong></p>
<ol>
<li>下面的程序向安全的内存空间写入从“a”到“h”8个字符，理解程序的含义，深入理解相关的知识。（注意：请自己学习、研究malloc函数的用法）</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Buffer ((char *) *(int far *)0x200)			<span class="comment">// 0:200H</span></span></span><br><span class="line">main() &#123;</span><br><span class="line">    Buffer = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    Buffer[<span class="number">10</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Buffer[<span class="number">10</span>]!=<span class="number">8</span>) &#123;</span><br><span class="line">        Buffer[Buffer[<span class="number">10</span>]] = <span class="string">&#x27;a&#x27;</span> + Buffer[<span class="number">10</span>];</span><br><span class="line">        Buffer[<span class="number">10</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(Buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>debug以上代码的结果：</p>
<p><img src="/post/e9163f9a/image-20201016171129909.png" alt="汇编代码1" style="zoom: 50%;"></p>
<p><img src="/post/e9163f9a/image-20201016171149851.png" alt="汇编代码2" style="zoom:50%;"></p>
<p><img src="/post/e9163f9a/image-20201016171318388.png" alt="汇编代码3" style="zoom:50%;"></p>
<p><img src="/post/e9163f9a/image-20201016171346033.png" alt="汇编代码4" style="zoom:50%;"></p>
<blockquote>
<ul>
<li>这里malloc返回的值同样是经过AX来传递的</li>
<li>值得注意的是，从代码可以看出，malloc获得的内存在DS段中，所以并不会随着程序返回而释放，所以需要调用free函数手动释放。当然整个程序退出后随着DS段被释放，这片内存就不会泄露了</li>
</ul>
</blockquote>
<ul>
<li>Buffer定义在<code>0:200H</code>，这是执行了<code>Buffer = (char *)malloc(20)</code>后的内存图</li>
</ul>
<p><img src="/post/e9163f9a/image-20201017140736707.png" alt="申请的内存区的偏移地址" style="zoom:67%;"></p>
<p>分析<code>Buffer = ((char *)*(int far *)0x200)</code></p>
<p>从上一题我们得知，C语言将调用函数后的返回值存储在寄存器<code>AX</code>，那么我们就可以利用这个特性，在<code>call Address</code>之后用<code>p</code>调试，观察寄存器<code>AX</code>的值（若是，则会返回<code>malloc</code>申请的内存区的首地址），并用<code>d</code>察看该地址的数据分布（一般会有大于20Byte的全0），那么我们就可以猜测刚刚调用的就是<code>malloc()</code>.</p>
<p>如下图，将14H存储到<code>AX</code>寄存器，说明正在为调用<code>malloc</code>函数传参作准备：</p>
<p><img src="/post/e9163f9a/image-20201017142014562.png" alt="malloc汇编实现" style="zoom: 50%;"></p>
<p><code>malloc</code>实现的汇编语言，如下图：</p>
<p><img src="/post/e9163f9a/image-20201017101603820.png" alt="malloc实现" style="zoom:50%;"></p>
<p>此语句执行，将需要创建的20Byte中的参数:<code>20=14H</code>，经由栈内存传参</p>
<p><img src="/post/e9163f9a/image-20201017101732896.png" alt="image-20201017101732896" style="zoom:67%;"></p>
<p>将参数传给寄存器<code>AX</code></p>
<p><img src="/post/e9163f9a/image-20201017102253876.png" alt="image-20201017102253876" style="zoom:67%;"></p>
<p>执行之后，将申请的内存区<strong>(堆)</strong>的地址存放在<code>AX</code>作为参数<strong>(申请内存区的首地址)</strong>返回：</p>
<p><img src="/post/e9163f9a/image-20201017103350411.png" alt="image-20201017103350411" style="zoom:67%;"></p>
<p>观察刚申请完的内存区的情况：</p>
<p><img src="/post/e9163f9a/image-20201017103619096.png" alt="image-20201017103619096" style="zoom:67%;"></p>
<p>继续执行命令，发现此时将传回的参数<strong>(申请内存区的首地址)</strong><code>AX=04D8</code>存储到<code>Buffer</code>所指向的地址是<code>ES:200</code>: </p>
<p><img src="/post/e9163f9a/image-20201017103933741.png" alt="image-20201017103933741" style="zoom:67%;"></p>
<p>来到这里已经结束语句的分析。</p>
<p>这里则是继续取<code>ES:200H</code>所指向的地址，将<code>ES:[200H + AH]</code>的值置为0，对应于语句<code>Buffer[10]=0;</code></p>
<p><img src="/post/e9163f9a/image-20201017104519819.png" alt="image-20201017104519819" style="zoom:67%;"></p>
<p>最后给申请的内存区赋值完后：（验证内存区）</p>
<p><img src="/post/e9163f9a/image-20201017124628215.png" alt="赋值后" style="zoom:67%;"></p>
<p>我们可以知道，尽管反汇编出来的汇编语句显得不那么“聪明”。如果由我们自己编写，类似上图的，会在把<code>AX</code>传回的首地址赋值到<code>ES:200H</code>之后，重新将寄存器<code>BX</code>置零，再从<code>ES:200H</code>取值(内存区首地址)的操作就能避免。我们会在把<code>AX</code>传回的首地址赋值到<code>ES:200H</code>之后，进而直接给<code>ES:200H+AH</code>赋值<code>0</code>，但是它们确实有效，因为这是翻译器模式化的翻译。</p>
<p>经过学习Nand2Tetris的虚拟机（原理相同，虚拟机将<code>vm</code>语言翻译成<code>Hack ASM</code>，以及C语言的编译器TC2.0将<code>C</code>翻译成<code>x86 ASM</code>），可以知道：我们编写的翻译器都是将被翻译语言的语法完整的解析到对应语言的语法，类似虚拟机中调用函数<code>call f n</code>，那么我们编写的翻译器就必须翻译成：保存现场，将（当前函数的参数，当前函数地址以及当前各内存段的指针，当前函数的局部变量…）压入栈，<code>goto</code> 某个地址，并为返回地址声明一个标签，为还原现场作准备。</p>
<p>调用<code>free</code>，释放内存：</p>
<p><img src="/post/e9163f9a/image-20201017142535999.png" alt="image-20201017142535999" style="zoom:50%;"></p>
<h2 id="研究试验4-不用main函数编程"><a href="#研究试验4-不用main函数编程" class="headerlink" title="研究试验4 不用main函数编程"></a>研究试验4 不用main函数编程</h2><p>编一个程序<code>f.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f() &#123;</span><br><span class="line">    *(<span class="keyword">char</span> far *) (<span class="number">0xb8000000</span> + <span class="number">160</span>*<span class="number">10</span> + <span class="number">80</span>) = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    *(<span class="keyword">char</span> far *) (<span class="number">0xb8000000</span> + <span class="number">160</span>*<span class="number">10</span> + <span class="number">81</span>) = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Question：<br>① 编译和链接哪个环节会出问题？<br>② 显示出的错误信息是什么？<br>③ 这个错误信息可能和哪个文件有关？</p>
<p>Answer：<br>① 链接环节出现了错误<br>② “Linker Error:Undefined Symbol ‘Main’ in Module C0S”——在C0S模块中未定义的标号_main<br>③ 和C0S.OBJ这个文件有关</p>
</li>
<li><p>用学习汇编语言时使用的LINK.EXE对TC.EXE生成的F.OBJ文件进行连接，生成F.EXE。用DEBUG加载F.EXE，察看整个程序的汇编代码。思考相关的问题。<br>Question：<br>① F.EXE的程序代码总共有多少字节？<br>② F.EXE的程序能正确返回吗？<br>③ F函数的偏移地址是多少？<br>Answer：<br>① 总共有1DH个字节（0~1CH）<br>② 可以执行，不能正确的返回<br>③ 0000h</p>
</li>
</ol>
<p>写一个程序m.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">    *(<span class="keyword">char</span> far *) (<span class="number">0xb8000000</span> + <span class="number">160</span>*<span class="number">10</span> + <span class="number">80</span>) = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    *(<span class="keyword">char</span> far *) (<span class="number">0xb8000000</span> + <span class="number">160</span>*<span class="number">10</span> + <span class="number">81</span>) = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>用TC.EXE对M.C进行编译，连接，生成M.EXE，用Debug察看M.EXE整个程序的汇编代码。思考相关的问题。<br>Question：<br>① M.EXE的程序代码总共有多少字节？<br>② M.EXE的程序能正确返回吗？<br>③ M.EXE程序中的main函数和F.EXE中的f函数的汇编代码有何不同？<br>Answer：<br>①<br>② 能正确返回<br>③ 没有不同</p>
</li>
<li><p>用Debug对m.exe进行跟踪：（注意：使用g命令和p命令。）</p>
<p>Question:</p>
<p>① 找到对main函数进行调用的指令的地址<br>② 找到整个程序返回的指令</p>
<p>Answer：</p>
<p>① <img src="/post/e9163f9a/image-20201017200501547.png" alt="image-20201017200501547"></p>
<p><strong>076C:011A</strong></p>
<p>② <img src="/post/e9163f9a/image-20201017200604720.png" alt="image-20201017200604720"></p>
<p><strong>076C:0156</strong></p>
</li>
<li><p>思考如下几个问题：<br>① 对main函数调用的指令和程序返回的指令是哪里来的？<br>② 没有main函数时，出现的错误信息里有和“C0S”相关的信息；而前面在搭建开发环境时，没有C0S.OBJ文件TC.EXE就无法对程序进行连接。是不是TC.EXE把C0S.OBJ和用户程序的.OBJ一起进行连接生成.EXE文件？<br>③ 对用户程序的main函数进行调用的指令和程序返回的指令是否就来自C0S.OBJ文件？<br>④ 我们如何看到C0S.OBJ文件中的程序代码呢？<br>⑤ C0S.OBJ文件里有我们设想的代码吗？</p>
<p>Answer:</p>
<p>① C0S.OBJ<br>② 是的<br>③ 是的<br>④ 用LINK.EXE进行链接<br>⑤ 有</p>
</li>
<li><p>用LINK.EXE对C:\MINIC目录下的C0S.OBJ进行连接，生成C0S.EXE。<br>用Debug分别察看C0S.EXE和M.EXE的汇编代码。注意：从头开始察看，两个文件中的程序代码有和相同之处？</p>
<p>两个程序的代码基本相同，且都是在011A调用了CALL指令，在0156调用了INT 21中断</p>
</li>
<li><p>用Debug找到M.EXE中调用main函数的CALL指令的偏移地址，从这个偏移地址开始向后察看10条指令；然后用Debug加载C0S.EXE，从相同的偏移地址开始向后察看10条指令，对两处的指令进行对比。</p>
</li>
</ol>
<p>M.EXE的汇编代码:</p>
<p><img src="/post/e9163f9a/image-20201017201725414.png" alt="debug m.exe" style="zoom:50%;"></p>
<p>C0S.EXE的汇编代码：</p>
<p><img src="/post/e9163f9a/image-20201017202204374.png" alt="C0S 汇编代码" style="zoom:50%;"></p>
<p>M.EXE和C0S.EXE在偏移地址011A之后的10条指令除了跳转指令的跳转地址有所不同外几乎完全相同。</p>
<ol>
<li>下面，我们用汇编语言编一个程序C0S.ASM，然后把它编译为C0S.OBJ，替代C:\MINIC目录下的C0S.OBJ。</li>
</ol>
<p>程序C0S.ASM：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">    db 128 dup (0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov dx,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,128</span><br><span class="line"></span><br><span class="line">    call s</span><br><span class="line"></span><br><span class="line">    mov ax,4C00H</span><br><span class="line">    int 21H</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<ol>
<li><p>在C:\MINIC目录下，用TC.EXE将F.C重新进行编译，连接，生成F.EXE。这次能通过连接吗？F.EXE可以正确运行吗？用Debug察看F.EXE的汇编代码。<br>① 能通过连接</p>
<p>② 可以正确运行</p>
<p>③ 汇编代码如下：</p>
<p><img src="/post/e9163f9a/image-20201017203833951.png" alt="拼接的汇编代码" style="zoom:50%;"></p>
</li>
<li><p>在新的C0S.OBJ的基础上，写一个新的F.C，向安全的内存空间写入从“a”到“h”的8个字符，分析、理解F.C。<br>程序F.C：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Buffer ((char *)*(int far *)0x200)</span></span><br><span class="line"></span><br><span class="line">f()&#123;</span><br><span class="line">	Buffer = <span class="number">0</span>;</span><br><span class="line">	Buffer[<span class="number">10</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(Buffer[<span class="number">10</span>]!=<span class="number">8</span>)&#123;</span><br><span class="line">		Buffer[Buffer[<span class="number">10</span>]]=<span class="string">&#x27;a&#x27;</span>+Buffer[<span class="number">10</span>];</span><br><span class="line">		Buffer[<span class="number">10</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV AX,076A</span><br><span class="line">MOV DS,AX</span><br><span class="line">MOV SS,AX</span><br><span class="line">MOV SP,0080</span><br><span class="line">CALL 0012 ; 调用程序中的第一个函数</span><br><span class="line">MOV AX,4C00</span><br><span class="line">INT 21</span><br><span class="line"></span><br><span class="line">; 0012: 进入f()函数，保存栈底，更新栈顶，相当于分离原程序环境和被调用程序环境的栈内存</span><br><span class="line">PUSH BP </span><br><span class="line">MOV BP,SP</span><br><span class="line"></span><br><span class="line">; Buffer &#x3D; 0;</span><br><span class="line">XOR BX,BX</span><br><span class="line">MOV ES,BX</span><br><span class="line">MOV BX,0200</span><br><span class="line">ES:</span><br><span class="line">MOV WORD PTR [BX],0000 ; 将0:200H处的内存单元改为0</span><br><span class="line"></span><br><span class="line">; Buffer[10] &#x3D; 0;</span><br><span class="line">XOR BX,BX</span><br><span class="line">MOV ES,BX</span><br><span class="line">MOV BX,0200</span><br><span class="line">ES:</span><br><span class="line">MOV BX,[BX] ; 将0:200H处的内存字单元存入BX中，将该值作为偏移的基址</span><br><span class="line">; 证明在汇编中，访问数组元素 与 访问malloc申请内存单元 的方式类似。</span><br><span class="line">; 访问数组元素和访问malloc申请内存单元，DS:[BX+index]</span><br><span class="line">; 区别:数组的偏移基址为0(直接将Symbol作为偏移基址)，而malloc是获取程序向系统申请的内存因而偏移基址由系统决定(研究试验3.5是4d8)</span><br><span class="line">MOV BYTE PTR [BX+0A],00 ; 将DS:AH处的内存单元改为0</span><br><span class="line">JMP 006D ; 跳转到while的循环条件判断</span><br><span class="line"></span><br><span class="line">; Buffer[Buffer[10]]&#x3D;&#39;a&#39;+Buffer[10];</span><br><span class="line">XOR BX,BX</span><br><span class="line">MOV ES,BX</span><br><span class="line">MOV BX,0200</span><br><span class="line">ES:</span><br><span class="line">MOV BX,[BX] ; BX&#x3D;[0:200H]，将该值作为偏移的基址</span><br><span class="line">MOV AL,[BX+0A] ; AL等于Buffer[10]，即将DS:AH内存字节单元的内容存入AL中</span><br><span class="line">ADD AL,61 ;为AL加上&#39;a&#39;</span><br><span class="line"></span><br><span class="line">XOR BX,BX</span><br><span class="line">MOV ES,BX</span><br><span class="line">MOV BX,0200</span><br><span class="line">ES:</span><br><span class="line">MOV BX,[BX]  ; BX&#x3D;[0:200H]，将该值作为偏移的基址</span><br><span class="line">PUSH AX  ; AX&#x3D;&#39;a&#39;+Buffer[10].在第一次循环中是61H,第二次61H+1...</span><br><span class="line">PUSH BX  ; BX&#x3D;[0:200H]</span><br><span class="line"></span><br><span class="line">XOR BX,BX</span><br><span class="line">MOV ES,BX</span><br><span class="line">MOV BX,0200</span><br><span class="line">ES:</span><br><span class="line">MOV BX,[BX] ; BX&#x3D;[0:200H]，将该值作为偏移的基址</span><br><span class="line">MOV AL,[BX+0A] ; 将Buffer[10]的值传入AL，即将DS:AH处的内存字节单元存入AL中</span><br><span class="line">CBW ; 将AL扩展至16位</span><br><span class="line">POP BX ; 取回BX&#x3D;[0:200H]</span><br><span class="line">ADD BX,AX ; BX: Buffer[Buffer[10]] &#x3D; Buffer[10]+[0:200H]</span><br><span class="line">POP AX ; 取回AX&#x3D;&#39;a&#39;+Buffer[10]</span><br><span class="line">MOV [BX],AL ; 将所要设置的数值&#39;a&#39;+Buffer[10]存入Buffer[Buffer[10]]中</span><br><span class="line"></span><br><span class="line">; Buffer[10]++;</span><br><span class="line">XOR BX,BX</span><br><span class="line">MOV ES,BX</span><br><span class="line">MOV BX,0200</span><br><span class="line">ES:</span><br><span class="line">MOV BX,[BX] ; BX&#x3D;[0:200H]</span><br><span class="line">INC BYTE PTR [BX+0A] ; Buffer[10]++</span><br><span class="line"></span><br><span class="line">; 006D，跳转此处进行while判断</span><br><span class="line">XOR BX,BX</span><br><span class="line">MOV ES,BX</span><br><span class="line">MOV BX,0200</span><br><span class="line">ES:</span><br><span class="line">MOV BX,[BX]</span><br><span class="line">CMP BYTE PTR [BX+0A],08 ; while判断: Buffer[10]是否等于8</span><br><span class="line">JNZ 0031 ; 不等于则继续进入循环体</span><br><span class="line">; 等于则还原环境(恢复栈顶)，并返回调用f()后的下一条语句</span><br><span class="line">POP BP </span><br><span class="line">RET</span><br></pre></td></tr></table></figure>
<h2 id="研究试验5-函数如何接受不定数量的参数"><a href="#研究试验5-函数如何接受不定数量的参数" class="headerlink" title="研究试验5 函数如何接受不定数量的参数"></a>研究试验5 函数如何接受不定数量的参数</h2><ol>
<li>写一个程序<code>a.c</code>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showchar</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">main() &#123;</span><br><span class="line">    showchar(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showchar</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    *(<span class="keyword">char</span> far *)(<span class="number">0xb8000000</span> + <span class="number">160</span>*<span class="number">10</span>+<span class="number">80</span>) = a;</span><br><span class="line">    *(<span class="keyword">char</span> far *)(<span class="number">0xb8000000</span> + <span class="number">160</span>*<span class="number">10</span>+<span class="number">81</span>) = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>main</code>函数通过栈<code>push/pop</code>传递参数给<code>showchar</code>，参数<strong>自右向左</strong>入栈</p>
</li>
<li><p><code>showchar</code>通过栈接收参数，但是不进行弹出，而是直接通过BP读取SS段中的内容，如：<code>mov al,[BP+4]</code></p>
<p>不弹出应该是为了保护还原现场，当传入的是变量而不是值时，需要还原变量的值，此时想起了<code>swap</code>…</p>
</li>
<li><p>因为在参数入栈之后还进行了<code>IP</code>和<code>BP</code>的入栈操作<br>所以取参数<code>char a</code>时，加上<code>idata 4</code>，取参数<code>int b</code>时，加上<code>idata 6</code></p>
</li>
</ul>
<ol>
<li>写一个程序<code>b.c</code>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showchar</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>,...)</span></span>;</span><br><span class="line">main() &#123;</span><br><span class="line">    showchar(<span class="number">8</span>,<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showchar</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> color, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">for</span>(a=<span class="number">0</span>; a!=n; a++) &#123;</span><br><span class="line">        *(<span class="keyword">char</span> far *)(<span class="number">0xb8000000</span> + <span class="number">160</span>*<span class="number">10</span>+<span class="number">80</span>+a+a) = *(<span class="keyword">int</span> *)(_BP+<span class="number">8</span>+a+a);</span><br><span class="line">        *(<span class="keyword">char</span> far *)(<span class="number">0xb8000000</span> + <span class="number">160</span>*<span class="number">10</span>+<span class="number">81</span>+a+a) = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>showchar</code>通过参数<code>int n</code>传递需要显示多少个字符，而参数<code>n</code>在最后入栈，<code>SS:[BP+4]</code>即可获得</p>
<p><code>+4</code>是因为<code>call</code>之后需要<code>push bp</code></p>
</li>
<li><p>参数<strong>自右向左</strong>入栈，最后入栈的参数是指向<code>format</code>首地址(偏移地址)的指针，而<code>printf</code>函数会<code>cmp si,[bp+4]</code>和<code>jnz 235</code>，当<code>cmp</code>和<code>jnz</code>同时运算，效果等同于<code>jne</code>，即进行判断<code>si</code>是否等于<code>[bp+4]</code>的值，<code>si</code>作为counter</p>
</li>
<li><p>所以说<code>printf</code>的变参要和<code>format</code>中的占位符一一对应，否则会出现难以理解的输出。</p>
</li>
</ul>
<ol>
<li><p>实现一个简单的<code>printf</code>函数，只需支持<code>%c %d</code>即可</p>
<p>实现char和int</p>
</li>
</ol>
<p>Reference: <a href="https://www.bilibili.com/video/BV1mt411R7Xv?p=286&amp;t=754">B站教程</a></p>
<p>顺便加了代码处理<code>%%%...</code>的能力</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MyPrintf(<span class="keyword">char</span> * format,...);</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    MyPrintf(<span class="string">&quot;This is MyPrintf %c %d&quot;</span>,<span class="string">&#x27;!&#x27;</span>,<span class="number">233</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPrintf(<span class="keyword">char</span> * format,...)&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> offset=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*format!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span> (*format)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">            format+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(*format==<span class="string">&#x27;c&#x27;</span>)&#123;</span><br><span class="line">                *(<span class="keyword">char</span> far *)(<span class="number">0xb8000000</span>+<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>+<span class="number">2</span>*offset++)=*(<span class="keyword">int</span> *)(_BP+<span class="number">6</span>+<span class="number">2</span>*cnt++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*format==<span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> num=*(<span class="keyword">int</span> *)(_BP+<span class="number">6</span>+<span class="number">2</span>*cnt++);</span><br><span class="line">                <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">char</span> tmp[<span class="number">10</span>];</span><br><span class="line">                <span class="keyword">while</span> (num!=<span class="number">0</span>)&#123;</span><br><span class="line">                    tmp[len++]=(num%<span class="number">10</span>)+<span class="number">0x30</span>;</span><br><span class="line">                    num/=<span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">                <span class="keyword">while</span> (len&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    *(<span class="keyword">char</span> far *)(<span class="number">0xb8000000</span>+<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>+<span class="number">2</span>*offset++)=tmp[len--];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                *(<span class="keyword">char</span> far *)(<span class="number">0xb8000000</span>+<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>+<span class="number">2</span>*offset++)=*format;</span><br><span class="line">            &#125;</span><br><span class="line">            format+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            *(<span class="keyword">char</span> far *)(<span class="number">0xb8000000</span>+<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>+<span class="number">2</span>*offset++)=*format;</span><br><span class="line">            format+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetris C4-机器语言</title>
    <url>/post/f125af90/</url>
    <content><![CDATA[<h1 id="机器语言-Machine-Language"><a href="#机器语言-Machine-Language" class="headerlink" title="[机器语言 Machine Language]"></a>[机器语言 Machine Language]</h1><p>借由机器语言，程序员用符号指令表达的抽象思维被转换成执行在硅片上的物理操作。</p>
<p><strong>This chapter is Complicated.</strong></p>
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><p>​        为了对机器语言作一般性描述，只须要集中讨论三个主要的抽象体上：<strong>处理器(processor)</strong>、<strong>内存(memory)</strong>以及一组<strong>寄存器(registers)</strong>。</p>
<h4 id="1-Machines"><a href="#1-Machines" class="headerlink" title="1.Machines"></a>1.Machines</h4><p>​        <strong>机器语言(machine language)</strong>利用<strong>处理器</strong>和<strong>寄存器操控内存</strong>。</p>
<p>​        <strong>内存(memory)</strong>    用来储存数据和指令的硬件设备。所有内存具有相同的结构：一个连续的固定宽度的单元序列，也称为<strong>字(word)</strong>或<strong>内存单元</strong>，每个内存单元都有一个唯一的<strong>地址(address)</strong>。因此可以通过地址描述任一内存单元。</p>
<p>​        <strong>处理器</strong>    <strong>中央处理器</strong>或<strong>CPU(Central Processing Unit)</strong>,是执行一组固定基本操作的设备。包括：算术操作、逻辑操作、内存存取操作和控制操作。操作对象都是二进制数值。</p>
<p>​        <strong>寄存器</strong>    内存访问较慢，需要较长的指令格式（一个地址可能需要32位）。因此，处理器都配有一些寄存器，每个寄存器只存储一位。紧挨着处理器，相当于处理器的一个高速本地内存，使得处理器能快速地操控数据和指令。</p>
<h4 id="2-Languages"><a href="#2-Languages" class="headerlink" title="2.Languages"></a>2.Languages</h4><p>​        16-位的指令包含四个4bit的位域(fileds)：最左边的域是CPU的操作编码，剩下的三个部分表示该操作的操作数。</p>
<p>​        <strong>二进制码</strong> 封装成 <strong>汇编(assembly language)</strong></p>
<p>​        汇编通过文本处理器编写，并由<strong>汇编编译器(assembler)</strong>将汇编程序 翻译成 <strong>二进制码</strong></p>
<h4 id="3-Commands"><a href="#3-Commands" class="headerlink" title="3.Commands"></a>3.Commands</h4><p>​        <strong>算术操作和逻辑操作</strong>    加减、布尔操作（按位取反、移位…）</p>
<p>​        <strong>内存访问</strong>    内存访问命令分两类。第一类是<strong>算术操作和逻辑操作</strong>，不仅可以操控寄存器，还可以操控指定的内存单元。第二类，所有计算机都会使用<code>load</code>和<code>store</code>命令，用来在寄存器和内存之间传递数据。这些命令可能会应用某些类型的寻址方式，在指令中指定目标内存单元的地址。三种绝大多数计算机支持的寻址方式：</p>
<ul>
<li>​    <strong>直接寻址(Direct Addressing)</strong>        最常用的寻址方式。直接 或 用符号表示内存单元的地址。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">LOAD R1, <span class="number">67</span>  <span class="comment">// R1 &lt;- Memory[67]</span></span><br><span class="line"><span class="comment">// 或者假设bar指向内存地址67，那么就有：</span></span><br><span class="line">LOAD R1, bar  <span class="comment">// R1 &lt;- Memory[67]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>​    <strong>立即寻址(Direct Addressing)</strong>        这种寻址方式用来加载常数——也即是，将指令中数据域的内容当作要操作的数据加载到寄存器。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">LOADI R1, <span class="number">67</span>  <span class="comment">// R1 &lt;- 67</span></span><br></pre></td></tr></table></figure>
<ul>
<li>​    <strong>间接寻址(Direct Addressing)</strong>        这种寻址方式用来处理<strong>指针(pointer)</strong>——也即是，将指令中数据域的内容当作要操作的数据加载到寄存器。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将x = foo[j] or x = *(foo+j)翻译成汇编语言</span></span><br><span class="line">ADD R1, foo, j  <span class="comment">// R1 &lt;- (foo+j)</span></span><br><span class="line">LOAD* R2, R1  <span class="comment">// R2 &lt;- Memory[R1]，取值到R2</span></span><br><span class="line">STR R2, x  <span class="comment">// x &lt;- R2，将值赋给x(内存单元)</span></span><br></pre></td></tr></table></figure>
<p>​        当数组在高级语言程序(C/Java…)被声明并被初始化时，编译器分配一组连续的内存单元来保存这个数组数据，并用foo来指代该内存单元组的<strong>基地址(base address)</strong>。于是当编译器以后遇到表示数组单元的符号<strong>(eg: foo[j])</strong>时，解析地址：<code>foo的基地址 + (j × 单个数组元素所占的字节)</code>。</p>
<p>​        <strong>控制流程</strong>        程序通常以先行执行，但也包含分支：<strong>反复</strong>(repetition, 跳回到循环的初始位置)、<strong>有条件的执行</strong>（conditional executioin, 若false向前跳到<code>if-then</code>语句之后）、<strong>子程序调用</strong>（subrouting calling, 跳到另一代码段的第一条命令处）</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高级实现</span></span><br><span class="line"><span class="keyword">while</span> (R1 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    code <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">code <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 底层实现</span></span><br><span class="line"><span class="comment">// while循环结构的典型翻译</span></span><br><span class="line">beginWhile</span><br><span class="line">    JNG R1, endWhile  <span class="comment">// if R1&lt;0 goto endWhile</span></span><br><span class="line">    <span class="comment">// code 1 的翻译</span></span><br><span class="line">JMP beginWhile  <span class="comment">// goto beginWhile</span></span><br><span class="line">endWhile:<span class="type"></span></span><br><span class="line"><span class="type">	</span>// code <span class="number">2</span> 的翻译</span><br></pre></td></tr></table></figure>
<h3 id="Hack机器语言规范详述"><a href="#Hack机器语言规范详述" class="headerlink" title="[Hack机器语言规范详述]"></a>[Hack机器语言规范详述]</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>​        Hack是一个基于冯·诺伊曼架构的16-位计算机，由一个CPU、两个独立的内存模块（instruction memory指令内存  和  data memory数据内存），以及两个内存映射I/O设备（显示器和键盘）组成。</p>
<p>​        <strong>内存地址空间</strong>        Hack程序员要了解，有两个不同的地址空间：<strong>指令地址空间</strong>（instruction memory<strong>指令内存</strong>），<strong>数据地址空间</strong>（data memory<strong>数据内存</strong>）。两个内存区16-位宽，由15-位地址空间，意味着两个内存可设定的最大地址都是<code>32K</code>的<code>16-bit word</code><strong>(2^15^ = 32 × 1024 = 32K)</strong></p>
<p>​        CPU只能执行存储在指令内存中的程序。指令内存是只读设备，程序通过某种外部方法被加载到指令内存中（加载新程序，就像游戏机更换游戏卡切换游戏）.  Hack平台的硬件仿真器提供一种方法，将某文本文件中用机器语言编写的程序加载到指令内存中。</p>
<p>​        <strong>寄存器(Registers)</strong>        Hack程序员要接触两个称为D和A的16-位寄存器，能够被算数和逻辑指令显式地操控(eg: <code>A = D-1</code>或<code>D = !A</code>)。D只作为数据寄存器（储存数据）；A既可以作为数据寄存器，也可以作为地址寄存器（储存地址）。</p>
<p><img src="/post/f125af90/image-20200827144620317.png" alt="三个寄存器" style="zoom: 50%;"></p>
<p>​        Hack语言规定，内存的存取指令是对隐式的内存地址“M”进行操作。<code>M-&gt;A, A=512, M = memory[512]</code></p>
<h4 id="2-A-指令-地址指令"><a href="#2-A-指令-地址指令" class="headerlink" title="2. A-指令 (地址指令)"></a>2. A-指令 (地址指令)</h4><p>唯一解析的指令：@value，为A寄存器赋值</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* value:</span></span><br><span class="line"><span class="comment"> *  1.非负的十进制常数≤32767(=2^15 - 1)</span></span><br><span class="line"><span class="comment"> *  2.指向(非负的十进制常数)的符号, eg:sum</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@<span class="number">21</span>：</span><br><span class="line"> - A寄存器赋值为<span class="number">21</span>  data register</span><br><span class="line"> - RAM[<span class="number">21</span>]将成为选定的RAM寄存器  address register</span><br><span class="line"><span class="comment">// 二进制形式：0value</span></span><br></pre></td></tr></table></figure>
<p>​        只要赋值赋值给A寄存器，A寄存器会自动从数据存储器中选中被选择的寄存器，被选择的寄存器就是上图中的M寄存器。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set RAM[100] to -1</span></span><br><span class="line">@<span class="number">100</span>  <span class="comment">// A = 100, 二进制：0value(=0000 0000 0110 0100)</span></span><br><span class="line">M = <span class="number">-1</span>  <span class="comment">// RAM[100] = -1</span></span><br></pre></td></tr></table></figure>
<p>​        此段代码，M就是代表了内存单元中的寄存器RAM[100]。这就是 A-指令 的用法，在内存的存取操作之前，我们总是要用 A-指令 去选择一个寄存器，进而完成内存的存取。</p>
<h4 id="3-C-指令"><a href="#3-C-指令" class="headerlink" title="3. C-指令"></a>3. C-指令</h4><p><img src="/post/f125af90/image-20200827153104413.png" alt="C指令" style="zoom:50%;"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dest or jump are optional</span></span><br><span class="line"><span class="comment">// if dest is null, &quot;=&quot; omit</span></span><br><span class="line"><span class="comment">// if jump is null, &quot;;&quot; omit</span></span><br><span class="line">C-instructions: <span class="type">dest </span>= comp;jump</span><br></pre></td></tr></table></figure>
<p>comp域：ALU计算什么；</p>
<p>dest域：计算后的结果（ALU的输出）将被存储到哪里；</p>
<p>jump域：接下来要取出并执行拿一条命令</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set the D register to -1</span></span><br><span class="line">D = <span class="number">-1</span>  <span class="comment">// D in dest table, -1 in comp table</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Set RAM[300] to the value of the D register minus 1</span></span><br><span class="line">@<span class="number">300</span>  <span class="comment">// A = 300, slect the register which I want to operate (access memory)</span></span><br><span class="line">M = D<span class="number">-1</span>  <span class="comment">// (D-1) in comp table</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// If (D-1 == 0) jump to execute the instruction stored in ROM[56]</span></span><br><span class="line">@<span class="number">56</span>  <span class="comment">// A=56</span></span><br><span class="line">D<span class="number">-1</span>;JEQ  <span class="comment">// if (D-1 == 0) go to 56.</span></span><br><span class="line"><span class="comment">// (D-1) in comp table, JEQ is (if out=0 then jump)</span></span><br></pre></td></tr></table></figure>
<p>C-指令的二进制表示：</p>
<p><img src="/post/f125af90/image-20200827160411973.png" alt="C指令的二进制形式" style="zoom:50%;"></p>
<p>C-指令的compute域：</p>
<p><img src="/post/f125af90/image-20200827160756020.png" alt="C-指令的compute域" style="zoom:50%;"></p>
<p>C-指令的dest域：</p>
<p><img src="/post/f125af90/image-20200827160915065.png" alt="C-指令的dest域" style="zoom:50%;"></p>
<p>dest域为3位二进制组合，代表了8种可能。</p>
<p>C-指令的jump域：</p>
<p><img src="/post/f125af90/image-20200827161133846.png" alt="C-指令的jump域" style="zoom:50%;">与dest域相似，junp也是3位二进制组合。</p>
<p>特别的，最后一个指令<code>(0;JMP)</code>执行一个无条件跳转。（其实除了0，还可取任意数值）</p>
<h4 id="4-符号"><a href="#4-符号" class="headerlink" title="4. 符号"></a>4. 符号</h4><p>​        汇编命令可以使用常数或符号来表示内存单元位置（地址）。</p>
<h4 id="5-输入-输出处理"><a href="#5-输入-输出处理" class="headerlink" title="5. 输入/输出处理"></a>5. 输入/输出处理</h4><p>Hack能连接两个外设，屏幕和键盘。两个设备与计算机的交互都是通过<strong>内存映像(memory maps)</strong>实现的。</p>
<p>这意味着在屏幕上描述像素是通过<strong>将二进制值写入</strong>与屏幕相关的<strong>内存段</strong>来实现的。</p>
<p>键盘的输入是通过<strong>读取</strong>与键盘相关的<strong>内存单元</strong>来实现的。</p>
<p>物理I/O设备和它们对应的内存映像是通过<strong>连续的循环刷新</strong>进行<strong>同步</strong>的。</p>
<h4 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h4><p>​        屏幕通过电线连接计算机，如果我们追踪电线，我们可以看到它进连接了RAM的一个区域，称为屏幕内存映射。</p>
<p><img src="/post/f125af90/image-20200828104048726.png" alt="screen memory map" style="zoom:50%;"></p>
<p>​        1 = 黑，0 = 白。而这中间的困难是，显示单元是二维的；内存映射是一维的，我们必须连接起来。我们只能从内存映射中<strong>读写</strong>16位数据，而无法只<strong>操作</strong>一个单独的位的数据。</p>
<p>​        对内存的存取操作都是16位，因此我们可以取出16位，对其中的1位进行操作之后，再存放。</p>
<p>​        另一难题，如何在内存映射出对应的行-列？</p>
<ol>
<li><p><code>word = Screen[32×row + col/16] (整除)</code></p>
<p>​        屏幕的内容<code>(131072 = 256*512)</code>由RAM<strong>基地址</strong>为<strong>16384(0x4000)</strong>的<strong>8K</strong> 内存映射 来表示，作用和记忆单元完全一样，对内存进行读写操作。而在整个计算机中，这个芯片将会成为数据内存的一部分，所以数据内存将由多个芯片组成。<code>8K = 8192, 8192*16bits = 131072</code></p>
<p><code>word = RAM[16384 + 32×row + col/16]</code></p>
</li>
</ol>
<pre><code> ​    求解出行-列，那么如何存取16位地址块中的 哪一个 二进制数呢？
</code></pre><ol>
<li><code>col%16</code>得到0至15之间的数，可以对其置1或0，修改之后再保存整个16位地址。在下一个时钟周期，就可以改变屏幕显示的像素。</li>
</ol>
<p>书上的例子：(应该是最右的元素)</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在屏幕的右上角换一个黑点</span></span><br><span class="line">@SCREEN  <span class="comment">// 将 A寄存器的值 置入 内存映射区，映射到屏幕第一行的16个像素的内存字</span></span><br><span class="line">M = <span class="number">1</span>  <span class="comment">// 1: (00000000000000001), 将最右边的像素变黑</span></span><br></pre></td></tr></table></figure>
<p>视频上的硬件仿真器的例子：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eg:第3行前16列的所有像素变黑</span></span><br><span class="line">CHIP Screen&#123;</span><br><span class="line">	IN  <span class="keyword">in</span>[<span class="number">16</span>],    <span class="comment">// what to write</span></span><br><span class="line">    load,          <span class="comment">// write-enable bit</span></span><br><span class="line">    address[<span class="number">13</span>];   <span class="comment">// where to read/write</span></span><br><span class="line">    OUT out[<span class="number">16</span>];   <span class="comment">// Screen value at the given address   </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 32*3 = 96; address[13] = 96 = (0000 0000 0110 0000);</span></span><br><span class="line"><span class="comment">// load = 1</span></span><br><span class="line"><span class="comment">// in[16] = (1111 1111 1111 1111) = -1</span></span><br><span class="line"><span class="comment">// 写入内存后，还需要run时钟，将在下一个时钟周期刷新后显示</span></span><br></pre></td></tr></table></figure>
<h4 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h4><p>​        键盘通过电缆连接计算机，如果我们追踪电缆，我们可以看到它进入了RAM的一个区域，称为键盘内存映射。</p>
<p><img src="/post/f125af90/image-20200828105047045.png" alt="keyboard memory map" style="zoom:50%;"></p>
<p>​        Hack计算机与物理键盘之间通过RAM基地址为<strong>24576(0x6000)</strong>的单字内存映像进行交互。只要在键盘上敲一个键，其对应的16-位<strong>ASCII码</strong>值就出现在<strong>RAM[24576]</strong>。没有敲键盘时，该内存单元的值就是<strong>0(=0000 0000 0000 0000)</strong>。除了常用的<strong>ASCII码</strong>之外，Hack键盘还可以识别：</p>
<p><img src="/post/f125af90/image-20200828105539792.png" alt="键盘识别额外的键" style="zoom:50%;"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Read-Only</span></span><br><span class="line">CHIP Keyboard &#123;</span><br><span class="line">    OUT out[<span class="number">16</span>];   <span class="comment">// The ASCII code of the pressed key, </span></span><br><span class="line">                   <span class="comment">// or 0 if no key is currently pressed, </span></span><br><span class="line">                   <span class="comment">// or one the special codes listed in Figure 5.5.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        按下瞬间识别，松手则无键按下，置0.</p>
<h3 id="zap-zap-zap-机器语言实践"><a href="#zap-zap-zap-机器语言实践" class="headerlink" title=":zap::zap::zap:[机器语言实践]"></a>:zap::zap::zap:[机器语言实践]</h3><p><strong>D: data register</strong></p>
<p><strong>A: (address / data) register</strong></p>
<p><strong>M: the currently selelcted memory register, M = RAM[A]</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// D = 10</span></span><br><span class="line">@<span class="number">10</span></span><br><span class="line">D=A</span><br><span class="line"></span><br><span class="line"><span class="comment">// D++</span></span><br><span class="line">D+<span class="number">1</span>  <span class="comment">// D+1 in comp table of C-instruction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// D=RAM[17]</span></span><br><span class="line">@<span class="number">17</span>  <span class="comment">// now, M=RAM[17]</span></span><br><span class="line">D=M</span><br><span class="line"></span><br><span class="line"><span class="comment">// RAM[17]=0</span></span><br><span class="line">@<span class="number">17</span></span><br><span class="line">M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RAM[17]=10</span></span><br><span class="line">@<span class="number">10</span></span><br><span class="line">D=A  <span class="comment">// store the value</span></span><br><span class="line">@<span class="number">17</span>  <span class="comment">// slelect the register</span></span><br><span class="line">M=D</span><br><span class="line"></span><br><span class="line"><span class="comment">// RAM[5] = RAM[3]</span></span><br><span class="line">@<span class="number">3</span></span><br><span class="line">D=M</span><br><span class="line">@<span class="number">5</span></span><br><span class="line">M=D</span><br></pre></td></tr></table></figure>
<p>Computes: RAM[2] = RAM[0] + RAM[1]</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@<span class="number">0</span>  <span class="comment">// R0 may be better</span></span><br><span class="line">D=M</span><br><span class="line"></span><br><span class="line">@<span class="number">1</span>  <span class="comment">// R1 may be better</span></span><br><span class="line">D=D+M  <span class="comment">// D+M in comp table of C-instruction</span></span><br><span class="line"></span><br><span class="line">@<span class="number">2</span>  <span class="comment">// R2 may be better</span></span><br><span class="line">M=D</span><br><span class="line">    </span><br><span class="line">@<span class="number">6</span></span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// end of program, use infinite loop to avoid </span></span><br></pre></td></tr></table></figure>
<p>空格在翻译时被忽略。</p>
<p>当我们要使用<strong>寄存器(R0~R15)</strong>时，利用符号表示，以获得更好的可读性：（此时A寄存器作为 address register）</p>
<p><img src="/post/f125af90/image-20200828141806438.png" alt="symbols" style="zoom:50%;"></p>
<p>符号严格区分大小写，请只使用‘R’。</p>
<p>SCREEN、KBD以及其他的内置符号</p>
<p><img src="/post/f125af90/image-20200828142217495.png" alt="extra symbols" style="zoom:50%;"></p>
<p>SCREEN和KBD代表的分别是：输出和输入设备内存映射的基地址。</p>
<h4 id="分支-Branching"><a href="#分支-Branching" class="headerlink" title="[分支 Branching]"></a>[分支 Branching]</h4><p><img src="/post/f125af90/image-20200828144432517.png" alt="branch" style="zoom:50%;"></p>
<p><strong>@LABEL</strong>会被翻译成@n，其中n是<strong>(LABEL)</strong>声明后的<strong>指令号</strong>。</p>
<p>(POSITIVE)是8，(END)是10</p>
<h4 id="Variables"><a href="#Variables" class="headerlink" title="[Variables]"></a>[Variables]</h4><p><img src="/post/f125af90/image-20200828161742688.png" alt="flip" style="zoom:50%;"></p>
<p>@temp变成中间变量，效果相当于@n，</p>
<p>@temp变量从地址16开始，可声明n个变量。</p>
<p>计算累加和</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Computes RAM[1] = 1+2+ ... +RAM[0]</span></span><br><span class="line">    <span class="keyword">int</span> n = R0;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">LOOP:</span><br><span class="line">    <span class="keyword">if</span> i &gt; n <span class="keyword">goto</span> STOP;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> LOOP;</span><br><span class="line">STOP:</span><br><span class="line">    R1 = sum; </span><br></pre></td></tr></table></figure>
<p>将伪代码转换成我们的Hack汇编</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Computes RAM[1] = 1+2+ ... +n</span></span><br><span class="line"><span class="comment">// Usage: put a number (n) in RAM[0]</span></span><br><span class="line"></span><br><span class="line">    @R0</span><br><span class="line">    D=M</span><br><span class="line">    @n</span><br><span class="line">    M=D  <span class="comment">// n = R0</span></span><br><span class="line">    @i</span><br><span class="line">    M=<span class="number">1</span>  <span class="comment">// i = 1</span></span><br><span class="line">    @sum</span><br><span class="line">    M=<span class="number">0</span>  <span class="comment">// sum = 0</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    @i</span><br><span class="line">    D=M</span><br><span class="line">    @n</span><br><span class="line">    D=D-M  <span class="comment">// n - i</span></span><br><span class="line">    @STOP</span><br><span class="line">    D;JGT  <span class="comment">// jump (if) greater than; if i &gt; n goto STOP</span></span><br><span class="line"></span><br><span class="line">    @sum</span><br><span class="line">    D=M</span><br><span class="line">    @i</span><br><span class="line">    D=D+M</span><br><span class="line">    @sum</span><br><span class="line">    M=D</span><br><span class="line">    @i</span><br><span class="line">    M=M+<span class="number">1</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(STOP)</span><br><span class="line">    @sum</span><br><span class="line">    D=M</span><br><span class="line">    @R1</span><br><span class="line">    M=D  <span class="comment">// R[1] = sum</span></span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
<p>​    这是我们最佳的Hack汇编实践方式：</p>
<ol>
<li>Design the program using pseudo code and Make sure it works.</li>
<li>Write the program in assembly language.</li>
<li>Test the program (on paper) using a variable-value trace table.</li>
</ol>
<h4 id="指针"><a href="#指针" class="headerlink" title="[指针]"></a>[指针]</h4><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for(i=0; i&lt;n; i++)&#123;</span></span><br><span class="line"><span class="comment">// 		arr[i] = -1;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// Suppose that arr=100 and n=10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr = 100</span></span><br><span class="line">    @<span class="number">100</span></span><br><span class="line">    D=A</span><br><span class="line">    @arr</span><br><span class="line">    M=D</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n = 10</span></span><br><span class="line">    @<span class="number">10</span></span><br><span class="line">    D=A</span><br><span class="line">    @n</span><br><span class="line">    M=D</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize i = 0</span></span><br><span class="line">    @i</span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    <span class="comment">// if (i==n) goto END. (not STOP cause we dont intent to valuation)</span></span><br><span class="line">    @i</span><br><span class="line">    D=M</span><br><span class="line">    @n</span><br><span class="line">    D=D-M</span><br><span class="line">    @END</span><br><span class="line">    D;JEQ</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RAM[arr+i] = -1</span></span><br><span class="line">    @arr</span><br><span class="line">    D=M</span><br><span class="line">    @i</span><br><span class="line">    A=D+M  <span class="comment">// A = arr+i</span></span><br><span class="line">    M=<span class="number">-1</span>  <span class="comment">// RAM[arr+i] = -1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// i++</span></span><br><span class="line">    @i</span><br><span class="line">    M=M+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
<p><img src="/post/f125af90/image-20200828210609280.png" alt="pointers" style="zoom:50%;"></p>
<ul>
<li><p>高级语言中，<code>arr</code>和<code>i</code>之类<strong>存储地址</strong>的变量称为<strong>指针</strong>。</p>
</li>
<li><p>Hack指针的逻辑：无论何时，当我们必须用指针访问内存，我们需要像<code>A=M</code>的指令。（对<code>RAM[M]</code>操作）</p>
</li>
<li>将地址寄存器（A register）设置为某个内存寄存器的内容，其中我们做了一些指针运算，计算我们需要操作的地址。</li>
</ul>
<h4 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入 / 输出"></a>输入 / 输出</h4><p><img src="/post/f125af90/image-20200828211646079.png" alt="input/output" style="zoom:50%;"></p>
<p>上图知识回顾。</p>
<p>我们需要在屏幕上画全黑的矩形，简单的思路是迭代足够多的行，让屏幕显示“黑块”。</p>
<p>psuedu code: </p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for (i=0; i&lt;n; i++)&#123;</span></span><br><span class="line"><span class="comment">// 		draw 16 block pixels at the beginning of row i</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">	addr = SCREEN</span><br><span class="line">    n = RAM[<span class="number">0</span>]</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    LOOP:<span class="type"></span></span><br><span class="line"><span class="type">        if i &gt; n goto END</span></span><br><span class="line"><span class="type">        RAM</span>[addr] = <span class="number">-1</span>  <span class="comment">// 1111 1111 1111 1111(= 16 black pixels)</span></span><br><span class="line">        <span class="comment">// advances to the next row</span></span><br><span class="line">        addr = addr + <span class="number">32</span>  <span class="comment">// 我们用内存映射的前32行代表一整行512(=32*16)个像素，每行如此</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        goto LOOP</span><br><span class="line"></span><br><span class="line">    END:<span class="type"></span></span><br><span class="line"><span class="type">        goto END</span></span><br></pre></td></tr></table></figure>
<p>实现的Hack汇编：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">   @SCREEN</span><br><span class="line">   D=A</span><br><span class="line">   @addr</span><br><span class="line">   M=D  <span class="comment">// addr = 16384(base address)</span></span><br><span class="line"></span><br><span class="line">   @R0</span><br><span class="line">   D=M</span><br><span class="line">   @n</span><br><span class="line">   M=D  <span class="comment">// n = RAM[0]</span></span><br><span class="line"></span><br><span class="line">   @i</span><br><span class="line">   M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    @i</span><br><span class="line">    D=M</span><br><span class="line">    @n</span><br><span class="line">    D=D-M</span><br><span class="line">    @END</span><br><span class="line">    D;JGT  <span class="comment">// if i &gt; n goto END</span></span><br><span class="line"></span><br><span class="line">    @addr</span><br><span class="line">    A=M</span><br><span class="line">    M=<span class="number">-1</span>  <span class="comment">// RAM[addr] = 1111 1111 1111 1111</span></span><br><span class="line"></span><br><span class="line">    @i</span><br><span class="line">    M=M+<span class="number">1</span>  <span class="comment">// i = i + 1</span></span><br><span class="line">    @<span class="number">1</span></span><br><span class="line">    D=A  <span class="comment">// D = RAM[32]</span></span><br><span class="line">    @addr</span><br><span class="line">    M=M+D  <span class="comment">// addr = addr + 32</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP  <span class="comment">// goto END</span></span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END  <span class="comment">// program&#x27;s end</span></span><br><span class="line">    <span class="number">0</span>;JMP  <span class="comment">// infinite loop</span></span><br></pre></td></tr></table></figure>
<h5 id="键盘-1"><a href="#键盘-1" class="headerlink" title="键盘"></a>键盘</h5><p><img src="/post/f125af90/image-20200828222504824.png" alt="keyboard" style="zoom:50%;"></p>
<ul>
<li>读出RAM[24576]的内容<ul>
<li>如果寄存器存储了0，说明无键输入；</li>
<li>否则，寄存器存储了现在按下的键的<strong>键盘扫描码</strong>。</li>
</ul>
</li>
</ul>
<h4 id="Project"><a href="#Project" class="headerlink" title="[Project]"></a>[Project]</h4><h5 id="1-Mult"><a href="#1-Mult" class="headerlink" title="1. Mult"></a>1. Mult</h5><p>a program performing <code>R2 = R0 * R1</code>.</p>
<p>pseudo code:</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">   i = RAM[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">   LOOP:<span class="type"></span></span><br><span class="line"><span class="type">       </span>// This is assembly, may be variable <span class="string">&#x27;i&#x27;</span> isnt so necessary like C program, can use RAM[<span class="number">0</span>] directly.</span><br><span class="line">       <span class="keyword">if</span> i ≤ <span class="number">0</span> goto STOP  </span><br><span class="line">       i = i - <span class="number">1</span></span><br><span class="line">       sum = sum + RAM[<span class="number">1</span>]</span><br><span class="line">       goto LOOP</span><br><span class="line"></span><br><span class="line">   STOP:<span class="type"></span></span><br><span class="line"><span class="type">       RAM</span>[<span class="number">2</span>] = sum</span><br><span class="line">       </span><br><span class="line">   END:<span class="type"></span></span><br><span class="line"><span class="type">       goto END</span></span><br></pre></td></tr></table></figure>
<p>impletement: mult.asm</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book &quot;The Elements of Computing Systems&quot;</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/04/Mult.asm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiplies R0 and R1 and stores the result in R2.</span></span><br><span class="line"><span class="comment">// (R0, R1, R2 refer to RAM[0], RAM[1], and RAM[2], respectively.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Put your code here.</span></span><br><span class="line"></span><br><span class="line">    @sum</span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line">    @R0</span><br><span class="line">    D=M</span><br><span class="line">    @i</span><br><span class="line">    M=D</span><br><span class="line">    @R2</span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    @i</span><br><span class="line">    D=M</span><br><span class="line">    @STOP</span><br><span class="line">    D;JLE  <span class="comment">// jump less equal; if R[0] &lt;= 0 goto STOP</span></span><br><span class="line">    @i</span><br><span class="line">    M=M<span class="number">-1</span>  <span class="comment">// i--</span></span><br><span class="line"></span><br><span class="line">    @R1</span><br><span class="line">    D=M</span><br><span class="line">    @sum</span><br><span class="line">    M=M+D  <span class="comment">// D = sum + R[0]</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(STOP)</span><br><span class="line">    @sum</span><br><span class="line">    D=M</span><br><span class="line">    @R2</span><br><span class="line">    M=D  <span class="comment">// R[2] = sum</span></span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
<h5 id="2-Fill"><a href="#2-Fill" class="headerlink" title="2. Fill"></a>2. Fill</h5><p><strong>持续监听</strong>键盘输入，只要有<strong>任何键被按下</strong>，屏幕全黑；只要<strong>松开按键</strong>，屏幕恢复全白。</p>
<ol>
<li>如何定义无限循环？</li>
<li>什么意味着监听到按键？</li>
<li>监听到按键后，如何将屏幕变黑？</li>
<li>如何清屏？</li>
</ol>
<p><strong>如何定义无限循环？</strong></p>
<p>关键在于程序结束时的跳转，只要我们能保证，程序总是跳转到循环开始的地方即可。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">(LOOP)</span><br><span class="line">...</span><br><span class="line">@LOOP</span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// 程序结束，跳转到 LOOP tag</span></span><br></pre></td></tr></table></figure>
<p><strong>什么意味着监听到按键？</strong></p>
<p>​        当键盘任意键被按下，那么<strong>键盘的内存映射区</strong>的值一定大于0，所以判断 <strong>键盘基地址(KBD)对应的值</strong> 是否大于0即可。由于程序在<strong>无限循环</strong>，所以只要按键不松开，那么 <strong>KBD的值</strong> 就不会变回0，我们的程序就会一直输出，直到屏幕被填满。</p>
<p>​        如果<strong>KBD的值</strong>为0，说明键盘<strong>空置</strong>，我们的程序应该转而去执行<strong>恢复白屏</strong>的操作。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@KBD</span><br><span class="line">D=M  <span class="comment">// D-register gets the basic address of the keyboard memory-map.</span></span><br><span class="line">@FILL</span><br><span class="line">D;JGT  <span class="comment">// jump (to FILL if D) greater than 0.</span></span><br><span class="line">@CLEAR</span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// other case(= D≤0), unconditional jump to CLEAR</span></span><br></pre></td></tr></table></figure>
<p><strong>监听到按键后，如何将屏幕变黑？</strong></p>
<p>​        这正是<code>FILL</code>需要实现的功能。我们通过课堂的例子知道，一次<strong>存取</strong>操作<strong>最多</strong>只可以将<strong>16bit</strong>的数据置为<strong>-1(= 1111 1111 1111 1111)</strong>，从而变黑。因此如果将全屏幕变黑，就需要通过循环实现，循环需要知道起点和终点或者起点和长度。</p>
<p>​        (起点)我们可以存储当前的地址到变量<code>@current</code>，(终点)存储<strong>屏幕内存映射区的最大单元地址(=24575)</strong>到变量<code>@max</code>。另外，要用长度也可以存储<strong>屏幕最大长度8K(=8192)</strong>。需要注意的是，当前地址表示的是第一个可用的单元地址，如果无可用单元，那么<code>current - max &lt; 0</code>，若等于0，则表示最后一个单元可用。（24576恰好为键盘的内存映射地址）</p>
<p>​        循环条件已经解决，如果填充满了，直接返回LOOP；如果未满，则继续。</p>
<p>​        如果按键不松，那么循环会一直检测到按键，也就会一直执行FILL模块，每执行一次会填充一个单元(=16bits)的黑色像素，因此，在屏幕上看到的像素显示是幕帘式的，而不是骤变的。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@SCREEN</span><br><span class="line">D=A  <span class="comment">// D-register gets the basic address of the screen memory-map.</span></span><br><span class="line">@current</span><br><span class="line">M=D</span><br><span class="line">@<span class="number">24575</span>  <span class="comment">// max address of  the screen memory-map.</span></span><br><span class="line">D=A</span><br><span class="line">@max</span><br><span class="line">M=D</span><br><span class="line"></span><br><span class="line">(FILL)</span><br><span class="line">@current</span><br><span class="line">D=M</span><br><span class="line">@max</span><br><span class="line">D=D-M  <span class="comment">// current - max</span></span><br><span class="line">@LOOP</span><br><span class="line">D;JGT  <span class="comment">// jump if current &gt; max</span></span><br><span class="line"></span><br><span class="line">@current</span><br><span class="line">D=M  <span class="comment">// get address</span></span><br><span class="line">A=D  <span class="comment">// A = current address, in order to change Memory[current]</span></span><br><span class="line">M=<span class="number">-1</span>  <span class="comment">// current address turn black</span></span><br><span class="line">@current</span><br><span class="line">M=M+<span class="number">1</span></span><br><span class="line">@LOOP</span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// return LOOP</span></span><br></pre></td></tr></table></figure>
<p><strong>如何清屏？</strong></p>
<p>​        这正是<code>CLEAR</code>需要实现的功能，是<code>FILL</code>的逆过程。当程序检测到<strong>无按键(KBD的值为0)</strong>，进入<code>CLEAR</code>模块。</p>
<p>​        清屏操作，获取当前地址，并循环：减一，并与屏幕基地址SCREEN比较，若小于则清屏结束；否则，继续清屏。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">(CLEAR)</span><br><span class="line">@current</span><br><span class="line">D=M</span><br><span class="line">D=D<span class="number">-1</span>  <span class="comment">// 先减一</span></span><br><span class="line">@SCREEN</span><br><span class="line">D=D-A  <span class="comment">// (current address) minus (SCREEN basic address)</span></span><br><span class="line">@LOOP</span><br><span class="line">D;JLT</span><br><span class="line">@current</span><br><span class="line">D=M  <span class="comment">// get address</span></span><br><span class="line">A=D  <span class="comment">// A = current address, in order to change Memory[current]</span></span><br><span class="line">M=<span class="number">0</span>  <span class="comment">// current address turn white</span></span><br><span class="line">@LOOP</span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// return LOOP</span></span><br></pre></td></tr></table></figure>
<p>Pseudo code</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">max = <span class="number">24575</span>;</span><br><span class="line">current = SCREEN;</span><br><span class="line">LOOP()&#123;</span><br><span class="line">    <span class="keyword">if</span>(Memory[KBD] &gt; <span class="number">0</span>)&#123;  <span class="comment">// 键盘有按键</span></span><br><span class="line">        FILL();</span><br><span class="line">    &#125;</span><br><span class="line">    CLEAR();</span><br><span class="line">&#125;</span><br><span class="line">FILL()&#123;</span><br><span class="line">    <span class="keyword">if</span>((current-max) &gt; <span class="number">0</span>)&#123;  <span class="comment">// 当前地址大于屏幕显示内存映射区的最大地址，已填满屏幕</span></span><br><span class="line">      LOOP();  </span><br><span class="line">    &#125;</span><br><span class="line">    Memory[current] = <span class="number">-1</span>;</span><br><span class="line">    current++;</span><br><span class="line">    LOOP();</span><br><span class="line">&#125;</span><br><span class="line">CLEAR()&#123;</span><br><span class="line">    <span class="keyword">if</span>((SCREEN-current) &gt; <span class="number">0</span>)&#123;  <span class="comment">// 当前地址小于屏幕显示内存映射区的最小地址，已清空屏幕</span></span><br><span class="line">        LOOP();</span><br><span class="line">    &#125;</span><br><span class="line">    Memory[current] = <span class="number">0</span>;</span><br><span class="line">    current--;</span><br><span class="line">    LOOP();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>implement:</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// max = 24575, store as a address</span></span><br><span class="line">    @<span class="number">24575</span></span><br><span class="line">    D=A</span><br><span class="line">    @max</span><br><span class="line">    M=D</span><br><span class="line"></span><br><span class="line">    <span class="comment">// current = SCREEN, store as a address</span></span><br><span class="line">    @SCREEN</span><br><span class="line">    D=A</span><br><span class="line">    @current</span><br><span class="line">    M=D</span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    <span class="comment">// if(Memory[KBD] &gt; 0)&#123;  // 键盘有按键</span></span><br><span class="line">    <span class="comment">//     FILL();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    @KBD</span><br><span class="line">    D=M  <span class="comment">// *** get Memory[KBD]</span></span><br><span class="line">    @FILL</span><br><span class="line">    D;JGT</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CLEAR();  // no conditional</span></span><br><span class="line">    @CLEAR</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(FILL)</span><br><span class="line">    @current</span><br><span class="line">    D=M</span><br><span class="line">    @max</span><br><span class="line">    D=D-M  <span class="comment">// current - max</span></span><br><span class="line">    @LOOP</span><br><span class="line">    D;JGT</span><br><span class="line"></span><br><span class="line">    @current</span><br><span class="line">    A=M</span><br><span class="line">    M=<span class="number">-1</span></span><br><span class="line">    @current</span><br><span class="line">    M=M+<span class="number">1</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(CLEAR)</span><br><span class="line">    @SCREEN</span><br><span class="line">    D=A  <span class="comment">// *** get SCREEN address</span></span><br><span class="line">    @current</span><br><span class="line">    D=D-M  <span class="comment">// SCREEN - current</span></span><br><span class="line">    @LOOP</span><br><span class="line">    D;JGT</span><br><span class="line"></span><br><span class="line">    @current</span><br><span class="line">    A=M</span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    @current</span><br><span class="line">    M=M<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
<p>做的时候困扰我的反而是：@KBD之后获取Memory[KBD]的值，以及@SCREEN之后获取SCREEN地址。成功把我绕晕了….</p>
<p><img src="/post/f125af90/image-20200830115543297.png" alt="result00" style="zoom:50%;"></p>
<p><img src="/post/f125af90/image-20200830115451987.png" alt="result01" style="zoom:50%;"></p>
<p>A-register、D-register and @value:</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@<span class="number">1024</span>  <span class="comment">// 传说中的 A-instruction  也就是A指令, 下面的都是C指令</span></span><br><span class="line">D=A    <span class="comment">// 读取数据1024, 并赋值给 D-Register 也就是 data-Register 数据寄存器</span></span><br><span class="line">D=M    <span class="comment">// 读取内存地址为1024 的值也就是 Memory[1024]</span></span><br><span class="line">D;JEQ  <span class="comment">// 跳转逻辑 如果当前数据寄存器中的值等于0, 则pc = 1024, 也就是当前下一个输入的指令地址为1</span></span><br></pre></td></tr></table></figure>
<p><em>test:</em>(from阿德莱德大学)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rust 伪代码 add up all 10 numbers in the array numbers</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = sum + *numbers++;</span><br><span class="line">    <span class="keyword">let</span> x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>implement: (passed test)</em></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">    @x  <span class="comment">// 16</span></span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line">    @sum  <span class="comment">// 17</span></span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line">    @numbers  <span class="comment">// address in [18,27]</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    @x</span><br><span class="line">    D=M</span><br><span class="line">    @<span class="number">10</span></span><br><span class="line">    D=D-A  <span class="comment">// (x-10)</span></span><br><span class="line">    @END</span><br><span class="line">    D;JGE  <span class="comment">// 与伪代码符号完全相反：‘＞’ =&gt; ‘≤’</span></span><br><span class="line"></span><br><span class="line">    @numbers  <span class="comment">// array</span></span><br><span class="line">    A=M</span><br><span class="line">    D=M  <span class="comment">// D = *numbers</span></span><br><span class="line">    @sum</span><br><span class="line">    M=D+M  <span class="comment">// sum = *numbers + sum</span></span><br><span class="line">    @numbers</span><br><span class="line">    A=A+<span class="number">1</span>  <span class="comment">// numbers++, get the next one in array</span></span><br><span class="line">    @x</span><br><span class="line">    M=M+<span class="number">1</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetris C5-计算机体系结构</title>
    <url>/post/1404dacc/</url>
    <content><![CDATA[<h1 id="计算机体系结构-Computer-Architecture"><a href="#计算机体系结构-Computer-Architecture" class="headerlink" title="[计算机体系结构 Computer Architecture]"></a>[计算机体系结构 Computer Architecture]</h1><p>本章涵盖“硬件”部分中最难啃的内容。将第1~3章构建的所有芯片整合并集成一台通用计算机Hack。</p>
<p>Hack优点：</p>
<ol>
<li>通过前面构建的芯片可以几小时构建完成。</li>
<li>Hack计算机的体系结构足以描述任何数字计算机的关键操作原理和硬件组成。</li>
</ol>
<p><strong>This chapter is more Complicated than previous.</strong></p>
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><h4 id="1-存储程序概念"><a href="#1-存储程序概念" class="headerlink" title="1. 存储程序概念"></a>1. 存储程序概念</h4><p>​        一个由有限硬件组件构成的计算机却可以执行无限的任务队列，其实都是<strong>“存储程序(stored program)”</strong>概念的硕果。计算机基于固定的硬件平台，能够执行固定的指令集。同时，这些指令能够被当成构建模块，组成任意的程序。而且，这些程序的逻辑被存储到计算机的<strong>存储设备(memory)</strong>里，跟数据一样，成为所谓的<strong>“软件(software)”</strong>。</p>
<h4 id="2-冯·诺伊曼结构"><a href="#2-冯·诺伊曼结构" class="headerlink" title="2.冯·诺伊曼结构"></a>2.冯·诺伊曼结构</h4><p>​        存储系统概念最著名的是<strong>通用图灵机(1936)</strong>和<strong>冯·诺伊曼机(1945)</strong>。</p>
<p>​        图灵机描述虚拟的简单计算机的抽象机，主要用来分分析计算机的逻辑结构。相比之下，冯·诺伊曼机是实际应用型的体系结构，是今天所有计算机结构的基础。</p>
<p><img src="/post/1404dacc/image-20200830133841248.png" alt="冯·诺伊曼机"></p>
<p>​        冯·诺伊曼体系结构的基础是一个<strong>中央处理单元(CPU, Central Processing Unit)</strong>，它与<strong>记忆设备(memory device)</strong>即<strong>广义的内存</strong>进行交互，负责从<strong>输入设备(input device)</strong>接收数据，向<strong>输出设备(output device)</strong>发送数据。体系结构的核心是存储程序的概念：计算机内存不仅存储着要进行操作的数据，还存储着指示计算机运行的指令。</p>
<p>​        广义的内存代表任何具有存储功能的设备和组件。</p>
<p><img src="/post/1404dacc/image-20200901111929066.png" alt="DataBus、AddressBus、ControlBus"></p>
<p>​        Data、Address、Control这三部分的每一段信息都由电线实现，通过一组公共总线。公共电线分别有数据总线、地址总线、控制总线。</p>
<p>​        首先是数据总线和<code>ALU</code>的交互，输入数据进行算术运算或逻辑运算，得出结果再输出到数据总线，然后到<strong>内存(memory)</strong>或<strong>寄存器(registers)</strong>。</p>
<p>​        控制总线。<code>ALU</code>需要知道它每次运行的是什么操作，所以它必须从控制总线中重新获取信息，指定它所要进行的操作类型。通过条件分支或循环条件决定下一个指令是什么？这种控制通过控制位(sel)实现, 所以我们需要从<code>ALU</code>中获取控制信息反馈到控制系统的其他部分。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">————</th>
<th style="text-align:center">CPU中的ALU</th>
<th style="text-align:center">CPU中的Registers</th>
<th style="text-align:center">内存Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据总线</td>
<td style="text-align:center">往<code>ALU</code>输入数据进行算术运算 / 逻辑运算，<code>ALU</code>输出运算结果，再反馈到其它</td>
<td style="text-align:center">读写</td>
<td style="text-align:center">读写</td>
</tr>
<tr>
<td style="text-align:center">地址总线</td>
<td style="text-align:center">————</td>
<td style="text-align:center">间接寻址到RAM或者跳到一个ROM地址</td>
<td style="text-align:center">下图一和图二</td>
</tr>
<tr>
<td style="text-align:center">控制总线</td>
<td style="text-align:center">往<code>ALU</code>输入控制位(sel)决定<code>ALU</code>将要进行的运算操作类型；通过条件分支或循环条件决定下一个指令，获取控制信息反馈到控制系统的其他部分。</td>
<td style="text-align:center">反馈到控制系统的其他部分</td>
<td style="text-align:center">反馈到控制系统的其他部分</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/post/1404dacc/image-20200901145605717.png" alt="dataMemory"></p>
<p>​        根据地址得到需要操作的数据块，并对其进行读写操作。</p>
<p><img src="/post/1404dacc/image-20200901145738663.png" alt="programMemory"></p>
<p>​        需要将下一个程序指令的地址输入到<strong>程序内存</strong>，因为这是我们使用程序指令的地方，放置地址后，从那里得到指令，也可能是数字。程序内存中的指令告诉系统的其他部分该做什么，所以我们需要从下一个指令中获取信息，也即从程序内存的数据输出，并将其输入到控制总线。</p>
<h4 id="3-内存"><a href="#3-内存" class="headerlink" title="3. 内存"></a>3. 内存</h4><p>​        冯·诺伊曼机的内存中存有两种类型的信息：<strong>数据项(data items)</strong> 和 <strong>程序指令(programing instructioins)</strong>。采用不同方式处理两种信息，并被分别存储到不同的内存区，尽管功能不同，但都以二进制数形式存储在具有通用结构的<strong>随机存取器(RAM)</strong>。一个单独的字（一个数据项或者一条指令）通过它的地址指定。</p>
<ul>
<li>数据内存        高级程序操纵的抽象组件，例如变量、数组和对象。这些数据抽象被翻译成机器语言后，变成一连串的二进制数，存储在数据内存。通过指定的地址进行读写操作。</li>
<li>指令内存        高级指令 如上类似处理，并被存储在指令内存。计算机每一步操作，CPU从指令中取出一个字，对其进行解码，从而执行指定的指令，然后计算下一条将要执行的指令。<ul>
<li>指令内存中的指令格式遵守机器语言的规则。</li>
</ul>
</li>
</ul>
<h4 id="4-中央处理器"><a href="#4-中央处理器" class="headerlink" title="4. 中央处理器"></a>4. 中央处理器</h4><p>​        CPU是计算机体系的核心，负责执行已被加载到指令内存的指令。CPU通过使用三个主要的硬件执行指令：<strong>算术逻辑单元(ALU, Arithmetic-Logic Unit)</strong>，一组<strong>寄存器(registers)</strong>和<strong>控制单元(control unit)</strong>。</p>
<ul>
<li><strong>算术逻辑单元（ALU）</strong>        ALU 负责执行计算机中所有底层的算术操作和逻辑操作。</li>
<li><strong>寄存器（Registers）</strong>          CPU 的设计是为了能够快速地执行简单计算。与运算相关的数据暂存到高速寄存器，远比从内存搬进搬出快得多。</li>
<li><strong>控制单元（Control Unit）</strong> 计算机指令用二进制数表示，通常具有16、32或64位宽。在指令可被执行之前，要对其进行解码，指令包含的信息向不同的硬件（ALU，寄存器，内存）发送信号，指使它们如何执行指令。指令解码过程是通过某些<strong>控制单元</strong>完成的。这些控制单元还负责决定下一条读取和执行哪一条指令。</li>
</ul>
<h4 id="5-寄存器"><a href="#5-寄存器" class="headerlink" title="5. 寄存器"></a>5. 寄存器</h4><p>​        内存访问是很慢的过程。当<code>CPU</code>被指示去取内存中地址<code>j</code>的内容时，会连续发生以下操作：</p>
<p>​            (a)  <code>j</code>从<code>CPU</code>传到<code>RAM</code>;</p>
<p>​            (b)  <code>RAM</code>的<strong>直接访问逻辑(direct-access logic)</strong>选中地址为<code>j</code>的寄存器;</p>
<p>​            (c)  <code>RAM[j]</code>的内容传回到<code>CPU</code>;</p>
<p>​        寄存器也能提供同样的数据访问功能， 但没有开会的数据传递和寻址开销。</p>
<ul>
<li><p>寄存器位于<code>CPU</code>内部，所以对它们的访问几乎可以瞬间完成</p>
</li>
<li><p>与数百万个内存单元相比，寄存器数量非常少，机器语言指令可以使用短短几个位就能指定要操作的寄存器在什么位置，指令格式也会更短。</p>
<p>​    </p>
<p>不同的目的，不同的<code>CPU</code>采用不同数量、不同类型的寄存器。</p>
</li>
<li><p><strong>数据寄存器(Data registers)</strong>        为<code>CPU</code>提供短期记忆(memory)服务。例如计算<code>(a+b)*c</code>，必须先计算<code>(a+b)</code>的值并储存，可以暂存<code>(a+b)</code>到数据寄存器。</p>
</li>
<li><p><strong>寻址寄存器(Addressing registers)</strong>   为了进行读写，<code>CPU</code>必须连续访问内存中的数据。这样我们必须确定被访问的<strong>内存字(word)</strong>所在的内存地址。由上条指令得出的地址，地址会被存储在<strong>寻址寄存器</strong>。</p>
</li>
<li><p><strong>程序计数寄存器(Program counter register)</strong>  执行程序时，<code>CPU</code>必须总是知道下一条指令在指令内存中的地址，地址保存在<strong>程序计数寄存器(PC, Program Counter)</strong>中。<code>CPU</code>通过两种方式更新<code>PC</code>的内容：</p>
<ul>
<li>如果当前指令存在需要执行的<code>goto n</code>命令，则<code>CPU</code>将<code>PC</code>置为<code>n</code>；</li>
<li>否则，<code>PC</code>增1以便指针指向程序中的下一条指令。</li>
</ul>
</li>
</ul>
<h4 id="6-输入输出"><a href="#6-输入输出" class="headerlink" title="6.输入输出"></a>6.输入输出</h4><p>​        计算机使用一组<strong>输入输出(I/O)设备</strong>来与其外部环境进行交互。<strong>不考虑</strong>设备本身的构造，每个设备代表一块独立的机器，需要相关的工程知识；CSer设计不同方案将不同外设的<strong>物理细节封装</strong>，让计算机以相同的方式对它们进行操作，其中最简单的实现技巧之一就是<strong>I/O映像(memory-mapped I/O)</strong>。</p>
<p>​        I/O映像的基本思想是：创建I/O设备的二进制仿真，使其对于<code>CPU</code>而言，“看上去”就像普通的内存段。</p>
<h3 id="Hack-硬件平台规范详述"><a href="#Hack-硬件平台规范详述" class="headerlink" title="Hack 硬件平台规范详述"></a>Hack 硬件平台规范详述</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>​        Hack平台是16-位冯·诺伊曼机，一个<code>CPU</code>、两个独立的内存模块（指令内存和数据内存）和两个内存映像I/O设备（屏幕和键盘）。</p>
<p>​        Hack计算机执行位于指令内存中的程序。指令内存是只读设备，可以用ROM芯片实现。加载新的程序意味着要替换整个ROM芯片。HACK平台的硬件仿真器提供了<strong>加载文本文件</strong>的方法，文本文件包含用<strong>Hack机器语言</strong>编写的程序（从新在开始，<strong>分别用RAM和ROM来指代Hack的数据内存和指令内存</strong>）。因此两个独立的内存模块为：RAM和ROM。</p>
<p>​        Hack的CPU由<strong>ALU</strong>和三个分别称为<strong>数据寄存器(D, data regiter)</strong>、<strong>地址寄存器(A, address register)</strong>、<strong>程序计数器(PC, program counter)</strong>的寄存器组成。</p>
<p><img src="/post/1404dacc/image-20200902144121386.png" alt="The Hack Computer"></p>
<p>……省略约3000字，请仔细看书🤣</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="[实现]"></a>[实现]</h3><ul>
<li><strong>Memory</strong>：内存，包括数据内存和指令内存，屏幕内存映像和键盘内存映像</li>
<li><strong>CPU</strong>：包含A寄存器，D寄存器，ALU，PC程序计数器</li>
<li><strong>Computer</strong>：完整的一个计算机平台。运行在仿真平台上</li>
</ul>
<h4 id="Memory："><a href="#Memory：" class="headerlink" title="Memory："></a>Memory：</h4><p>输入管脚：<code>in[16]</code>, <code>load</code>,<code>address[15]</code><br>输出管脚：<code>out[16]</code><br>Memory芯片主要由三个底层芯片构建：RAM16K，Screen，KeyBoard。同时我们必须通过这三个底层芯片来实现一个统一的逻辑地址空间，这个空间从地址0到24567。</p>
<ul>
<li>构建这个连续的地址空间的方法我们可以参考之前第三章由小RAM构建大RAM的方法。</li>
<li>内存的功能首先能够根据<code>address</code>选定需要进行操作的单元。</li>
<li>然后将<code>load</code>信号给指定的内存单元。根据<code>load</code>信号判断是进行写入还是继续保持。</li>
<li>下面进行地址连线：（注意此地址只有15位 -&gt; address[15]）<ul>
<li>RAM16K:  (0~16383) -&gt; (<strong>0</strong>00 0000 0000 0000) ~ ‭(<strong>0</strong>11 1111 1111 1111‬)</li>
<li>Screen:  (16384~24575) -&gt; (<strong>10</strong>0 0000 0000 0000) ~ ‭(<strong>10</strong>1 1111 1111 1111‬)</li>
<li>Keyboard: 24576 -&gt; (<strong>11</strong>0 0000 0000 0000)</li>
</ul>
</li>
</ul>
<ol>
<li><p>首先根据地址进行判断<strong>(00, 01, 10, 11)</strong>，应该将控制信号发送给<code>RAM</code>, <code>Screen</code>, <code>Keyboard</code>中的哪个地址空间。可以使用 <code>DMux</code>解复用 实现‬（将一个地址分发到不同的芯片）。</p>
<ol>
<li>由地址的第15位选择输出，区分出 <strong>RAM(0)</strong> 和 <strong>内存映射区(1)</strong>, 实际输出还是load = (0/1).</li>
<li>再由 <strong>内存映射区(1)</strong> 对应地址的第14位进行选择，区分出 <strong>Screen(0)</strong> 和 <strong>Keyboard(1)</strong>, 实际输出还是load = (0/1)</li>
</ol>
<ul>
<li>由于所给出的地址空间不会超过<code>110 0000 0000 0000</code>‬，所以我们只需要进行一次判断就可以了，而不用考虑后面13位的判断。</li>
</ul>
</li>
<li><p>然后将输入数据<code>in</code>，由<code>上个步骤</code>得出的<strong>控制信号</strong>和<strong>片内选择地址(RAM: 0~14bit, Screen: 0~13bit, Keboard: 1bit)</strong>给对应的芯片处理即可。Screen和Keyboard芯片都是内置好的，因此直接调用接口即可。</p>
</li>
</ol>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>输入管脚：<code>inM[16]</code>, <code>instruction[16]</code>, <code>reset</code><br>输出管脚：<code>outM[16]</code>, <code>writeM</code>, <code>addressM[15]</code>, <code>pc[15]</code><br>CPU实现的一种推荐方案：</p>
<p><img src="/post/1404dacc/image-20200903101409828.png" alt="CPU-inplement"></p>
<ol>
<li>ALU</li>
<li>三个寄存器：A-Register、D-Register、PC</li>
<li>两个Mux（多路复用器）</li>
<li>利用输入的指令的规范逻辑完善<code>c</code>标签（不同芯片的控制位）的逻辑，即可实现CPU</li>
</ol>
<p><img src="/post/1404dacc/image-20200903155249111.png" alt="decode"></p>
<p>​        对指令解码的逻辑，对MSB(0/1)进行区分A-指令和C-指令，提取出另外的15-bit。A-指令保存在<code>A Register</code>，C-指令还需继续解码。</p>
<p><img src="/post/1404dacc/image-20200903161122686.png" alt="ALU-input"></p>
<p>​    ALU的数据输入：D-register、A-register/M-register</p>
<p>​    ALU根据<code>comp</code>域 <strong>控制</strong>输入<strong>执行</strong>哪一个运算函数。</p>
<p><img src="/post/1404dacc/image-20200903161304535.png" alt="ALU-output"></p>
<p>​    ALU数据输出：D-register，A-register，M-register</p>
<p>​    ALU根据<code>dest</code>域 <strong>控制</strong>输出<strong>写入</strong>哪些寄存器</p>
<p><img src="/post/1404dacc/image-20200903161840894.png" alt="reset"></p>
<p>​    计算机已经载入了程序，当按下<code>reset</code>，程序开始运行，重启也可。<strong>(PC=0)</strong></p>
<p><img src="/post/1404dacc/image-20200903162246778.png" alt="jump-control"></p>
<p>​    PC概念：总是发送下一个指令的地址；由指令的<code>jump</code>域控制PC的输出</p>
<ul>
<li>开始/重启程序的执行，<code>reset = 1, PC = 0</code></li>
<li>程序不跳转，<code>jump = (000), PC++</code></li>
<li>程序无条件跳转，<code>jump = (111), PC = A</code></li>
<li>程序有条件跳转（判断条件是否满足再跳转），<code>jump = 1~3个1, PC = A</code></li>
</ul>
<p><img src="/post/1404dacc/image-20200903163053983.png" alt="jump-implement"></p>
<p>​    PC的实现：</p>
<ul>
<li><code>reset</code>是否为1？</li>
<li><code>load</code>由<code>jump</code>域的3-bits和<strong>ALU的控制输出(ZR、NG)</strong>决定</li>
<li><code>load = 1, PC = A; load = 0, PC++</code></li>
</ul>
<p><img src="/post/1404dacc/image-20200903163656399.png" alt="ZR-NG"></p>
<p>​    <strong>ALU的控制输出(ZR、NG)</strong>: 输出是0时，<code>ZR = 1</code>、输出是负数时，<code>NG = 1</code></p>
<h5 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h5><p>对指令进行<strong>解码</strong>，需要回顾一下第四章规范的指令格式：<br><strong>A-指令</strong>：</p>
<script type="math/tex; mode=display">
0vvv~~vvvv~~vvvv~~vvvv</script><p><code>MSB</code>: 0，其余15位表示地址值，存入<code>A Register</code>.</p>
<p> <strong>C-指令</strong>：</p>
<script type="math/tex; mode=display">
111a~~c_1c_2c_3c_4~~c_5c_6d_1d_2~~d_3j_1j_2j_3</script><ul>
<li><p><code>MSB</code>: 1，紧接着的两位无意义；</p>
</li>
<li><p><code>a</code>位域：控制与<code>D Register</code>进行计算的是<code>A Register</code>还是<code>M Register</code>；</p>
</li>
<li><code>comp</code>域：控制运算操作和逻辑操作，具体参考图4.3；</li>
<li><code>dest</code>域：控制目标存储位置，<strong>d~1~</strong>控制是否将ALU的计算结果存入<code>A Register</code>中，<strong>d~2~</strong>控制是否存入<code>D Register</code>中，<strong>d~3~</strong>控制是否存入<code>M Register</code>中;</li>
<li><code>jump</code>域：控制（有条件/无条件）跳转。</li>
</ul>
<h5 id="解码指令"><a href="#解码指令" class="headerlink" title="解码指令"></a>解码指令</h5><p>​        如果是A-指令，那么无论如何都要将地址加载到A寄存器中；如果是C-指令，则需要考虑<strong>d~1~</strong>，是否(1/0)需要将ALU的计算结果保存在A寄存器中。</p>
<p><img src="/post/1404dacc/image-20200903110412596.png" alt="A-Instruction"></p>
<p>​        不妨暂时将第一个Mux的控制位记为<strong>c~m~</strong>，将A寄存器的控制位记作<strong>c~a~</strong>。</p>
<p>​        <strong>c~m~</strong>用于区分<strong>A</strong>-指令<strong>(0-vvv)</strong>和<strong>C</strong>-指令<strong>(111-)</strong>；<strong>c~a~</strong>用于控制是否写入<code>A Register</code>.</p>
<p>那么我们可以得到真值表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Instruction</th>
<th style="text-align:center">Instruction[15]</th>
<th style="text-align:center">d~1~</th>
<th style="text-align:center">c~m~</th>
<th style="text-align:center">c~a~</th>
</tr>
</thead>
<tbody>
<tr>
<td>A-instruction</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>A-instruction</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>C-instruction</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td>C-instruction</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>由真值表我们可以得到控制位<strong>c~m~</strong>和<strong>c~a~</strong>的公式：</p>
<script type="math/tex; mode=display">
c_m~=~\overline{Instruction[15]},~c_a~=~\overline{Instruction[15]·\overline{d_1}}~=~Or(\overline{Instruction[15]}, d1)</script><p>对于A-指令以上的工作就已经足够了。而对于C-指令我们还需要做其他的工作。</p>
<h5 id="C-指令的解码"><a href="#C-指令的解码" class="headerlink" title="C-指令的解码"></a>C-指令的解码</h5><p>​        C指令的d~1~位已经被解析完了，接下来从左向右开始解码。</p>
<ul>
<li><strong><em>a</em></strong>是控制选择<strong>A/M</strong>的控制位，所以它应该在第二个Mux，注意要与<code>MSB</code><strong>取与</strong>操作，确保为C-指令。</li>
</ul>
<p><img src="/post/1404dacc/image-20200903153107852.png" alt="A/M-Register"></p>
<ul>
<li><strong>d~2~</strong>是控制计算结果是否保存在<code>D Register</code>中的，所以它与<code>MSB</code><strong>取与</strong>操作后，作为控制信号给<code>D Register</code>；</li>
</ul>
<p><img src="/post/1404dacc/image-20200903154017004.png" alt="DRegister-C"></p>
<ul>
<li><strong>c~1~~c~6~</strong>是控制ALU的运算函数的，所以它们应该作为ALU的控制位，<code>comp</code>域对应ALU的运算函数。</li>
</ul>
<p><img src="/post/1404dacc/image-20200903153824368.png" alt="ALU-c"></p>
<ul>
<li><strong>d~3~</strong>是控制计算结果是否保存在<code>M Register</code>中的，所以它作为输出与<code>MSB</code><strong>取与</strong>操作后，输出给writeM；</li>
</ul>
<p><img src="/post/1404dacc/image-20200903154052424.png" alt="MRegister-C"></p>
<ul>
<li><strong><em>j</em>~1~, <em>j</em>~2~, <em>j</em>~3~</strong>是控制跳转的，总体上来看，只有两种现象，一种是顺序执行，即PC+1；另一种是跳转到地址为<code>A Register</code>中的地址单元。根据课本给出的编码：</li>
</ul>
<p><img src="/post/1404dacc/image-20200903154135073.png" alt="jump-region"></p>
<p>​        究竟是否需要跳转，要根据ALU的计算结果进行判断。</p>
<p>​        ALU有两个<strong>控制</strong>输出信号：<strong>zr</strong>（当计算结果等于0时为1）对应 <strong>j~1~</strong>，<strong>ng</strong>（当计算结果小于0时为1）对应 <strong>j~2~</strong>；所以我们可以推出：$\overline{ng~+~zr}$（当计算结果大于0时为1）对应 <strong>j~3~</strong></p>
<p>​        结合<code>jump</code>域和ALU的输出结果，可以得到如下真值表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">(j~1~&amp;ng) Or (j~2~&amp;zr) Or (j~3~&amp; $\overline{ng~+~zr}$)</th>
<th style="text-align:center">load</th>
<th style="text-align:center">inc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>Memory</tag>
        <tag>nand2tetris</tag>
        <tag>HDL</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetris C6-汇编编译器</title>
    <url>/post/e93fe37f/</url>
    <content><![CDATA[<h1 id="汇编编译器-Assembler"><a href="#汇编编译器-Assembler" class="headerlink" title="[汇编编译器 Assembler]"></a>[汇编编译器 Assembler]</h1><p>​        我们已经完成了计算机的<strong>硬件平台(hardware platform)</strong>，此后我们将集中探讨计算机的<strong>软件阶层体系(software hierarchy)</strong>，直到最后为简单的面向对象编程语言开发<strong>编译器</strong>和<strong>基本的操作系统</strong>为止。</p>
<p>​        在软件阶层体系中，最基本的模块就是<strong>汇编编译器(assembler)</strong>。在C4中介绍了机器语言的两种表达形式，即<strong>汇编形式</strong>和<strong>二进制形式</strong>。在这里我们将了解编译器如何系统地将汇编语言编写的程序<strong>翻译</strong>成二进制形式。</p>
<p>​        因为<strong>符号化汇编命令(symbolic assembler commands)</strong>与其对应的二进制代码之间的关系很简单，唯一的复杂性在于：<strong>允许汇编程序使用符号来指代内存地址</strong>。我们希望通过编译器来管理这些<strong>用户自定义的符号(symbols)</strong>，将它们解析成物理内存地址。一般使用<strong>符号表(symbol table)</strong>来完成这个任务，这种符号表是经典的数据结构，应用在很多软件编译过程中。</p>
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><h4 id="1-符号-Symbols"><a href="#1-符号-Symbols" class="headerlink" title="1. 符号(Symbols)"></a>1. 符号(Symbols)</h4><p>​        符号在汇编程序通常有两个用途：</p>
<ul>
<li><p><strong>变量(Variables)</strong>：<strong>程序员可以使用符号的变量名称，翻译器会“自动地”为其分配内存地址</strong>。这些地址的实际值是没有意义的，只要在程序的整个编译过程中，<strong>每个符号始终被指代为同一内存地址</strong>即可。</p>
</li>
<li><p><strong>标签(Labels)</strong>：<strong>程序员可以在程序中用符号来标注不同的位置</strong>。比如，可以用标签<code>loop</code>来指代特定代码段的起始位置。程序中的其它指令就可以有条件或无条件地执行<code>goto loop</code>指令。</p>
<p>​        用户定义的<strong>变量名称</strong>和<strong>符号标签(symbolic labels)</strong>，与实际内存地址的映射则不是这么简单。确定符号地址的任务是从用硬件层级上升到软件层级过程中遇到的第一个挑战。</p>
</li>
<li><p><strong>符号解析(Sybol Resolution)</strong>：如下图，该程序包含4个用户自定义的符号：2个变量名称(<strong>i</strong>和<strong>sum</strong>)；2个标签(<strong>loop</strong>和<strong>end</strong>)。<strong><em>如何系统的将符号转换为不含符号的代码呢？</em></strong>制定两个任意性的<strong>规则</strong>：</p>
<ol>
<li><p><strong>翻译后的代码</strong>将被存储到计算机中<strong>起始地址为0的内存</strong>中；</p>
</li>
<li><p><strong>变量</strong>将会被分配到<strong>起始地址为1024的内存</strong>中（这些规则依赖于特定的目标硬件平台）。</p>
</li>
</ol>
<ul>
<li>数据结构处理方式：构建一个<strong>符号表(symbol table)</strong>. 在源代码中，每遇到一个新符号<strong><em>xxx</em></strong>，就在符号表中添加一行<strong>(<em>xxx</em></strong>, <strong><em>n</em>)</strong>。<em>n</em>是分配给对应符号的内存地址。符号表建立完成后，利用他来将程序翻译成无符号的版本。</li>
</ul>
</li>
</ul>
<p><img src="/post/e93fe37f/image-20200905143509717.png" alt="符号解析"></p>
<p>​    如上，符号表的各项键值对 对应了源代码中的自定义符号。只是最后一句需要解释一下，代表了无限循环<code>end:  goto end</code>.</p>
<p>​    其中，有3个要点需要说明。</p>
<ol>
<li>我们定义的变量分配的规则决定了能运行的程序<strong>最多</strong>只能有1024条指令。为了不使实际程序（如操作系统）<strong>溢出</strong>到符号表，存储变量的基地址应该<strong>更远</strong>一些。<strong>(base address&gt;&gt;1024)</strong></li>
<li><strong>“每条源代码命令映射到一个字(word)”</strong>的假设过于天真。一般情况下，某些汇编指令(<code>if i = 101 goto end</code>)会被翻译成几条机器指令，因此每条源代码会占据好几个内存单元。为了解决此问题，翻译程序会记录每条源代码产生的字的个数，然后相应的更新它的<strong>“指令内存计数器(Insvachion memory counter)”</strong>.</li>
<li>对于<strong>“每个变量用一个单一的内存单元来表示”</strong>的假设可能也不实际。编程语言支持<strong>多种类型的变量</strong>，各自占用着<strong>不同的内存空间</strong>。因此，当为变量分配内存空间时，翻译程序必须考虑他们的<strong>数据类型</strong>和<strong>硬件内存单元的宽度</strong>。</li>
</ol>
<h4 id="2-汇编编译器-Assembler"><a href="#2-汇编编译器-Assembler" class="headerlink" title="2.汇编编译器(Assembler)"></a>2.汇编编译器(Assembler)</h4><p>​        汇编编译器将汇编程序翻译成计算机的二进制机器语言，才能被计算机执行。生成的代码被加载到计算机的内存中然后被硬件执行。</p>
<p>​        可见，汇编编译器实际上主要是个文本处理程序，设计目的是提供翻译服务。因此我们要有完整的汇编语法说明文档和相应的二进制代码。有了这样的约定（通常称为机器语言规范），让每个符号命令执行下面的任务：</p>
<ul>
<li><p>解析出符号命令内在的<strong>域</strong>。（解析）</p>
</li>
<li><p>对于每个域，<strong>产生</strong>机器语言中相应的<strong>位域</strong>。（代码生成）</p>
</li>
<li><p>用内存单元的<strong>数字地址</strong>来<strong>替换</strong>所有的<strong>符号引用</strong>。（符号处理）</p>
</li>
<li><p>将二进制码<strong>汇编</strong>成完整的机器指令。（汇编）</p>
<p>其中三个任务（解析、代码生成和汇编）是相当容易实现的。而符号处理则相对复杂，是汇编编译器的主要功能。(——符号表)</p>
</li>
</ul>
<h3 id="Hack-汇编到二进制的翻译规范详述"><a href="#Hack-汇编到二进制的翻译规范详述" class="headerlink" title="[Hack 汇编到二进制的翻译规范详述]"></a>[Hack 汇编到二进制的翻译规范详述]</h3><p>​        总的来说，Assembler是一个翻译挑战，从源语言到目标语言。为了做到这点，我们必须知道两种语言的语法。</p>
<h4 id="1-语法规约和文件格式"><a href="#1-语法规约和文件格式" class="headerlink" title="1. 语法规约和文件格式"></a>1. 语法规约和文件格式</h4><p><strong>文件名称</strong>        习惯上，二进制机器码程序后缀名为“Hack”，汇编代码程序的后缀名为“asm”。因此，Prog.asm文件会被汇编翻译器翻译成Prog.hack文件。</p>
<p><strong>二进制代码(.hack)文件</strong>        二进制代码文件由<strong>文本行</strong>组成。<strong>第一行由16个0/1组成的ASCⅡ码构成一个序列，该序列对一个单一的16-位机器语言指令进行编码</strong>。当机器语言程序被<strong>加载</strong>进计算机的<strong>指令内存</strong>中时，文件的<strong>第n行二进制码</strong>被存储到<strong>地址为n</strong>的指令内存单元内（设命令行的技术和指令内存的起始地址都是从0开始）。    </p>
<p><img src="/post/e93fe37f/memory_layout.png" alt="内存布局"></p>
<p><strong>汇编语言(.asm)文件</strong>        由<strong>文本行</strong>组成，每一行代表一条<strong>指令(instrution)</strong>或者一个<strong>符号声明(symbol declaration)</strong>.</p>
<ul>
<li><strong>指令(Instrution)</strong>        A-指令或C-指令</li>
<li><strong>(Symbol)</strong>        <strong>该伪命令将Symbol绑定到该程序中下一条命令的地址上</strong>。因为它并<strong>不产生机器代码</strong>，所以称之为<strong>“伪代码(pseudo-command)”.</strong>      (eg: (END))</li>
</ul>
<p>（下面的语法仅适用于汇编程序）</p>
<p><strong>常数(constants)和符号(Symbols)</strong>        常数必须是<strong>非负</strong>的，用<strong>十进制</strong>表示。用户定义的符号可以由字母、数字、下划线(_)、点(.)、美元符号($)和冒号(:)组成的字母序列，但是<strong>不能以字母开头</strong>。</p>
<p><strong>注释</strong>        以两条斜线(//)开头的文本行，注释不会被计算机执行。</p>
<p><strong>空格</strong>        空格字符和空行被忽略。</p>
<p><strong>大小写习惯</strong>        <strong>所有的汇编助记符必须大写</strong>。用户<strong>自定义</strong>的符号和变量是<strong>区分大小写</strong>的。一般的习惯是，<strong>标签(labels)大写</strong>，<strong>变量名称小写</strong>。</p>
<h4 id="2-指令"><a href="#2-指令" class="headerlink" title="2. 指令"></a>2. 指令</h4><p>Hack计算机包含两种指令类型，分别称为<strong>寻址指令(A-指令, Addressing Instrution)</strong>和<strong>计算指令(C-指令, Compute Instruction)</strong>。指令格式如下：</p>
<p><img src="/post/e93fe37f/image-20200906092445956.png" alt="A-指令"></p>
<p><img src="/post/e93fe37f/image-20200906092528300.png" alt="C-指令"></p>
<h4 id="3-符号"><a href="#3-符号" class="headerlink" title="3. 符号"></a>3. 符号</h4><p>Hack汇编命令通过使用<strong>常数</strong>或<strong>符号</strong>来指代<strong>内存单元<em>(地址)</em></strong></p>
<blockquote>
<p>从C6开始，若未经特殊说明，内存单元可以用名词“地址”代替，如变量Value的地址是0X5B46，这包含两层意思：</p>
<p>1）说明Value的物理地址是数值0X5B46；</p>
<p>2）<strong>Value代表的变量存储在地址为0X5B46的内存单元中</strong>。</p>
<p>MOV  AX，Value   等价于  MOV  AX，(0X5B46)</p>
</blockquote>
<p>汇编程序中的符号来源于三个方面。</p>
<p><strong>预定义符号(Predefined Symbols)</strong>        任何Hack程序允许使用下面的预定义符号。</p>
<p><img src="/post/e93fe37f/image-20200906093259952.png" alt="预定义符号"></p>
<p><strong>标签符合(Labels Symbols)</strong>        伪命令(Xxx)定义符号Xxx来指代存有程序中下一条命令在指令内存中的地址。每个标签只能定义一次，可以在任何地方使用，甚至在定义之前。有两种实现方法：</p>
<ol>
<li><p>先存储Symbol到符号表(但不知道它在哪里)，当真正遇到正确地址的定义时补上。</p>
</li>
<li><p>第一次遍历程序的Labels和对应的位置，并存储在符号表，第二次遍历把Labels换成Address。(更简单)</p>
</li>
</ol>
<p><strong>变量符号(Variable Symbols)</strong>        任何出现在汇编程序中的符号Xxx，如果它<strong>不是预定义符号也没有在其他地方使用(Xxx)命令</strong>，那么它就被当作是变量。每遇到一个新的变量时，就把它<strong>连续地映射到从16开始的内存中去</strong>。</p>
<h3 id="基本的汇编编译器逻辑"><a href="#基本的汇编编译器逻辑" class="headerlink" title="[基本的汇编编译器逻辑]"></a>[基本的汇编编译器逻辑]</h3><p><img src="/post/e93fe37f/image-20200906095023883.png" alt="汇编编译器的逻辑"></p>
<p>汇编编译器 <strong>(Assembler模块)</strong>循环执行：</p>
<ul>
<li>从输入的文本文件中读取下一个汇编语言的命令（无需记住上一个命令）</li>
<li>把命令分为不同的部分</li>
<li>每个部分都可以用我们的语言指定的一种独特的方式翻译成二进制代码</li>
<li>将这些代码合并为一个机器语言命令（得到的二进制代码直接等同于汇编语言）</li>
<li>输出这个机器语言命令</li>
</ul>
<p>循环直到 文末(EOF)</p>
<p>第一个问题：如何从输入的文本文件中读取下一个汇编语言的命令？</p>
<p>​        唯一的<strong>困难</strong>是我们可能需要跳过所有的注释、空格和空行。我们需要<strong>确保</strong>我们读<strong>取了下一个命令，而不是注释、空格和空行</strong>。</p>
<p>​        读取当前命令，并将其各部分放入某种字符串变量中，变成了一些我们以后可以处理的字符数组。</p>
<p>第二个问题：如何把命令分为不同的部分？</p>
<p>​        利用一些语法，把原来的字符串分成多个部分，其中涉及到一些简单的字符串操作。</p>
<p>第三个问题：如何把ASM翻译成二进制代码？</p>
<p><img src="/post/e93fe37f/image-20200906111607583.png" alt="翻译" style="zoom:67%;"></p>
<p>​        通过查询符号表根据<strong>命令和符号</strong>找到出对应的二进制代码，而数字则直接转换成二进制。</p>
<p>第四个问题：如何将二进制代码合并？</p>
<p><img src="/post/e93fe37f/image-20200906111849947.png" alt="合并" style="zoom:67%;"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="[实现]"></a>[实现]</h3><p>实现计划：</p>
<ol>
<li>我们将从编写一个基本的汇编程序开始，它可以处理那些没有符号的程序。（推迟对符号的处理，直接忽略所有的“空白”）</li>
<li>我们将会发展出处理和使用符号的能力。</li>
<li>最后，使用这个功能，我们会返回到基本的汇编程序<strong>(1.)</strong>，然后将其拓展为通用的汇编程序，它可以翻译任何给定的程序，用Hack汇编代码写成二进制代码。</li>
</ol>
<h4 id="1-1-翻译A-指令"><a href="#1-1-翻译A-指令" class="headerlink" title="1.1 翻译A-指令"></a>1.1 翻译A-指令</h4><p><img src="/post/e93fe37f/image-20200906210200090.png" alt="A-指令" style="zoom: 67%;"></p>
<p>​        当<code>value</code>是非负的十进制常数，或者一个符号指向这样的常数时，就是A-指令。二进制语法<code>0-valueBinary</code>。</p>
<p>​        翻译成二进制码：</p>
<ul>
<li>如果<code>value</code>是十进制常数，那么我们就计算该值的二进制码。为了把它变成一个15位的常数，我们需要加多少个0。</li>
<li>如果是<code>symbol</code>，迟点解决。</li>
</ul>
<h4 id="1-2-翻译C-指令"><a href="#1-2-翻译C-指令" class="headerlink" title="1.2 翻译C-指令"></a>1.2 翻译C-指令</h4><p><img src="/post/e93fe37f/image-20200906211938885.png" alt="image-20200906211938885" style="zoom:67%;"></p>
<p>​        由汇编编译器的解析器，将C-指令分成<code>dest</code>、<code>comp</code>和<code>jump</code>三个部分解析。解析器会获得一个源语句或汇编指令，将它分为三个单独的字段，然后我们可以单独检查每个字段。</p>
<p>​        当设计到C-指令的二进制形式，我们初始化我们正构建的字符串开头有<strong>3个<code>1</code></strong>；</p>
<p>​        接下来的7个位对应于<code>comp</code>域</p>
<p><img src="/post/e93fe37f/image-20200906213014717.png" alt="image-20200906213014717" style="zoom:67%;"></p>
<p>​        根据<code>D+1</code>在表中查询，可得<code>a=0, c=011111</code>，然后把它附加到我逐渐构建的字符串。</p>
<p>​        指令的下一个部分与目标相对应。</p>
<p><img src="/post/e93fe37f/image-20200906213749551.png" alt="C-指令 dest" style="zoom:67%;"></p>
<p>​        根据<code>MD</code>查询相关的表，可得<code>MD=011</code>，并将其附加到逐渐构建的字符串。</p>
<p>​        指令的最后一部分对应于跳转指令。</p>
<p><img src="/post/e93fe37f/image-20200906214014761.png" alt="C-指令 jump" style="zoom:67%;"></p>
<p>​        根据无跳转查询表，可得<code>null=000</code>，附加到字符串，最后构建完成汇编语句对应的二进制码。</p>
<p>​        正如上述，我们在这里所做的一切都是文本处理、字符串处理。我得到一个源字符串，通过特定的解析方式，我在一个渐进的过程中构建目标字符串，每一种高级语言都有执行字符串处理的能力。</p>
<h4 id="1-3-要构建的汇编器的完整逻辑"><a href="#1-3-要构建的汇编器的完整逻辑" class="headerlink" title="1.3 要构建的汇编器的完整逻辑"></a>1.3 要构建的汇编器的完整逻辑</h4><p><img src="/post/e93fe37f/image-20200906214901531.png" alt="image-20200906214901531" style="zoom:67%;"></p>
<p>对于每个指令：</p>
<ul>
<li><p>解析指令：将它分成多个模块。A-：<code>0-value</code>；C-：<code>111a cccc ccdd djjj</code></p>
</li>
<li><p>A-指令：将十进制常数翻译成二进制码；</p>
</li>
<li><p>C-指令：生成指令中各个域对应的二进制码；</p>
<p>将翻译好的二进制码汇编成16-位的机器指令</p>
</li>
<li><p>将16-位的机器指令写入输出文件。</p>
</li>
</ul>
<h3 id="开发一个Hack汇编器"><a href="#开发一个Hack汇编器" class="headerlink" title="[开发一个Hack汇编器]"></a>[开发一个Hack汇编器]</h3><p><img src="/post/e93fe37f/image-20200906220942772.png" alt="开发Hack汇编器" style="zoom:50%;"></p>
<p>规定：</p>
<ul>
<li>开发一个Hack汇编编译器程序，将Hack汇编程序翻译成可执行的Hack二进制码</li>
<li>源程序写在后缀为<code>Prog.asm</code>的文本文件中</li>
<li>生成的二进制码写入到后缀为<code>Prog.hack</code>的文本文件中</li>
<li>假设：<code>Prog.asm</code>无错误检测</li>
</ul>
<p>用法：</p>
<p>命令行语法。该命令应该创建（或覆盖）一个可原封不动在Hack计算机中执行的<code>Xxx.hack</code>文件。</p>
<p>​        构建编译器分为两个阶段。第一阶段，编写汇编编译器(<strong>Paeser模块</strong>和<strong>Code模块</strong>)来翻译<strong>无符号汇编程序</strong>。第二阶段，拓展成为具有<strong>符号处理能力</strong>的汇编编译器。</p>
<h4 id="1-无符号程序的汇编编译器"><a href="#1-无符号程序的汇编编译器" class="headerlink" title="1. 无符号程序的汇编编译器"></a>1. 无符号程序的汇编编译器</h4><ul>
<li>输入的<code>Prog.asm</code>程序不包含符号。A-指令<code>@Xxx</code>必须是十进制非负常数，不能是符号。</li>
<li>不能包含符号命令，<code>(Xxx)</code>不可用。</li>
</ul>
<ol>
<li>打开名为<code>Prog.hack</code>的输出文件</li>
<li>开始处理<code>Prog.asm</code>文件的每一行汇编指令  (Loop)<ul>
<li>对于C-指令，程序将翻译后的指令域的二进制码连接到一个单一的16-位字上，并将其写入<code>Prog.hack</code>文件</li>
<li>对于A-指令，程序将语法分析器返回地十进制常数翻译成对应的二进制表示，并将得到的16-位字写入<code>Prog.hack</code>文件</li>
</ul>
</li>
</ol>
<p><em>Parser.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理.asm文件的指令  eg: @常数, AMD comp JGT/..  (AMD=)(comp运算)(;JGT/...), (Symbol)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 扫描器(Scanner对象)存储输入流，准备语法分析</span></span><br><span class="line">    <span class="comment">// String对象存储当前行的指令</span></span><br><span class="line">    <span class="comment">// 构造器：为汇编编译器构造语法分析器的实例，传入Scanner对象(而Scanner对象由汇编编译器需要编译的文件构造)</span></span><br><span class="line">    <span class="comment">// API:</span></span><br><span class="line">    <span class="comment">// boolean hasMoreCommands(): 扫描器.hasNextLine</span></span><br><span class="line">    <span class="comment">// void advance(): 当前指令.nextLine</span></span><br><span class="line">    <span class="comment">// enum commandType: 三种指令类型</span></span><br><span class="line">    <span class="comment">// void skipSpacesAndComments(): 注释:subString()截掉&#x27;//&#x27;之后的内容, 空白:replace()替换所有空格和制表符</span></span><br><span class="line">    <span class="comment">// int Length(): 当前指令长度</span></span><br><span class="line">    <span class="comment">// commandType CommandType(): 根据当前指令，返回判断得出的指令类型。判断出A-指令和伪指令，剩下的就是C-指令</span></span><br><span class="line">    <span class="comment">// C-指令 API</span></span><br><span class="line">    <span class="comment">// String dest(): 将当前指令分割，返回当前C-指令的dest助记符</span></span><br><span class="line">    <span class="comment">// String comp(): 将当前指令分割，返回当前C-指令的comp助记符</span></span><br><span class="line">    <span class="comment">// String jump(): 将当前指令分割，返回当前C-指令的jump助记符</span></span><br><span class="line">    <span class="comment">// A-指令 API</span></span><br><span class="line">    <span class="comment">// String symbol(): 直接返回@之后的内容，无符号: 必为非负十进制常数</span></span><br><span class="line">    <span class="comment">// void close(): 关闭资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Code.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入一个域的助记符，返回域对应的二进制码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Code</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C-指令</span></span><br><span class="line">    <span class="comment">// comp域</span></span><br><span class="line">    <span class="comment">// HashMap&lt;String, String&gt;对象，存储comp域助记符到二进制码的转换表</span></span><br><span class="line">    <span class="comment">// String comp(): 错误处理,若HashMap对象不存在该comp域指令. 存在则根据HashMap返回comp域助记符**对应的二进制码**</span></span><br><span class="line">    <span class="comment">// dest域, 无需表</span></span><br><span class="line">    <span class="comment">// void checkDest(): 根据dest域助记符判断是否需要存储到寄存器，并往对应的二进制码添加(0/1)</span></span><br><span class="line">    <span class="comment">// String dest(): 用StringBuilder对象存储dest二进制形式，调用checkDest()得到dest正确的二进制表达式，并返回</span></span><br><span class="line">    <span class="comment">// jump域</span></span><br><span class="line">    <span class="comment">// String jump(): 根据jump域助记符，返回jump对应得二进制表达式</span></span><br><span class="line">    <span class="comment">// A-指令</span></span><br><span class="line">    <span class="comment">// String binary(): 对常数的大小进行错误判断，根据十进制常数返回二进制的对应形式，并填充0直至二进制码为15位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Assembler.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assembler</span></span>&#123;</span><br><span class="line">    <span class="comment">// Parser getParser(): 根据文件名创建Parser对象</span></span><br><span class="line">    <span class="comment">// boolean isValidName(): 判断文件是否为.asm文件</span></span><br><span class="line">    <span class="comment">// int getInt(): 返回三种字符串对应的十进制常数</span></span><br><span class="line">    <span class="comment">// main(): </span></span><br><span class="line">    <span class="comment">// 1.解析命令行: (java 包名/类名 .asm文件位置)</span></span><br><span class="line">    <span class="comment">//                                (0)</span></span><br><span class="line">    <span class="comment">// 2.错误处理，命令参数必须是是两个，文件必须是.asm文件; 获得文件名</span></span><br><span class="line">    <span class="comment">// 3.根据文件名实例化Parser对象</span></span><br><span class="line">    <span class="comment">// 4.创建同名的输出流文件.hack，并存储在PrintWriter对象</span></span><br><span class="line">    <span class="comment">// loop</span></span><br><span class="line">    <span class="comment">// 5.循环利用parser解析指令，当前输入还有更多指令时，指令跳向下一行，跳过所有的&quot;空白&quot;，(如果此时指令长度为0，则下一个循环)，否则，创建出Parser对象的CommandType类型对象.</span></span><br><span class="line">    <span class="comment">// 6.根据CommandType对象，进行三种指令的处理</span></span><br><span class="line">    <span class="comment">// C-指令：3个区域分别用Code调用类静态方法，获取3个区域的二进制码，并往输出流对象PrintWriter写入&quot;111 comp dest jump&quot;</span></span><br><span class="line">    <span class="comment">// 伪指令：不处理</span></span><br><span class="line">    <span class="comment">// A-指令：用Code调用类静态方法获取A-指令的二进制码，并输出流对象PrintWriter写入&quot;0 binary&quot;</span></span><br><span class="line">    <span class="comment">// 如果Parser对象判断还有指令则创建新行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-完整的汇编编译器"><a href="#2-完整的汇编编译器" class="headerlink" title="2. 完整的汇编编译器"></a>2. 完整的汇编编译器</h4><h5 id="SymbolTable模块"><a href="#SymbolTable模块" class="headerlink" title="SymbolTable模块"></a>SymbolTable模块</h5><p>​        因为Hack指令可能包含符号，作为翻译的一部分，必须为这些符号确定<strong>实际的地址</strong>。</p>
<p>​        我们用<strong>符号表(symbol table)</strong>来完成，符号表用来建立和维护符号与地质之间的关联。<strong>哈希表(hash table)</strong>就是表示这种关系的经典数据结构之一。</p>
<p><img src="/post/e93fe37f/image-20200910212336715.png" alt="symbolTable"></p>
<h5 id="有符号程序的汇编编译器"><a href="#有符号程序的汇编编译器" class="headerlink" title="有符号程序的汇编编译器"></a>有符号程序的汇编编译器</h5><p>​        有效的方法之一是，从头至尾地读取两次代码。</p>
<p>​        Hack语言有三种类型的符号：预编译符号(predefined symbols)，标签(labels)和变量(variables)。符号表应该包含并处理所有这些符号。</p>
<p>​        <strong>初始化</strong>        创建符号表；根据下表，用所有预定义符号和他们预分配的RAM地址对符号表进行初始化。</p>
<p><img src="/post/e93fe37f/image-20200910212821490.png" alt="预定义符号表"></p>
<p>​        <strong>第一遍读取阶段</strong>        该阶段主要是<strong>在符号表建立每条命令及其对应的地址</strong>。处理程序的每一行时，利用数字来记录ROM地址——当前指令最终将被加载到这个地址中。每次遇到一条<strong>伪指令<em>(Xxx)</em></strong>时，在<strong>符号表</strong>上加一个新条目来<strong>将<em>Xxx</em>与最终用于存储程序中下一条指令的ROM地址关联</strong>。此阶段所有标记和他们的ROM地址被加入到符号表中。</p>
<p>​        <strong>第二遍读取阶段</strong>        重新对每一行指令进行语法分析，每次遇到<strong>符号化A-指令</strong>，就在符号表中查找<strong><em>Xxx</em></strong>。如果在符号表中找到了该符号，就<strong>用其对应的地址来替换该符号与完成指令的翻译</strong>。如果在符合表中<strong>没找到该符号</strong>，那么它必定代表<strong>变量</strong>。为处理这个变量，<strong>在符号表中添加<em>(Xxx, n)</em>，这里<em>n</em>代表下一个可用的个RAM地址</strong>。分配的RAM地址是连续数字，从地址16开始。(紧接着预定义符号之后)</p>
<p><img src="/post/e93fe37f/image-20200910223225858.png" alt="image-20200910223225858" style="zoom:67%;"></p>
<p><em>Parser.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span></span>&#123;</span><br><span class="line">    <span class="comment">// Modify</span></span><br><span class="line">    <span class="comment">// String symbol(): 增加@Variable和(Symbol)的处理。@..返回处理统一，不变；而(Symbol)，只返回Symbol</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>SymbolTable.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Symboltable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 符号表：HashTable&lt;String, Integer&gt;</span></span><br><span class="line">    <span class="comment">// 当前更新变量的地址：16(init)</span></span><br><span class="line">    <span class="comment">// SymbolTable(): 初始化HashTable，并初始化预定义的符号</span></span><br><span class="line">    <span class="comment">// void addEntry(String symbol, int address)</span></span><br><span class="line">    <span class="comment">// boolean contains(String symbol): 是否包含Key</span></span><br><span class="line">    <span class="comment">// int getAddress(String symbol): 根据Key获得Address</span></span><br><span class="line">    <span class="comment">// int getNextAddAndIncrement(): 获取当前更新变量的地址，并令地址加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Assembler.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assembler</span></span>&#123;</span><br><span class="line">    <span class="comment">// Add</span></span><br><span class="line">    <span class="comment">// 添加第一次遍历：主要是构建符号表，将伪指令添加到符号表</span></span><br><span class="line">    <span class="comment">// 记录当前命令被加载到的地址</span></span><br><span class="line">    <span class="comment">// loop</span></span><br><span class="line">    <span class="comment">// 1.循环利用parser解析指令，当前输入还有更多指令时，指令跳向下一行，跳过所有的&quot;空白&quot;，(如果此时指令长度为0，则下一个循环)，否则，创建出Parser对象的CommandType类型对象.</span></span><br><span class="line">    <span class="comment">// 如果指令类型是伪指令，将(符号,当前程序指令地址+1)添加到符号表; 否则当前程序指令地址自增</span></span><br><span class="line">    <span class="comment">// 关闭parser资源</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Modify</span></span><br><span class="line">    <span class="comment">// int getInt(String input, SymbolTable symbolTable): 当input是符号化常数，转换为int并返回; 若不是，处理数字格式异常，(只能是 预定义变量 / 用户自定义变量).</span></span><br><span class="line">    <span class="comment">// - 预定义变量: 返回 根据input符号返回符号表对应的地址</span></span><br><span class="line">    <span class="comment">// - 用户自定义变量: 将(符号，符号表中的当前更新变量的地址)，并返回地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reference: <a href="https://github.com/jahnagoldman">jahnagoldman</a></p>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
        <tag>Assembly</tag>
        <tag>Hack汇编编译器</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetris C7-虚拟机Ⅰ堆栈运算</title>
    <url>/post/83717699/</url>
    <content><![CDATA[<h1 id="虚拟机Ⅰ-堆栈运算-Stack-Arithmetic"><a href="#虚拟机Ⅰ-堆栈运算-Stack-Arithmetic" class="headerlink" title="[虚拟机Ⅰ: 堆栈运算 Stack Arithmetic]"></a>[虚拟机Ⅰ: 堆栈运算 Stack Arithmetic]</h1><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><h4 id="1-虚拟机范型"><a href="#1-虚拟机范型" class="headerlink" title="1.虚拟机范型"></a>1.虚拟机范型</h4><p>​        高级语言程序能够在计算机上运行之前，它必须被翻译成计算机的机器语言，即<strong>编译</strong>。如果每种高级语言被编译成对应于目标硬件平台的机器语言，那么我们必须维护多个版本的代码，这是一种无尽的折磨…</p>
<p><img src="/post/83717699/image-20200911163424313.png" alt="pain" style="zoom:67%;"></p>
<p>​        减少高级语言和机器语言<strong>依赖性</strong>的方法之一是将编译过程分为<strong>两个几乎独立的阶段</strong>。基本思想：中间代码运行在<strong>虚拟机(virtual Machine)</strong>上，而不是正式的硬件平台。</p>
<p><img src="/post/83717699/image-20200911163242720.png" alt="virtualMachine instance"></p>
<p>​        第一个阶段：高级程序被解析出来，其命令被翻译成中间结果。第二个阶段：这些中间结果被进一步翻译成目标硬件的机器语言。当然，两个编译阶段之间的接口<strong>(接口就是中间处理步骤的精确定义)</strong>必须仔细地进行设计。</p>
<p>​        原来作用为一个独立程序的编译器被分成两个独立的程序。第一个程序，编译器(Compiler)，将高级代码翻译成中间VM指令；第二个程序将这个<strong>VM代码翻译成目标计算机硬件平台的机器语言</strong>。</p>
<p>​        Java编译器也是<strong>两层(two-tiered)结构</strong>，它生成运行在JVM虚拟机上(也称为Java运行时环境，<strong>Java Runtime Enviroment</strong>)的byte-code语言。</p>
<p>​        明确且正式的虚拟机语言概念有很多务实的优点。首先，仅需要<strong>替换虚拟机实现部分</strong>（有时候称为编译器的后端程序， backend）就能相对容易地<strong>得到不同硬件平台的编译器</strong>。因此，虚拟机在不同硬件平台之间的<strong>可移植性</strong>可以实现代码效率、硬件成本和程序开发难度之间的权衡。其次，很多语言的编译器能够<strong>共享VM后端程序</strong>，允许<strong>代码共享和语言互用性</strong>。比如，某种高级语言善于科学计算，而另一种在处理用户接口方面很突出。<strong>如果把两种语言编译到通用的VM层，那么通过使用约定的调用语法，其中一种语言的程序就能够很容易地调用另一种语言的程序</strong>。</p>
<p>​        虚拟机方法的另一个优点是<strong>模块化</strong>。<strong>VM的每一个改善都会立即被所有构建于其上的编译器继承</strong>。同样地，每个安装有VM实现的数字设备都能够受益于现有软件的庞大基础。</p>
<p>​        将高级语言翻译成中间代码的程序可以称为<strong>编译器前端程序</strong>，而将中间代码翻译成机器语言的程序可以称为<strong>编译器后端程序</strong>。</p>
<p>​        比如<code>Java</code>，<code>Java</code>的源码经翻译后形成<code>Byte Code</code>文件，<code>Byte Code</code>文件是运行在<code>Java</code>虚拟机上的，而<code>Byte Code</code>文件经翻译后得到机器语言，机器语言运行在硬件平台上。因此，中间代码运行在虚拟机上，机器语言运行在硬件上。</p>
<p>​        编译器的后端程序负责的是将中间代码翻译成机器语言，所以它与硬件平台的关系性非常大，如果我们需要运行在不同的硬件平台上，那么机器语言就会发生变化，因此后端程序就需要改变，而前端程序不需要改变，因而虚拟机可以使语言很方便的进行<strong>跨平台使用</strong>。</p>
<p>​        在此虚拟机中，虚拟机语言共包含4种类型的指令：算术指令，内存访问指令，程序流程控制指令和子程序调用指令。</p>
<p>​        </p>
<h4 id="2-栈式计算机模型"><a href="#2-栈式计算机模型" class="headerlink" title="2.栈式计算机模型"></a>2.栈式计算机模型</h4><p>​        在VM操作中的操作数和结果应该驻留在哪里。也许“最干净利落”的方法是将其放在<strong>栈式(stack)</strong>数据结构。</p>
<h5 id="栈式计算机模型的实现"><a href="#栈式计算机模型的实现" class="headerlink" title="栈式计算机模型的实现"></a>栈式计算机模型的实现</h5><p><img src="/post/83717699/image-20200913101004893.png" alt="stack machine inplementation" style="zoom:50%;"></p>
<p><em>Logic</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*sp = <span class="number">17</span>;</span><br><span class="line">sp++;</span><br></pre></td></tr></table></figure>
<p><em>Hack assembly</em></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@<span class="number">17</span>;  <span class="comment">// A=17</span></span><br><span class="line">D=A;  <span class="comment">// D=17</span></span><br><span class="line"><span class="comment">// *SP=D</span></span><br><span class="line">@SP;  <span class="comment">// A = SP</span></span><br><span class="line">A=M;  <span class="comment">// A = Memory[SP]: indirect address</span></span><br><span class="line">M=D;  <span class="comment">// M = D,( M is (*SP) )</span></span><br><span class="line"><span class="comment">// SP++</span></span><br><span class="line">@SP;</span><br><span class="line">M=M+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="from-VM-to-Assembly"><a href="#from-VM-to-Assembly" class="headerlink" title="[from VM to Assembly]"></a>[from VM to Assembly]</h3><p><strong><em>push &amp; pop</em> implementation:</strong></p>
<p><img src="/post/83717699/image-20200923124849383.png" alt="push/pop" style="zoom:67%;"></p>
<p><strong><em>stack</em> implementation</strong></p>
<p><img src="/post/83717699/image-20200923125313183.png" alt="image-20200923125313183" style="zoom:67%;"></p>
<p><strong><em>implement constant:</em></strong>no <code>pop</code></p>
<p><img src="/post/83717699/image-20200913111011987.png" alt="implement constant" style="zoom:50%;"></p>
<ul>
<li>不允许存储任何东西到<code>constant</code>段</li>
</ul>
<p><strong>Implementing <em>local</em></strong></p>
<p><img src="/post/83717699/image-20200913103134064.png" alt="local" style="zoom:50%;"></p>
<p><em>logic</em>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addr = LCL + <span class="number">2</span>;</span><br><span class="line">SP--;</span><br><span class="line">*addr = *SP;</span><br></pre></td></tr></table></figure>
<p><em>implement:</em></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@<span class="number">2</span>;</span><br><span class="line">D=A;</span><br><span class="line">@LCL;</span><br><span class="line">D=M+D;</span><br><span class="line">@addr;</span><br><span class="line">M=D;</span><br><span class="line"><span class="comment">// SP--, SP is a pointer</span></span><br><span class="line">@SP;</span><br><span class="line">A=M;</span><br><span class="line">M=M<span class="number">-1</span>;  <span class="comment">// SP--</span></span><br><span class="line">D=M;  <span class="comment">// D=SP</span></span><br><span class="line">@addr;</span><br><span class="line">A=M;  <span class="comment">// A=addr, M=*addr</span></span><br><span class="line">M=D;</span><br></pre></td></tr></table></figure>
<h5 id="summary"><a href="#summary" class="headerlink" title="summary:"></a>summary:</h5><p>previous <em>Logic</em> is <code>pop local i</code>, and <code>push local i</code> is similiar.</p>
<p><code>pop local i</code>is to<code>addr = LCL + i, SP--, *addr = *SP</code></p>
<p><code>push local i</code> is to<code>addr = LCL + i, *SP = *addr, SP++</code></p>
<p><img src="/post/83717699/image-20200913104413496.png" alt="summary" style="zoom:50%;"></p>
<p><strong>implement <em>lcoal, argument, this, that</em></strong>:</p>
<p><img src="/post/83717699/image-20200923151620070.png" alt="image-20200923151620070" style="zoom:67%;"></p>
<ul>
<li>将函数方法局部变量和参数变量映射到<code>local</code>和<code>argument</code>段</li>
<li>将函数方法正在处理的对象属性字段和数组项(条目)映射到<code>this</code>和<code>that</code>段</li>
</ul>
<p><img src="/post/83717699/image-20200913144322327.png" alt="four segment" style="zoom: 80%;"></p>
<p><code>local</code>, <code>argument</code>, <code>this</code> 和 <code>that</code>都是同样的实现，只需要将<code>segment</code>替换就可以得到另一种。</p>
<script type="math/tex; mode=display">
segment = \{lcoal, argument, this, that\}</script><p><strong><em>implement static</em></strong>:class level variable</p>
<p><img src="/post/83717699/image-20200913150214722.png" alt="static-variable" style="zoom: 80%;"></p>
<p>​    挑战：<code>static</code>变量应该对程序中的所有函数方法可见</p>
<p>​    解决方法：将其存储在<code>global space</code>全局段中</p>
<ul>
<li>VM翻译器必须翻译每一个VM指向的<code>static i</code>(in the file <em>Foo.vm</em>)到Hack汇编程序的<code>Foo.i</code></li>
<li>遵循Hack汇编的语法，Hack汇编编译器将会把这些映射到<code>RAM[16], ... , RAM[255]</code></li>
</ul>
<p><em>implement Memory segment:</em> <code>temp</code></p>
<p><img src="/post/83717699/image-20200913162748968.png" alt="temp01" style="zoom: 67%;"></p>
<ul>
<li>有些时候，编译器需要用一些中间变量，我们的VM提供了8个类似的变量，存储在<code>temp</code>段</li>
</ul>
<p><img src="/post/83717699/image-20200913163030397.png" alt="temp02" style="zoom:67%;"></p>
<p>✨✨<code>temp</code>: from VM code to Assembly pseudo code</p>
<p>8个变量存储在<code>RAM[5]~RAM[12]</code></p>
<p><strong><em>implement pointer 0/1</em></strong></p>
<ul>
<li>用于存储<code>this</code>和<code>that</code>段的基地址</li>
<li>当我们编写编译器时，就会知道<code>this</code>的重要性</li>
</ul>
<p><img src="/post/83717699/image-20200922135814987.png" alt="pointer"></p>
<ul>
<li>通过访问<code>THIS</code>从而访问<code>pointer 0: this</code></li>
<li>通过访问<code>THAT</code>从而访问<code>pointer 1: that</code></li>
</ul>
<h5 id="Summary"><a href="#Summary" class="headerlink" title="Summary:"></a>Summary:</h5><p><img src="/post/83717699/image-20200922135405740.png" alt="总结1" style="zoom:67%;"></p>
<p><img src="/post/83717699/image-20200922135427724.png" alt="总结2" style="zoom:67%;"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="[实现]"></a>[实现]</h3><h5 id="综合内存映射分析堆栈运算"><a href="#综合内存映射分析堆栈运算" class="headerlink" title="综合内存映射分析堆栈运算"></a><strong>综合内存映射分析堆栈运算</strong></h5><p>​        做好本章的项目，理解好<strong>内存映射(Memory Map)</strong>是关键，只有理解了内存映射才能知道去哪里取数据，将数据存储到哪里。</p>
<p>​        综合来看，本章的大致思路就是：从<strong>RAM[1]~RAM[4]</strong>中找到<strong>基址</strong>，根据偏移量计算出地址，再去获取数据，并将数据放入堆栈中，在栈区中完成一定操作后，再将结果从堆栈中弹出，放到指定的内存单元（这里实际上还需要计算基址和偏移量）。不同的是<code>temp</code>段，它可以直接在<strong>RAM[5]</strong>上加上偏移量得到存储单元的地址。</p>
<p>​        在整个操作过程中，如果需要使用除D寄存器和A寄存器之外的寄存器暂时存储结果的时候，就会使用到<strong>RAM[13]~RAM[15]</strong>的通用寄存器。</p>
<p><strong><em>Review:</em></strong></p>
<ol>
<li><p><code>@X</code>的意义为把<code>X</code>存入A寄存器，M代表的是<code>Memory[A]</code>，即A映射的地址中所存的值。<br><code>A=M, M=D</code>两句意味着1. A更新为M寄存器存储的数据所指向的地址，2.将D寄存器存储的的数据存入<code>Memory[A]</code>，这是这一章中用得最多的逻辑语句。</p>
</li>
<li><p>在实现<code>eq</code>, <code>gt</code>, <code>lt</code>时，需要用汇编语言实现<code>if</code>分支，这里需要用到两个<code>lable</code>，一个<strong>有条件</strong><code>jump</code>，一个<strong>无条件</strong><code>jump</code>，代码实现为：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compare R1=R2 set result in R3</span></span><br><span class="line">@SP</span><br><span class="line">AM=M<span class="number">-1</span></span><br><span class="line">D=M</span><br><span class="line">A=A<span class="number">-1</span></span><br><span class="line">D=M-D</span><br><span class="line">@RET_TRUE</span><br><span class="line">D;JEQ</span><br><span class="line">@SP         <span class="comment">// need to return False</span></span><br><span class="line">A=M<span class="number">-1</span></span><br><span class="line">M=<span class="number">0</span></span><br><span class="line">@CONTINUE</span><br><span class="line"><span class="number">0</span>;JMP</span><br><span class="line">(RET_TRUE)</span><br><span class="line">@SP        <span class="comment">// need to return True</span></span><br><span class="line">A=M<span class="number">-1</span></span><br><span class="line">M=<span class="number">-1</span></span><br><span class="line">(CONTINUE)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>push segment i</code>的实现：<code>addr = segmentPointer+i, *SP = *addr, SP++</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@segmentPointer</span><br><span class="line">D=M</span><br><span class="line">@index</span><br><span class="line">A=D+A</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>pop segment i</code>的实现：<code>addr = segmentPointer+i, SP--, *addr = *SP</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@segmentPointer</span><br><span class="line">D=M</span><br><span class="line">@index</span><br><span class="line">D=D+A</span><br><span class="line">@R13</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">AM=M<span class="number">-1</span></span><br><span class="line">D=M</span><br><span class="line">@R13</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure>
<p><code>push/pop temp i</code>的实现</p>
<p>push: <code>addr = 5 + i, *SP = *addr, SP++</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@<span class="number">5</span>+index</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>pop:  <code>addr = 5 + i, SP--, *addr = *SP</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@SP</span><br><span class="line">AM=M<span class="number">-1</span></span><br><span class="line">D=M</span><br><span class="line">@<span class="number">5</span>+index</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>push pointer 0/1</code>的实现：<code>*SP = THIS/THAT, SP++</code></p>
<p><code>pop pointer 0/1</code>的实现：<code>SP--, THIS/THAT = *SP</code></p>
<p>与temp类似</p>
</li>
<li><p><code>push/pop static i</code>的实现：<code>@vmName.index ...</code></p>
<p>与temp类似</p>
</li>
<li><p><code>segment</code>和<code>pointer</code>,<code>static</code>,<code>temp</code>段的区别只有：<code>segment</code>段需要额外计算地址</p>
<p>即<code>push/pop local 2</code>，需要计算<code>LCL+2</code>再进行<code>push/pop</code>操作</p>
</li>
</ol>
<p><strong><em>Recommand:</em></strong></p>
<ol>
<li>按照书中推荐的实现步骤，依次实现5个.vm文件的转化</li>
<li>对于每个步骤，先在VM Emulator中运行.vm文件和VME.tst测试文件，通过观察其每一步是如何实现的，深入理解VM语言中<code>push</code>，<code>pop</code>和各个参数的实际意义</li>
<li>手写练习相关Hack汇编语言，对于每个<code>segment</code>段的转换，至少完成一个例子</li>
<li>将转换过程用高级语言实现(Java/Python/…)，测试修改，抽象方法，代码复用</li>
</ol>
<p><img src="/post/83717699/image-20200922135207520.png" alt="建议实现步骤" style="zoom: 80%;"></p>
<p><img src="/post/83717699/image-20200922135257496.png" alt="建议实现步骤2" style="zoom:80%;"></p>
<p><strong><em>Tips:</em></strong></p>
<ol>
<li><p>第七章中的机器语言和第六章中的机器语言在结构上略有不同，这一章中的语言更加向高级语言靠拢，在有些地方显得“啰嗦”</p>
<p><code>push constant 7</code>需要如此多的汇编语言实现，但是其中每一句话都是有意义的，所以一定要理解每一句VM语言究竟做了哪些事</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@<span class="number">7</span>          <span class="comment">// constant 7</span></span><br><span class="line">D=A         <span class="comment">// D=7</span></span><br><span class="line">@SP         <span class="comment">// A=栈顶指针=RAM[0]</span></span><br><span class="line">A=M         <span class="comment">// A=Memory[A], A更新为M存储的数据所指向的地址</span></span><br><span class="line">M=D         <span class="comment">// Memory[A]=D</span></span><br><span class="line">@SP         <span class="comment">// A=栈顶指针</span></span><br><span class="line">M=M+<span class="number">1</span>       <span class="comment">// 栈顶指针++</span></span><br></pre></td></tr></table></figure>
<p><code>pop constant 7</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@<span class="number">7</span></span><br><span class="line">D=A</span><br><span class="line">@SP</span><br><span class="line">M=M<span class="number">-1</span></span><br><span class="line">A=M</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>因为一个vm文件中可能会同时出现许多<code>eq</code>，<code>lt</code>这样的涉及<code>jump</code>的语句，如果每一个<code>lable</code>都相同的话，那么<code>lable</code>就会产生重复冲突，如：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@Label</span><br><span class="line">...</span><br><span class="line">(Label)</span><br><span class="line">...</span><br><span class="line">@Label</span><br><span class="line">...</span><br><span class="line">(Label)</span><br></pre></td></tr></table></figure>
<p>当机器到达第一个<code>@lable</code>点时，就会跳到最后一处<code>(lable)</code>。为了避免这种情况，需要给不同的<code>lable</code>依次加上编号，如<code>lable1</code>，<code>lable2</code>，这里可以使用定义全局变量来实现。</p>
</li>
</ol>
<ol>
<li>翻译<code>pop segment index</code>的过程中，首先需要获取<code>segment</code>中存储的地址，然后将<code>index</code>加在这个地址上，得到目标地址。最后把当前<code>SP</code>所指向的地址中的值弹入这个目标地址。这个过程是无法用机器语言直接实现的，因为当中涉及两次调用寄存器D。唯一的解决方案就是在翻译过程中用<code>index</code>控制循环语句，让其自动添加<code>index</code>次的<code>A=A+1</code>，这样的话就免去了多次调用D寄存器的困难。</li>
</ol>
<p><em>Parser.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析.vm文件，封装对输入代码的访问操作</span></span><br><span class="line"><span class="comment"> * 读取vm指令并解析，然后为它各个部分提供方便的访问入口</span></span><br><span class="line"><span class="comment"> * 移除代码中所有空格和注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span></span>&#123;</span><br><span class="line">    <span class="comment">// variable: 文件扫描、当前指令、当前文件名</span></span><br><span class="line">    <span class="comment">// 算术指令的字符串数组</span></span><br><span class="line">    <span class="comment">// Paser模块基本函数：构造函数、更多指令、advance()、commandType()区分指令类型、返回指令第一个参数、返回指令第二个参数</span></span><br><span class="line">    <span class="comment">// 当前指令长度</span></span><br><span class="line">    <span class="comment">// 返回完整指令</span></span><br><span class="line">    <span class="comment">// 设置和获取文件名</span></span><br><span class="line">    <span class="comment">// 关闭资源</span></span><br><span class="line">    <span class="comment">// 判断是否为算术指令  be used in commandType()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>CodeWriter.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeWriter</span></span>&#123;</span><br><span class="line">    <span class="comment">// PrintWriter对象、当前文件名、区分分支标签的数字</span></span><br><span class="line">    <span class="comment">// 构造函数(PrintWriter): 区分分支标签的数字置零</span></span><br><span class="line">    <span class="comment">// 设置翻译出来的的.vm文件的文件名(提取出文件名)</span></span><br><span class="line">    <span class="comment">// writeArithmetic(String command): 将给定的算术操作所对应的汇编写到输出文件</span></span><br><span class="line">    <span class="comment">// writePushAndPop(Parser.Command command, String segment, int index): </span></span><br><span class="line">    <span class="comment">//   1.constant: @idnex, D=A, 将D寄存器的值存储在SP所指向的内存单元, SP++</span></span><br><span class="line">    <span class="comment">//   2.local,argument,this,that: </span></span><br><span class="line">    <span class="comment">//     (1)push: (addr = segmentPointer+i, *SP = *addr, SP++)</span></span><br><span class="line">    <span class="comment">//             获取对应(segmentPointer+i)所指向的地址,M[SP]获取对应的值,SP++</span></span><br><span class="line">    <span class="comment">//     (2)pop: (addr = segmentPointer+i, SP--, *addr = *SP) 需要借助R13存储中间值</span></span><br><span class="line">    <span class="comment">//             获取对应(segmentPointer+i)所指向的地址,SP--,对应的内存单元获取M[SP]的值</span></span><br><span class="line">    <span class="comment">//   3.temp: </span></span><br><span class="line">    <span class="comment">//     (1)push: (*SP = 5+i, SP++)</span></span><br><span class="line">    <span class="comment">//     (2)pop: (SP--, 5+i = *SP)</span></span><br><span class="line">    <span class="comment">//   4.pointer: </span></span><br><span class="line">    <span class="comment">//     (1)push pointer 0/1: (*SP = THIS/THAT, SP++) 根据0/1决定THIS/THAT</span></span><br><span class="line">    <span class="comment">//     (2)pop  pointer 0/1: (SP--, THIS/THAT = *addr)</span></span><br><span class="line">    <span class="comment">//   5.static:</span></span><br><span class="line">    <span class="comment">//     (1)push: (*SP = fileName.index, SP++)</span></span><br><span class="line">    <span class="comment">//     (2)pop: (SP--, fileName.index = *SP)</span></span><br><span class="line">    <span class="comment">// segment: local,argument,this,that  </span></span><br><span class="line">    <span class="comment">//   void writeBasePush(String segmentPointer, int index)</span></span><br><span class="line">    <span class="comment">//   void writeBasePop(String segmentPointer, int index)</span></span><br><span class="line">    <span class="comment">// poiner, static, temp</span></span><br><span class="line">    <span class="comment">//   void writeMappedPush(String location)</span></span><br><span class="line">    <span class="comment">//   void writeMappedPop(String location)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>VMTranslator.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VMTranslator</span></span>&#123;</span><br><span class="line">    <span class="comment">// 需要解析的.vm文件数组链表，处理无.vm文件的情况</span></span><br><span class="line">    <span class="comment">// getParser(File): 根据File文件对象创建Parser对象，与chap6类似</span></span><br><span class="line">    <span class="comment">// printCommandLineErrorAndExit(): 命令行错误处理</span></span><br><span class="line">    <span class="comment">// 判断命令行是否正确，错误则调用函数处理</span></span><br><span class="line">    <span class="comment">// 检查提供的命令行参数，以确定它是有效的文件或目录(1.不存在，2.文件，3.目录)</span></span><br><span class="line">    <span class="comment">// if 1.输出错误</span></span><br><span class="line">    <span class="comment">// else if 2.确定是.vm文件，获取Parser对象，并解析指令参数(路径+文件名)初始化Parser对象的文件名; 调用翻译函数</span></span><br><span class="line">    <span class="comment">// else if 3.将指令参数arg[0]映射路径下的所有文件转换成File对象，并用File[]数组存储; 遍历所有文件，找出.vm文件并根据File获取Parser，依据.vm文件File对象设置Paser对象文件名，设置输出文件名(绝对路径+&#x27;/&#x27;+文件名+&#x27;.asm&#x27;)，调用函数翻译成.asm文件，并把该文件加入到数组链表</span></span><br><span class="line">    <span class="comment">// 			if 若Parser对象的数组链表为空则输出错误并退出</span></span><br><span class="line">    <span class="comment">// else 4.错误处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// writeVM2ASM(String, Parser): 空建CideWriter对象，根据String构造PrintWriter对象，再由其构造CodeWriter对象，并从parser获取文件名设置CodeWriter对象的文件名。</span></span><br><span class="line">    <span class="comment">// 还有命令:向前，跳空白，parser长度为0下一循环，若parser的命令类型是&#x27;push&#x27;或&#x27;pop&#x27;则调用codewriter对象写入Push和Pop相应的ASM指令，算术指令调用相应的函数</span></span><br><span class="line">    <span class="comment">// finally 释放parser和codewriter资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
        <tag>VirtualMachine</tag>
        <tag>vm code</tag>
      </tags>
  </entry>
</search>
