<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言内存布局</title>
    <url>/post/908b7180/</url>
    <content><![CDATA[<h1 id="C语言程序的内存布局"><a href="#C语言程序的内存布局" class="headerlink" title="C语言程序的内存布局"></a>C语言程序的内存布局</h1><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><ul>
<li><p>在我们的计算机内存中，需要为程序存储的不同类型的数据分为不同的部分：</p>
<p><img src="/post/908b7180/memory_layout.png" alt></p>
<ul>
<li><strong>机器码</strong>部分是我们的已编译程序的二进制代码。当我们运行程序时，该代码将被加载到内存的“顶部”。</li>
<li><strong>全局变量</strong>是我们在程序中声明的全局变量或整个程序可以访问的其他共享变量。</li>
<li><strong>堆</strong>部分是一个空区域，<code>malloc</code>可以从中获取可用内存，供程序使用。<code>Dynamic Memory</code>动态申请的内存将存放在<strong>堆</strong>。</li>
<li><strong>栈</strong>部分由程序中的函数调用时使用。<code>function</code>任何函数和<code>Local Variables</code>本地变量 都将存放在<strong>栈</strong>，函数体内再进行函数调用将会在原本的栈区之上再叠一层，因为每个函数都有自己的主存区域。</li>
<li>例如，我们的<code>main</code>函数位于<strong>栈</strong>的最底部，而<code>main</code>调用的其他函数一层一层往上堆叠。</li>
</ul>
<hr>
<p>❌交换函数：交换的只是传入的变量的副本。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>例如，我们的<code>main</code>函数位于栈区的最底部，并且具有局部变量<code>x</code>和<code>y</code>。 调用交换函数时，它具有自己的存储框架或内存片，位于主存储器的顶部，具有局部变量<code>a</code>，<code>b</code>和<code>tmp</code>。</p>
</li>
<li><p>一旦函数交换返回，它所使用的内存将被释放以用于下一个函数调用，除了返回值，我们将丢失所做的所有事情，并且程序将返回称为交换的函数。</p>
</li>
</ul>
<p><img src="/post/908b7180/stack.png" alt></p>
<ul>
<li>因此，通过将<code>x</code>和<code>y</code>的地址从<code>main</code>传递到<code>swap</code>，我们实际上可以更改<code>x</code>和<code>y</code>的值：</li>
</ul>
<p><img src="/post/908b7180/pointers.png" alt></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    swap(&amp;x, &amp;y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li><code>x</code>和<code>y</code>的地址从<code>main</code>传递到<code>swap</code>，并且我们使用<code>int *a</code>语法声明我们的<code>swap</code>函数接受指针。 我们通过跟随指针<code>a</code>将<code>x</code>的值保存到<code>tmp</code>，然后通过跟随指针<code>b</code>取<code>y</code>的值，并将其存储到<code>a(x)</code>所指向的位置。 最后，我们将<code>tmp</code>的值存储到<code>b(y)</code>所指向的位置，然后完成。</li>
</ul>
</li>
<li>如果调用<code>malloc</code>的次数过多，则会发生堆溢出，最终导致溢出到栈区。 或者，如果调用的函数过多，则会发生堆溢出，其中堆也分配了过多的内存帧。 这两种类型的溢出通常称为缓冲区溢出，之后我们的程序（或整个计算机）可能崩溃。</li>
</ul>
<h3 id="未分配内存的指针"><a href="#未分配内存的指针" class="headerlink" title="未分配内存的指针"></a>未分配内存的指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x;</span><br><span class="line">    <span class="keyword">int</span> *y;</span><br><span class="line">    x = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *x = <span class="number">42</span>;</span><br><span class="line">    *y = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>y</code>没有被分配内存，最终程序将会出错。此时的<code>y</code>其实是garbage，保存了垃圾值。</p>
]]></content>
      <categories>
        <category>内存布局</category>
      </categories>
      <tags>
        <tag>memory layout</tag>
        <tag>stack</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>
<!-- 
hexo-generator-index從 2.0.0 開始，已經支持文章置頂功能。
你可以直接在文章的front-matter區域裏添加sticky: 1屬性來把這篇文章置頂。
數值越大，置頂的優先級越大。 
-->
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Q&amp;A:RAM &amp; ROM &amp; Memory</title>
    <url>/post/17d0af8c/</url>
    <content><![CDATA[<h1 id="RAM为什么是随机存储？"><a href="#RAM为什么是随机存储？" class="headerlink" title="RAM为什么是随机存储？"></a>RAM为什么是随机存储？</h1><p>​        <strong>”随机“强调的是存取数据所花的时间与目标数据所在的物理位置无关</strong>。这是由RAM的结构决定的，RAM使用<strong>存储阵列</strong>来存储数据，只要给出<strong>行地址</strong>和<strong>列地址</strong>，就能<strong>确定目标数据</strong>，这一过程<strong>与目标数据所处的物理位置无关</strong>。</p>
<p>​        与“随机存取“相对的，是<strong>“串行访问”</strong>，指<strong>存取数据所花的时间与目标数据所在的物理位置有关</strong>。串行访问里面又分为<strong>顺序存取</strong>和<strong>直接存取</strong>。<strong>顺序存取如磁带</strong>，要想访问一个某一存储单元，<strong>必须先访问该单元前面的单元</strong>，（所以就有了听歌时倒磁带的痛苦经历）。<strong>直接存取如磁盘</strong>，磁头可以直接定位到目标存储单元，<strong>不需访问该单元前面的单元</strong>。需要注意的是，即使是直接定位，定位磁头所花的时间也是不同的，比如磁头当前在磁道0，定位到磁道2和磁道10000的时间肯定不同，所以存取数据所花的时间与目标数所在的物理位置仍然有关。</p>
<h1 id="明明可以往硬盘里写数据，为什么叫ROM呢？"><a href="#明明可以往硬盘里写数据，为什么叫ROM呢？" class="headerlink" title="明明可以往硬盘里写数据，为什么叫ROM呢？"></a>明明可以往硬盘里写数据，为什么叫ROM呢？</h1><p>​        首先，<strong>硬盘 ≠ ROM.</strong></p>
<p>​        在符合冯.诺依曼架构的计算机中，只读储存器ROM是相对于随机存储器RAM而存在的，<strong>所有的预程序从ROM读出存储在RAM上，工作时程序均在RAM中运行</strong>，而不是在ROM上，所以我们叫它只读储存器，<strong>运行在RAM中的数据在断电前会保存在可多次擦写的外储存器上，外储存器才是硬盘</strong>。</p>
<p>​        简而言之，对于计算机而言，从严格意义来讲<strong>ROM是用来存储输入输出系统</strong>，即<strong>BIOS</strong>，而<strong>硬盘叫外储存器，用来存放操作系统软件以及程序与数据</strong>。</p>
<p>​        对于手机而言，设定的Linux内核会<strong>从磁盘中划分一部分储存空间作为ROM区，用于开机时读取到RAM的映像，而ROM区域和程序以及数据存储区域共用一个介质</strong>，所以厂家为了简单宣传，会把整个ROM大小作为外储存器大小去宣传，但这个和PC是有一定区别的。</p>
<p>​        所以，<strong>这也从结构上顺便解释了为什么安卓手机抑或Linux系统不容易中毒的原因，因为系统作为ROM中的单纯映像，不授权的话是无法写入的</strong>，而Windows在外储存器以软件形式存在，且分界不明显，同时使用微内核结构桥接比较多，虽然方便更改系统配置但是对不熟悉者安全度低。</p>
<h1 id="EEPROM是一种“只读存储器”，为什么要对其进行写操作？"><a href="#EEPROM是一种“只读存储器”，为什么要对其进行写操作？" class="headerlink" title="EEPROM是一种“只读存储器”，为什么要对其进行写操作？"></a>EEPROM是一种“只读存储器”，为什么要对其进行写操作？</h1><p>EEPROM的首字母缩写具有随着技术的发展而发展的历史。</p>
<p><strong>ROM</strong>：只读存储器。写在工厂。</p>
<p><strong>PROM</strong>：可编程只读存储器，但可由用户编程（一次）。真正的一次性可编程，永远可读的存储器。弄错了，就丢了芯片。</p>
<p><strong>EPROM</strong>：可擦可编程只读存储器。可以写入多次，擦出需要使用紫外线照射。有点麻烦，但非常有用。</p>
<p><strong>EEPROM</strong>：电可擦可编程只读存储器。可以写入多次，通过编程电压进行修改。</p>
<p><img src="/post/17d0af8c/FWasd.jpg" alt="1"></p>
<p><em>图1. Intel 1702A EPROM，最早的EPROM类型之一，256 x 8位。石英小玻璃窗可吸收紫外线。资料来源：Wikipedia <a href="https://en.wikipedia.org/wiki/EPROM">EPROM</a>。</em></p>
<p>​        所以，为什么在可写时将其称为eepROm？我怀疑，答案是，与<strong>RAM</strong>（随机存取存储器）不同，它在电源关闭时会保存其内容，因此，其行为更像<strong>ROM</strong>。</p>
<p>​        后来推出的<strong>闪存(Flash Memory)</strong>技术，它是一种广义上的EEPROM，手机上的eMMC和UFS都属于闪存技术，因此闪存也被人们称为ROM。</p>
<h1 id="「内存」这个名字误导性太强，为什么没有一个更精准上口的叫法？"><a href="#「内存」这个名字误导性太强，为什么没有一个更精准上口的叫法？" class="headerlink" title="「内存」这个名字误导性太强，为什么没有一个更精准上口的叫法？"></a>「内存」这个名字误导性太强，为什么没有一个更精准上口的叫法？</h1><p>​        在计算机专业领域，“内存”的全称是“内部储存器”，用于在运行时储存信息，CPU可以直接寻址，区别于永久保存数据、CPU仅通过硬件控制器读取数据的“外部储存器”。<strong>这两者是从计算机架构的角度说的</strong>。在通常语境下，“内存”只有主板上插的内存条一种，<strong>内存就成了“主板上的RAM”的代称</strong>。</p>
<p>​        RAM是Random Access Memory，随机访问储存器，特点是断电失效，可以直接通过电流刷新数据。现在一般只有内存条（DRAM）和CPU缓存（SRAM）使用这类芯片。</p>
<p>​        对应的ROM是Read-Only Memory，只读储存器，最开始的ROM真的是只读，不可写入，包括半导体ROM和CD-ROM，后来出现了紫外线擦除的EPROM，电擦除的EEPROM。</p>
<p>​        <strong>RAM和ROM是从技术实现的角度说的</strong>。</p>
<p>​        U盘、固态硬盘、手机固件使用的闪存芯片也是一种EEPROM，它依然是先擦除再写入，和RAM有原理上的区别。所以<strong>手机广告上的2G RAM + 16G ROM是正确的用法</strong>。（不要纠结flash到底是不是EEPROM了，它确实符合EEPROM定义，写入是通过电擦除-再写入实现的，不过EEPROM一般专指可以按字节擦除的那种，flash是按块擦除）</p>
<p>​        智能手机的组成和电脑一样，所以<strong>依据部件功能继承了电脑的称呼</strong>。不过硬盘换成了闪存芯片，所以手机里履行硬盘职能的部件可以被称作“闪存”。</p>
<p>​        内存和ROM混淆<strong>我认为</strong>来自于安卓系统（或者更早的塞班，我没用过），安卓文件管理器把手机空间分为“内部储存”和“SD卡”，这里的“内部储存”指的是ROM，但是也简称为“内存”。为了和这个“内存”做区别，RAM就变成了运行内存，“运存”。</p>
<p>所以对应关系如下：<br><strong>电脑：内存－硬盘</strong><br><strong>手机：RAM－ROM</strong><br>　　　<strong>内存－闪存</strong><br>　　　<strong>运存－内存</strong></p>
<p>​        至于把手机的“内存”又迁移回电脑上，指代硬盘，只能说误会久矣…</p>
]]></content>
      <categories>
        <category>内存布局</category>
      </categories>
      <tags>
        <tag>RAM</tag>
        <tag>ROM</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetis C1-布尔逻辑</title>
    <url>/post/5b231705/</url>
    <content><![CDATA[<h1 id="布尔逻辑-Boolean-Logic"><a href="#布尔逻辑-Boolean-Logic" class="headerlink" title="[布尔逻辑 Boolean Logic]"></a>[布尔逻辑 Boolean Logic]</h1><p><strong>And/Or/Not</strong>算子都可以只用<strong>Nand</strong>或<strong>Nor</strong>函数来构建（可以单纯用Nand也可以单纯用Nor）</p>
<p><code>Nand</code>: 只有1-1为0，其他情况(0-0, 0-1, 1-0)均为1（Not And）</p>
<p><code>Nor</code>:   只有0-0为1，其他情况(0-1, 1-0, 1-1)均为0（Not Or）</p>
<a id="more"></a>
<p>eg: <code>x Or y</code> = <code>(x Nand x) Nand (y Nand y)</code></p>
<p>Or 和 And:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>x</th>
<th>0           0           1           1</th>
</tr>
</thead>
<tbody>
<tr>
<td>—————</td>
<td><strong>y</strong></td>
<td><strong>0           1           0           1</strong></td>
</tr>
<tr>
<td><code>(x Nand x) Nand (y Nand y)</code></td>
<td>Or</td>
<td>1           1           1           0</td>
</tr>
<tr>
<td><code>(x Nand y) Nand (x Nand y)</code></td>
<td>And</td>
<td>0           0           0           1</td>
</tr>
</tbody>
</table>
</div>
<p> Not:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>x</th>
<th>0           1</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(x Nand x)</code></td>
<td>Not</td>
<td>1           0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>既然每个布尔函数(P10)都能通过规范表示法由And、Or和Not构成，那么每个布尔函数也能仅使用Nand函数来构成</strong></p>
<p>Nand -&gt; (And、Or和Not) -&gt; (任意的布尔函数)：一生三，三生万物。</p>
<p>实际意义：一旦在物理上实现了Nand、功能，就可以使用很多这样的物理设备，通过 特定的连接方式（Function）来构建任何布尔函数的硬件实现。</p>
<p><strong>求解formula的方法：</strong></p>
<ol>
<li><p>Boolean Expression.布尔表达式</p>
</li>
<li><p>Truth Table.真值表</p>
<p>构造出满足取值为<code>1</code>的布尔表达式，通过<code>OR</code>连接所有的表达式</p>
</li>
</ol>
<h3 id="HDL实现基本门"><a href="#HDL实现基本门" class="headerlink" title="[HDL实现基本门]"></a>[HDL实现基本门]</h3><p>HDL: Hardware Description Language.</p>
<script type="math/tex; mode=display">\overline{x·x}=(x \ Nand \ x)</script><p><strong>Not:</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>in</th>
<th>0           1</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(in Nand true)</code></td>
<td>Not</td>
<td>1           0</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
out~=~\overline{in·true}</script><p><strong>Or / And / Xor:</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>x</th>
<th>0           0           1           1</th>
</tr>
</thead>
<tbody>
<tr>
<td>—————</td>
<td><strong>y</strong></td>
<td><strong>0           1           0           1</strong></td>
</tr>
<tr>
<td><code>(x Nand true) Nand (y Nand true)</code></td>
<td>Or</td>
<td>0           1           1           1</td>
</tr>
<tr>
<td><code>(x Nand y) Nand true</code></td>
<td>And</td>
<td>0           0           0           1</td>
</tr>
<tr>
<td><strong>—————————————————————</strong></td>
<td><strong>—</strong></td>
<td><strong>———————————</strong></td>
</tr>
<tr>
<td><code>Or( And(Not(x), y), And(x, Not(y)) )</code></td>
<td>Xor</td>
<td>0           1           1           0</td>
</tr>
</tbody>
</table>
</div>
<p><strong> Or:</strong>  </p>
<script type="math/tex; mode=display">
out~=~\overline{\overline{x}·\overline{y}}</script><p><strong> And:</strong> </p>
<script type="math/tex; mode=display">
out~=~\overline{\overline{x·y}·true}</script><p><strong> Xor:</strong> </p>
<script type="math/tex; mode=display">
out~=~\overline{x}·y~+~x·\overline{y}</script><h3 id="逻辑门"><a href="#逻辑门" class="headerlink" title="[逻辑门]"></a>[逻辑门]</h3><p><strong>Multiplexor:</strong> （多路复用，<strong>多路输入</strong>根据<strong>选择位</strong>进行选择性<strong>单路输出</strong>）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>x</th>
<th>0           0           1           1</th>
</tr>
</thead>
<tbody>
<tr>
<td>—————</td>
<td><strong>y</strong></td>
<td><strong>0           1           0           1</strong></td>
</tr>
<tr>
<td>—————</td>
<td><strong>sel</strong></td>
<td><strong>0           1</strong></td>
</tr>
<tr>
<td><code>Or(And(x, Not(sel)), And(b, sel) )</code></td>
<td>Multiplexor</td>
<td>8种可能[ 4 * (2-sel) ]</td>
</tr>
<tr>
<td><code>Not(sel)</code></td>
<td>—————</td>
<td>控制x, y运算结果不相同</td>
</tr>
<tr>
<td><code>And(x, Not(sel))</code></td>
<td>—————</td>
<td>控制sel = 0时输出x, 且只有1-1时out = 1</td>
</tr>
<tr>
<td><code>And(y, sel)</code></td>
<td>—————</td>
<td>控制sel = 1时输出y, 且只有1-1时out = 1</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
out~=~x·\overline{sel} + y·sel</script><p><strong>Demultiplexor:</strong> （解复用，将<strong>单路输入</strong>根据<strong>选择位</strong>划分为<strong>多路输出</strong>）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>in</th>
<th>0           0           1           1</th>
</tr>
</thead>
<tbody>
<tr>
<td>—————</td>
<td><strong>sel</strong></td>
<td><strong>0           1</strong></td>
</tr>
<tr>
<td><code>And(in, Not(sel)), And(in, sel)</code></td>
<td>Demultiplexor</td>
<td>4种可能</td>
</tr>
</tbody>
</table>
</div>
<p>4种可能: </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>in</th>
<th>sel</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
a~=~in·\overline{sel},~b~=~in·sel</script><h3 id="多位逻辑门"><a href="#多位逻辑门" class="headerlink" title="[多位逻辑门]"></a>[多位逻辑门]</h3><p><strong>Mux16:</strong> </p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Mux(a=a[<span class="number">1</span>], b=b[<span class="number">1</span>], sel=sel, out=out[<span class="number">1</span>]); </span><br><span class="line">…… </span><br><span class="line">Mux(a=a[<span class="number">15</span>], b=b[<span class="number">15</span>], sel=sel, out=out[<span class="number">15</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="多位多通道逻辑门"><a href="#多位多通道逻辑门" class="headerlink" title="[多位多通道逻辑门]"></a>[多位多通道逻辑门]</h3><p><code>m</code>个<code>n</code>位输入变量中选择一个并从其中单一的<code>n</code>位输出到 总线输出 上。</p>
<p>k个控制位指定选择，<code>k = log₂m</code></p>
<p><strong>Mux4way16:</strong> （选择输入以输出）</p>
<p><code>m = 4, n = 16, k = 2</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">IN a[<span class="number">16</span>], b[<span class="number">16</span>], c[<span class="number">16</span>], d[<span class="number">16</span>], sel[<span class="number">2</span>];</span><br><span class="line">OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">PARTS:<span class="type"></span></span><br><span class="line"><span class="type">Mux16</span>(a=a, b=b, sel=sel[<span class="number">0</span>], out=e);</span><br><span class="line">Mux16(a=c, b=d, sel=sel[<span class="number">0</span>], out=f);</span><br><span class="line">Mux16(a=e, b=f, sel=sel[<span class="number">1</span>], out=out);</span><br></pre></td></tr></table></figure>
<p><strong>Mux8way16:</strong> </p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">IN a[<span class="number">16</span>], b[<span class="number">16</span>], c[<span class="number">16</span>], d[<span class="number">16</span>],</span><br><span class="line">   e[<span class="number">16</span>], f[<span class="number">16</span>], g[<span class="number">16</span>], h[<span class="number">16</span>],</span><br><span class="line">   sel[<span class="number">3</span>];</span><br><span class="line">OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">PARTS:<span class="type"></span></span><br><span class="line"><span class="type"></span>// array cells [<span class="number">0.</span>.n]</span><br><span class="line">Mux4Way16(a=a, b=b, c=c, d=d, sel=sel[<span class="number">0.</span><span class="number">.1</span>], out=x1);</span><br><span class="line">Mux4Way16(a=e, b=f, c=g, d=h, sel=sel[<span class="number">0.</span><span class="number">.1</span>], out=x2);</span><br><span class="line">Mux16(a=x1, b=x2, sel=sel[<span class="number">2</span>], out=out);</span><br></pre></td></tr></table></figure>
<p><strong>DMux4Way</strong>：（选择通道以输出）</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">IN <span class="keyword">in</span>, sel[<span class="number">2</span>];</span><br><span class="line">OUT a, b, c, d;</span><br><span class="line"></span><br><span class="line">PART:<span class="type"></span></span><br><span class="line"><span class="type">Not</span>(<span class="keyword">in</span>=sel[<span class="number">0</span>], out=sel00);</span><br><span class="line">Not(<span class="keyword">in</span>=sel[<span class="number">1</span>], out=sel10);</span><br><span class="line"></span><br><span class="line">And(a=<span class="keyword">in</span>, b=sel10, out=a1);</span><br><span class="line">And(a=a1, b=sel00, out=a);</span><br><span class="line"></span><br><span class="line">And(a=<span class="keyword">in</span>, b=sel10, out=b1);</span><br><span class="line">And(a=b1, b=sel[<span class="number">0</span>], out=b);</span><br><span class="line"></span><br><span class="line">And(a=<span class="keyword">in</span>, b=sel[<span class="number">1</span>], out=c1);</span><br><span class="line">And(a=c1, b=sel00, out=c);</span><br><span class="line"></span><br><span class="line">And(a=<span class="keyword">in</span>, b=sel[<span class="number">0</span>], out=d1);</span><br><span class="line">And(a=d1, b=sel[<span class="number">1</span>], out=d);</span><br></pre></td></tr></table></figure>
<p><strong>DMux8Way:</strong> </p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">IN <span class="keyword">in</span>, sel[<span class="number">3</span>];</span><br><span class="line">OUT a, b, c, d, e, f, g, h;</span><br><span class="line"></span><br><span class="line">PARTS:<span class="type"></span></span><br><span class="line"><span class="type">DMux4Way</span>(<span class="keyword">in</span> = <span class="keyword">in</span>, sel = sel[<span class="number">1.</span><span class="number">.2</span>], a = o1, b = o2, c = o3, d = o4);</span><br><span class="line">DMux(<span class="keyword">in</span> = o1, sel = sel[<span class="number">0</span>], a = a, b = b);</span><br><span class="line">DMux(<span class="keyword">in</span> = o2, sel = sel[<span class="number">0</span>], a = c, b = d);</span><br><span class="line">DMux(<span class="keyword">in</span> = o3, sel = sel[<span class="number">0</span>], a = e, b = f);</span><br><span class="line">DMux(<span class="keyword">in</span> = o4, sel = sel[<span class="number">0</span>], a = g, b = h);</span><br></pre></td></tr></table></figure>
<p>DMux和Mux的区别与关联：</p>
<p><img src="/post/5b231705/v2-bb3f9b6f59a92fd0ede6b40bfb72332b_720w.jpg" alt="DMux &amp; Mux"></p>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
        <tag>HDL</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetis C2-布尔算法</title>
    <url>/post/e4fb99f5/</url>
    <content><![CDATA[<h1 id="布尔算法运算-Boolean-Arithmetic"><a href="#布尔算法运算-Boolean-Arithmetic" class="headerlink" title="[布尔算法运算 Boolean Arithmetic]"></a>[布尔算法运算 Boolean Arithmetic]</h1><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><p>两个<code>n-</code>位数字二进制加法的计算机硬件可以由三位加法的逻辑门构建而成。（两个计算位加上一个进位）</p>
<p><strong>在4-位二进制系统中的有符号数的2-补码表示</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>正数</th>
<th>负数</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 – 0000</td>
<td></td>
</tr>
<tr>
<td>1 – 0001</td>
<td>1111 – (-1)</td>
</tr>
<tr>
<td>2 – 0010</td>
<td>1110 – (-2)</td>
</tr>
<tr>
<td>3 – 0011</td>
<td>1101 – (-3)</td>
</tr>
<tr>
<td>4 – 0100</td>
<td>1100 – (-4)</td>
</tr>
<tr>
<td>5 – 0101</td>
<td>1011 – (-5)</td>
</tr>
<tr>
<td>6 – 0110</td>
<td>1010 – (-6)</td>
</tr>
<tr>
<td>7 – 0111</td>
<td>1001 – (-7)</td>
</tr>
<tr>
<td></td>
<td>1000 – (-8)</td>
</tr>
</tbody>
</table>
</div>
<p>计算<code>-x</code>原理：</p>
<script type="math/tex; mode=display">
2^n-x = 1 + (2^n-1)-x</script><p>由此可知，用补码表示<code>n-</code>位二进制系统有如下属性：</p>
<ul>
<li>系统能对所有<strong>2^n^</strong>个有符号数进行编码，最大的数(0111)和最小的数(1000)分别为<strong>(2^n-1^-1)</strong>和<strong>(-2^n-1^)</strong>.</li>
<li>所有正整数的编码的首位是0.</li>
<li>所有负整数的编码的首位是1.</li>
<li><em>为了通过<code>x</code>的编码获得<code>-x</code>的编码，所有最右边的0和从左边起的第一个1保持不变，然后将剩余的位取反。</em>等价的捷径就是，<strong>对<code>x</code>的所有的位取反，然后加上1，这个方案更容易在硬件中实现.</strong></li>
</ul>
<p>这种表示法有个特别吸引人的特征：<strong>任何两个用补码表示的有符号数的加法和与正数的加法完全相同</strong>。</p>
<p>eg: </p>
<p>1.加法(-2) + (-3)</p>
<p>使用补码(<code>4-</code>位)表示：(1110)₂ + (1101)₂  = (1011)₂  ，(丢掉溢出位)</p>
<p>正好是-5的补码.</p>
<p><strong>我们不用去关心这些代码表示的数字（正数还是负数）</strong></p>
<p>2.减法可以看成<code>x - y = x + (-y)</code>，补码表示中，计算<code>-y</code>：所有位取反再加1</p>
<p><strong>以上意味着能用单一芯片（成为算术逻辑单元ALU，ALU即<code>Arithmetic Logical Unit</code>）将硬件执行的所有基本算术操作和逻辑操作封装起来</strong>.</p>
<h3 id="规范详述"><a href="#规范详述" class="headerlink" title="[规范详述]"></a>[规范详述]</h3><ol>
<li>加法器(Adders)<ul>
<li><strong>半加器</strong>(Half-Adders)</li>
<li><strong>全加器</strong>(Full-Adders)</li>
<li><strong>加法器</strong>(Adders)</li>
</ul>
</li>
</ol>
<ul>
<li><strong>半加器</strong>(Half-Adders)：用来进行<code>2-</code>位二进制数的加法.</li>
</ul>
<p><img src="/post/e4fb99f5/image-20200816222258242.png" alt="image-20200816222258242" style="zoom:80%;"></p>
<ul>
<li><strong>全加器</strong>(Full-Adders)：用来进行<code>3-</code>位二进制数加法.  </li>
</ul>
<p><img src="/post/e4fb99f5/image-20200816223202065.png" alt="image-20200816223202065" style="zoom:80%;"></p>
<ul>
<li><strong>加法器</strong>(Adders)：用来进行两个<code>n-</code>位加法.(图为16位)</li>
</ul>
<p><img src="/post/e4fb99f5/image-20200816222654606.png" alt="image-20200816222654606" style="zoom:80%;"></p>
<ul>
<li><strong>增量器</strong>(incrementer)：用来对指定的数字加1.</li>
</ul>
<p><img src="/post/e4fb99f5/image-20200816223012624.png" alt="image-20200816223012624" style="zoom:80%;"></p>
<h3 id="算术逻辑单元-ALU"><a href="#算术逻辑单元-ALU" class="headerlink" title="算术逻辑单元(ALU)"></a>算术逻辑单元(ALU)</h3><p><img src="/post/e4fb99f5/image-20200817143329826.png" alt="image-20200817143329826" style="zoom:80%;"></p>
<p>Hack的ALU计算一组固定的函数<code>out = f(x, y)</code>，这里<code>x</code>和<code>y</code>是芯片的两个<code>16-</code>位输入，<code>out</code>是芯片的<code>16-</code>位输出，该函数表由18个固定函数组成，通过设置六个称为控制位(control bits)的输入位来告诉ALU用哪一个函数来进行何种函数计算。</p>
<p>ALU可以对2^6^=64个不同的函数进行操作。</p>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
        <tag>HDL</tag>
        <tag>ALU</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetis C3-时序逻辑</title>
    <url>/post/778f3b2f/</url>
    <content><![CDATA[<h1 id="时序逻辑-Sequential-Logic"><a href="#时序逻辑-Sequential-Logic" class="headerlink" title="[时序逻辑 Sequential Logic]"></a>[时序逻辑 Sequential Logic]</h1><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><p><strong>时钟(Clock)</strong>: 计算机里时间的流逝是用主时针(master clock)来表示的，它提供连续的<strong>交变信号序列</strong>。硬件实现通常基于<strong>振荡器(oscillator)</strong>，其在两个信号值<strong>0-1</strong>，或称<strong>“低电平-高电平(low-high, tick-tock)”</strong>之间交替变化。两个相邻的上升沿之间的时间间隙称为时钟的<strong>周期(cycle)</strong>，每个时钟周期模塑一个<strong>离散的时间单元</strong>。通过硬件电路，这个信号同时被传送到计算机平台的每个时序芯片中。</p>
<p><strong>触发器(Flip-Flops)</strong>: 本书使用<strong>数据触发器(Data Flip-Flop, DFF或称D触发器)</strong>。实现基于时间的行为：</p>
<script type="math/tex; mode=display">
out(t) = in(t - 1)</script><p>t是当前时钟周期。换而言之，DFF能够简单的实现将前一个时间周期的输入值作为当前周期的输出值。</p>
<p><code>out(t) = in(t - 1)</code>是所有计算机硬件维持自身状态的基础，二进制单元 -&gt; 寄存器 -&gt; 任意大的随机存取记忆单元(RAM) 都是如此.</p>
<p><strong>寄存器(Registers)</strong>: 能够“储存”某一时刻的值，实现经典的存储行为：</p>
<script type="math/tex; mode=display">
out(t) = out(t - 1)</script><p>从另一个方面来说，DFF仅能够输出它前一时钟周期的输出，也就是<code>out(t) = in(t - 1)</code>。这提示了我们，可以通过DFF来实现寄存器，只需将后面的输出反馈到它的输入就可以了。</p>
<p><img src="/post/778f3b2f/image-20200818162126362.png" alt="image-20200818162126362" style="zoom:80%;"></p>
<p>如此一来，在任何时刻<code>t</code>，这个设备的输出都会重现它在时刻<code>t-1</code>的值。</p>
<p>如图3.1右，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">load = 1, out(t) = in(t-1),  相当于wirte操作, 希望开始存储新值, 把值置于in输入口;</span><br><span class="line">load = 0, out(t) = out(t-1), 相当于read操作, 希望一直存储它的内部值直到新的指令到来</span><br></pre></td></tr></table></figure>
<p><img src="/post/778f3b2f/image-20200818163142204.png" alt="image-20200818163142204" style="zoom:80%;"></p>
<p><strong>内存(Memories)</strong>: …… 随机存取内存(RAM, Random Acess Memory): 在RAM上能够随机访问被选择的字而不会受限于访问顺序。</p>
<p><img src="/post/778f3b2f/image-20200818163246416.png" alt="image-20200818163246416" style="zoom:80%;"></p>
<p><strong>计数器(Counter)</strong>: 每经过一个时间周期计数器就增加1个单位，执行函数<code>out(t) = out(t-1) + c</code>，这里<code>c</code>就是1.</p>
<h3 id="时间问题"><a href="#时间问题" class="headerlink" title="[时间问题]"></a>[时间问题]</h3><p>至此本章介绍的芯片都是时序芯片(sequential chip)。简单来说，时序芯片就是直接或间接地嵌入一个或多个DFF门的芯片。</p>
<p>反馈回路：输出依赖于输入，而输入本身有依赖于输出，因此输出只依赖自身。</p>
<p><img src="/post/778f3b2f/image-20200818171444271.png" alt="image-20200818171444271" style="zoom:80%;"></p>
<p>……………………….</p>
<h3 id="规范详述"><a href="#规范详述" class="headerlink" title="[规范详述]"></a>[规范详述]</h3><ul>
<li><p>D触发器(DFFs)</p>
</li>
<li><p>寄存器 (基于DFFs)</p>
</li>
<li><p>存储块 (基于寄存器)</p>
</li>
<li><p>计数器芯片 (基于寄存器)</p>
<p>太多细节，几乎都是必看的，避免抄书……</p>
</li>
</ul>
<h3 id="实现硬件"><a href="#实现硬件" class="headerlink" title="[实现硬件]"></a>[实现硬件]</h3><p><strong>1Bit寄存器</strong>：</p>
<ul>
<li>If load[t] == 1 then out[t+1] = in[t]<ul>
<li>else out does not change (out[t+1] = out[t])</li>
</ul>
</li>
</ul>
<p><img src="/post/778f3b2f/image-20200822231745454.png" alt="image-20200822231745454"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">CHIP Bit &#123;</span><br><span class="line">    IN <span class="keyword">in</span>, load;</span><br><span class="line">    OUT out;</span><br><span class="line"></span><br><span class="line">    PARTS:<span class="type"></span></span><br><span class="line"><span class="type">    </span>// lastOut is equal to the last time out, Assigned by DFF<span class="string">&#x27;s lastOut</span></span><br><span class="line"><span class="string">    Mux(a=lastOut, b=in, sel=load, out=muxOut);</span></span><br><span class="line"><span class="string">    // cause the out is distinct(Only use once), so we can add out to copy the out</span></span><br><span class="line"><span class="string">    DFF(in=muxOut, out=lastOut, out=out);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>n-Bits寄存器</strong>：</p>
<p>n个<strong>1Bit寄存器</strong>串联 和 <code>log(2)n</code>的address选择寄存器进行读写（取址执行的基础 ）。</p>
<p><strong>n-Bits RAM(Random Access Memory)</strong>：</p>
<p><img src="/post/778f3b2f/image-20200822234706201.png" alt="image-20200822234706201"></p>
<p>address用于寻址：根据<code>address = i</code>找出需要载入的<strong>1Bit寄存器</strong>，此时该寄存器设置<code>load = 1，in = M</code>，并在下一个时间周期<code>out = M</code>，实现<code>out(t) = in(t-1)</code></p>
<p><img src="/post/778f3b2f/image-20200822235721818.png" alt="image-20200822235721818"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 16-bit register:</span></span><br><span class="line">CHIP Register &#123;</span><br><span class="line">    IN <span class="keyword">in</span>[<span class="number">16</span>], load;</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:<span class="type"></span></span><br><span class="line"><span class="type">    </span>// No Mux16, because DFF only accept <span class="number">1</span> bit input &amp; output.</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">0</span>], load=load, out=out[<span class="number">0</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">1</span>], load=load, out=out[<span class="number">1</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">2</span>], load=load, out=out[<span class="number">2</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">3</span>], load=load, out=out[<span class="number">3</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">4</span>], load=load, out=out[<span class="number">4</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">5</span>], load=load, out=out[<span class="number">5</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">6</span>], load=load, out=out[<span class="number">6</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">7</span>], load=load, out=out[<span class="number">7</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">8</span>], load=load, out=out[<span class="number">8</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">9</span>], load=load, out=out[<span class="number">9</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">10</span>], load=load, out=out[<span class="number">10</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">11</span>], load=load, out=out[<span class="number">11</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">12</span>], load=load, out=out[<span class="number">12</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">13</span>], load=load, out=out[<span class="number">13</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">14</span>], load=load, out=out[<span class="number">14</span>]);</span><br><span class="line">    Bit(<span class="keyword">in</span>=<span class="keyword">in</span>[<span class="number">15</span>], load=load, out=out[<span class="number">15</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Memory of 8 registers, each 16 bit-wide.</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">CHIP RAM8 &#123;</span><br><span class="line">    IN <span class="keyword">in</span>[<span class="number">16</span>], load, address[<span class="number">3</span>];</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:<span class="type"></span></span><br><span class="line"><span class="type">    </span>// <span class="keyword">in</span> accordance with address, locate which register to load</span><br><span class="line">    DMux8Way(<span class="keyword">in</span>=<span class="keyword">in</span>, sel=address, a=in0, b=in1, c=in2, d=in3, e=in4, f=in5, g=in6, h=in7);</span><br><span class="line"></span><br><span class="line">    Register(<span class="keyword">in</span>=in0, load=load, out=out0);</span><br><span class="line">    Register(<span class="keyword">in</span>=in1, load=load, out=out1);</span><br><span class="line">    Register(<span class="keyword">in</span>=in2, load=load, out=out2);</span><br><span class="line">    Register(<span class="keyword">in</span>=in3, load=load, out=out3);</span><br><span class="line">    Register(<span class="keyword">in</span>=in4, load=load, out=out4);</span><br><span class="line">    Register(<span class="keyword">in</span>=in5, load=load, out=out5);</span><br><span class="line">    Register(<span class="keyword">in</span>=in6, load=load, out=out6);</span><br><span class="line">    Register(<span class="keyword">in</span>=in7, load=load, out=out7);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// in accordance with address, decide which register should output</span></span><br><span class="line">    Mux8Way16(a=out0, b=out1, c=out2, d=out3, e=out4, f=out5, g=out6, h=out7, sel=address, out=out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Couters</strong></p>
<p>三个基本功能：</p>
<ul>
<li>重置计数器</li>
<li>计数器自增</li>
<li>为计数器赋值</li>
</ul>
<p><img src="/post/778f3b2f/image-20200823000717282.png" alt="image-20200823000717282"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">CHIP PC &#123;</span><br><span class="line">    IN <span class="keyword">in</span>[<span class="number">16</span>],load,inc,reset;</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:<span class="type"></span></span><br><span class="line"><span class="type">    </span>// Order cant change</span><br><span class="line">    <span class="comment">// inc</span></span><br><span class="line">    Mux16(a=lastOut, b=incOut, sel=inc, out=out1);</span><br><span class="line">    <span class="comment">// laod</span></span><br><span class="line">    Mux16(a=out1, b=<span class="keyword">in</span>, sel=load, out=out2);</span><br><span class="line">    <span class="comment">// reset</span></span><br><span class="line">    Mux16(a=out2, b=<span class="literal">false</span>, sel=reset, out=out3);</span><br><span class="line"></span><br><span class="line">    Register(<span class="keyword">in</span>=out3, load=<span class="literal">true</span>, out=lastOut, out=out);</span><br><span class="line">    Inc16(<span class="keyword">in</span>=lastOut, out=incOut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>RAM</tag>
        <tag>nand2tetris</tag>
        <tag>HDL</tag>
        <tag>Register</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetis C8-虚拟机Ⅱ程序控制</title>
    <url>/post/35e94e02/</url>
    <content><![CDATA[<h1 id="虚拟机Ⅱ-程序控制-Program-Control"><a href="#虚拟机Ⅱ-程序控制-Program-Control" class="headerlink" title="[虚拟机Ⅱ: 程序控制 Program Control]"></a>[虚拟机Ⅱ: 程序控制 Program Control]</h1><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><p>上一章介绍9个算术指令、逻辑指令以及内存访问指令(push/pop segment<8> index)是如何利用基本<strong>栈式机(stack machine)</strong>操作来进行计算的。本章将在上章基础上描述<strong>程序控制流(program flow)命令</strong>和<strong>子程序调用(subroutine calling)命令</strong>是如何在<strong>栈式机</strong>实现的。</8></p>
<p>对于在运行期的每个<strong>子程序调用</strong>，底层必须处理下面的一些细节。可以利用<strong>栈式机</strong>来方便的完成，事实上<strong>栈式结构</strong>本身的优势就在于处理类似的问题。</p>
<ul>
<li>将参数从调用者(caller)传递给被调用者(called subroutine)。（参数传递）</li>
<li>在跳转并执行被调用者之前，先保存调用者的状态。（现场保护）</li>
<li>为被调用者使用的局部变量分配内存空间。（内存分配）</li>
<li>跳转并执行被调用者。（子程序执行）</li>
<li>将被调用者的运行结果返回给调用者。（参数传递）</li>
<li>在从被调用者返回之前，回收其使用的内存空空间。（回收调用空间）</li>
<li>恢复调用者的状态。（恢复现场）</li>
<li>返回到调用语句之后的下一条语句继续执行。</li>
</ul>
<h3 id="程序控制流"><a href="#程序控制流" class="headerlink" title="[程序控制流]"></a>[程序控制流]</h3><p>​        主要有两种，<strong>无条件跳转</strong>和<strong>有条件跳转</strong>，这部分是很容易实现的。上一章VM的原始操作是如何计算任意给定的布尔表达式，并将其结果置于栈顶的。这种表达式与<code>goto</code>和<code>if-goto</code>命令相结合，就可以表示任何编程语言中的任何控制结构的流程。</p>
<p><img src="/post/35e94e02/image-20200926193155407.png" alt="程序控制流的实现"></p>
<h3 id="子程序调用"><a href="#子程序调用" class="headerlink" title="[子程序调用]"></a>[子程序调用]</h3><p>​        子程序调用主要包含两种，调用内置指令和调用用户自己定义的子程序。调用内置指令，比如：<code>add</code>，<code>sub</code>等，在第7章都已经实现。调用用户自己定义的子程序与调用内置指令的区别在于需要使用关键字<code>call</code>。</p>
<p><img src="/post/35e94e02/image-20200926200604522.png" alt="子程序调用流程" style="zoom:67%;"></p>
<p><img src="/post/35e94e02/image-20200926200701237.png" alt="子程序流程2"></p>
<h4 id="如何实现嵌套调用和递归调用的内存管理机制？"><a href="#如何实现嵌套调用和递归调用的内存管理机制？" class="headerlink" title="如何实现嵌套调用和递归调用的内存管理机制？"></a>如何实现嵌套调用和递归调用的内存管理机制？</h4><p>​        主程序会调用子程序，子程序还会调用子程序，子程序也会调用子程序自身，这就形成了<strong>嵌套调用</strong>和<strong>递归调用</strong>。<br>​        这里要介绍一个概念：<strong>帧</strong>，它表示<strong>子程序的局部变量的集合</strong>。在这一章中，栈是指全局栈结构，它<strong>包括所有子程序的帧组成的栈</strong>，包含了第7章中介绍的栈结构，但又大于之前的栈结构。</p>
<h4 id="函数调用协议-规范"><a href="#函数调用协议-规范" class="headerlink" title="函数调用协议(规范)"></a>函数调用协议(规范)</h4><p><img src="/post/35e94e02/image-20200926214313405.png" alt="函数调用协议(规范)"></p>
<ul>
<li>虽然子程序调用链可以具有任意深度，可以有任意的递归，但是<strong>在任何时刻，只有调用链顶部的子程序才能被执行</strong>，而处于调用链中其他子程序将一直等待到该子程序执行完毕才能继续执行。子程序调用的实现过程中，这种<strong>后进先出</strong>的处理方式和<strong>栈区</strong>数据结构的操作方式吻合。</li>
</ul>
<p><img src="/post/35e94e02/image-20200924203308549.png" alt="后进先出" style="zoom:67%;"></p>
<h4 id="✨✨✨函数调用协议的实现"><a href="#✨✨✨函数调用协议的实现" class="headerlink" title="✨✨✨函数调用协议的实现"></a>✨✨✨函数调用协议的实现</h4><ul>
<li>函数调用协议及其对应的全局栈区结构能够通过执行下图中给出的(用Hack汇编代码写出的)伪指令在Hack平台上实现。（CodeWriter的实现部分）</li>
</ul>
<p><img src="/post/35e94e02/image-20200924204022900.png" alt="函数命令的VM实现"></p>
<ul>
<li>下图显示了三个调用相关的栈区状态：</li>
</ul>
<p><img src="/post/35e94e02/image-20200924204140804.png" alt="全局栈区"></p>
<h4 id="Hack平台的RAM标准映射"><a href="#Hack平台的RAM标准映射" class="headerlink" title="Hack平台的RAM标准映射"></a>Hack平台的RAM标准映射</h4><p><img src="/post/35e94e02/image-20200926215722605.png" alt="映射"></p>
<p><img src="/post/35e94e02/image-20200926215830908.png" alt="汇编语言符号"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="[实现]"></a>[实现]</h2><p><em>Parser.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于Chap7，追加实现解析本章新增的6个VM指令</span></span><br></pre></td></tr></table></figure>
<p><em>VMTranslator</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在遍历Parser的数组链表之前增加指示: .asm是否已写入bootstrap程序代码</span></span><br><span class="line"><span class="comment">// 在遍历过程中，若程序并未写入bootstrap，调用函数并置指示为true</span></span><br></pre></td></tr></table></figure>
<p>将VM程序代码翻译成ASM汇编代码</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标签</span></span><br><span class="line">`label LOOP</span><br><span class="line">(LOOP)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无条件跳转</span></span><br><span class="line">`goto LOOP</span><br><span class="line">@LOOP</span><br><span class="line"><span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件跳转</span></span><br><span class="line">`<span class="keyword">if</span>-goto END</span><br><span class="line">@SP</span><br><span class="line">AM=M<span class="number">-1</span></span><br><span class="line">D=M</span><br><span class="line">@END</span><br><span class="line">D;JNE						<span class="comment">// 不相等则跳转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">call functionName numArgs	<span class="comment">// 根据上图8.5(call f n)的VM实现翻译</span></span><br><span class="line">`call mult <span class="number">2</span></span><br><span class="line">@RETURN_ADD_index</span><br><span class="line">D=A</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>CodeWriter</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeWriter</span></span>&#123;</span><br><span class="line">    <span class="comment">// writeLabel(String): 写入label指令的汇编代码</span></span><br><span class="line">    <span class="comment">// eg:label LOOP -&gt; (LOOP)</span></span><br><span class="line">    <span class="comment">// writeGoto(String): 写入goto指令的汇编代码，eg:goto LOOP -&gt; @LOOP,0;jmp</span></span><br><span class="line">    <span class="comment">// writeIf(String): 写入if-goto指令的汇编代码，eg:if-goto</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reference: </p>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
        <tag>VirtualMachine</tag>
        <tag>vm</tag>
      </tags>
  </entry>
  <entry>
    <title>stack&amp;Heap</title>
    <url>/post/e5494597/</url>
    <content><![CDATA[<h1 id="栈（Stack）和堆（Heap）"><a href="#栈（Stack）和堆（Heap）" class="headerlink" title="栈（Stack）和堆（Heap）"></a>栈（Stack）和堆（Heap）</h1><p>​        目前来说我们知道怎么去声明一个基础类型的变量，比如int，float，等等。以及复杂数据类型数组和结构，声明它们的时候C会把这些变量放在栈上。<strong>每个线程都有一个栈，而程序通常只有一个堆</strong>。</p>
<h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>  什么是栈？它是内存中一块特殊的区域，<strong>用于保存在函数中声明的零时变量</strong>（其中也包括<code>main()</code>函数）。栈是LIFO(Last in First Out 后进先出)的数据结构，进出操作是由CPU来管理和优化的。<strong>调用函数时就会使用栈。</strong>每当函数声明了一个变量，该变量就会被<strong>推入(Pushed)</strong>栈中。每当函数退出时，所有的变量都会被函数推出栈，并被<strong>释放掉(Free)</strong>。一旦变量被释放，该内存区域就可以被其他栈变量使用。<br>  使用栈的优势是它会为你管理内存，而不需要你手动去分配或者释放内存。更进一步说，由于CPU可以有效地管理栈内存，所以从栈中读写变量是很快的。<br>  理解栈的关键是需要知道函数什么时候退出，此时栈中所有的变量被推出，因此<strong>栈变量是局部的</strong>（也就是局部变量）。C中经常出现的一个错误就是，在函数返回以后去访问函数内部中栈变量。<br>  如果使用太多的栈空间会导致溢出，比如在使用递归的时候，该函数使用了太多的局部变量在递归过程中就有可能造成<strong>栈溢出</strong>。</p>
<blockquote>
<p>总结</p>
<ul>
<li>栈是LIFO数据结构；</li>
<li>CPU管理内存，而不需要手动去管理。正是因为这个原因从栈中读写变量<strong>很快</strong>的；</li>
<li>栈变量是局部的（也就是局部变量）；</li>
<li>栈的容量会随着函数的Push和Pop变化；</li>
</ul>
</blockquote>
<h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><p>  堆也是内存中一块特定区域，但是CPU并不会自动管理相关的操作，而且它的空间大小会有一定的浮动。在堆上分配内存的时候，在C中使用<code>malloc()</code>和<code>calloc()</code>函数。在不需要堆上这块内存之后，需要使用<code>free()</code>函数释放掉它。<strong>如果不释放的话就会造成内存泄漏</strong>，这块内存就会被闲置。<br>  和栈不同之处在于，<strong>堆内存数据的读写速度会比栈慢</strong>。</p>
<h3 id="栈（Stack）和堆（Heap）的差异"><a href="#栈（Stack）和堆（Heap）的差异" class="headerlink" title="栈（Stack）和堆（Heap）的差异"></a>栈（Stack）和堆（Heap）的差异</h3><h4 id="配置堆栈大小"><a href="#配置堆栈大小" class="headerlink" title="配置堆栈大小"></a>配置堆栈大小</h4><p>  堆的大小在程序启动时分配，数值在不同操作系统中可能有所不同。<br>  在Cocoa中想要修改线程的栈大小的话，可以使用<code>NSThread</code>的实例方法<code>setStackSize:</code>，如果使用POSIX线程技术创建的线程的话，想要设置栈大小的话使用<code>pthread_attr_setstacksize</code>函数。</p>
<blockquote>
<p>⚠️如果要设置栈大小就必须要在创建线程之前完成。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(backgroudMethod:) object:nil];</span><br><span class="line">[thread setStackSize:<span class="number">1024</span>];</span><br><span class="line">[thread start];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 第二种</span></span><br><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"><span class="keyword">pthread_t</span> posix_tread_id;</span><br><span class="line"><span class="keyword">int</span> returnVal;</span><br><span class="line">returnVal = pthread_attr_init(&amp;attr);</span><br><span class="line">returnVal = pthread_attr_setstacksize(&amp;attr, <span class="number">1024</span>);  <span class="comment">// 在创建线程前设置堆栈大小</span></span><br><span class="line"><span class="keyword">char</span> *data;</span><br><span class="line">data = <span class="string">&quot;To ensure that a thread knows what work to do&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> thread_error = pthread_create(&amp;posix_tread_id, &amp;attr, posix_thread_mainroutine, data);</span><br></pre></td></tr></table></figure>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>  栈是和线程相关联的，意思就是说当线程退出时，栈被回收。而堆通常是在启动程序时分配，当程序退出之后被回收。</p>
<h3 id="什么时候使用栈什么时候使用堆"><a href="#什么时候使用栈什么时候使用堆" class="headerlink" title="什么时候使用栈什么时候使用堆"></a>什么时候使用栈什么时候使用堆</h3><ul>
<li>需要申请较大内存空间（比如struct，array之类的），而且需要该变量存在较长时间，就是将该变量放在<strong>堆</strong>中；</li>
<li>如果需要动态修改struct或者array的大小，将该变量放在<strong>堆</strong>上。使用<code>malloc()</code>，<code>calloc()</code>，<code>realloc()</code>和<code>free()</code>等函数来管理内存；</li>
<li>如果使用相对较小的变量，并且只在函数中使用它们，此时该变量就存在于栈上。这样做会更快而且更简单。</li>
</ul>
]]></content>
      <categories>
        <category>内存布局</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetis C5-计算机体系结构</title>
    <url>/post/881a6736/</url>
    <content><![CDATA[<h1 id="计算机体系结构-Computer-Architecture"><a href="#计算机体系结构-Computer-Architecture" class="headerlink" title="[计算机体系结构 Computer Architecture]"></a>[计算机体系结构 Computer Architecture]</h1><p>本章涵盖“硬件”部分中最难啃的内容。将第1~3章构建的所有芯片整合并集成一台通用计算机Hack。</p>
<p>Hack优点：</p>
<ol>
<li>通过前面构建的芯片可以几小时构建完成。</li>
<li>Hack计算机的体系结构足以描述任何数字计算机的关键操作原理和硬件组成。</li>
</ol>
<p><strong>This chapter is more Complicated than previous.</strong></p>
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><h4 id="1-存储程序概念"><a href="#1-存储程序概念" class="headerlink" title="1. 存储程序概念"></a>1. 存储程序概念</h4><p>​        一个由有限硬件组件构成的计算机却可以执行无限的任务队列，其实都是<strong>“存储程序(stored program)”</strong>概念的硕果。计算机基于固定的硬件平台，能够执行固定的指令集。同时，这些指令能够被当成构建模块，组成任意的程序。而且，这些程序的逻辑被存储到计算机的<strong>存储设备(memory)</strong>里，跟数据一样，成为所谓的<strong>“软件(software)”</strong>。</p>
<h4 id="2-冯·诺伊曼结构"><a href="#2-冯·诺伊曼结构" class="headerlink" title="2.冯·诺伊曼结构"></a>2.冯·诺伊曼结构</h4><p>​        存储系统概念最著名的是<strong>通用图灵机(1936)</strong>和<strong>冯·诺伊曼机(1945)</strong>。</p>
<p>​        图灵机描述虚拟的简单计算机的抽象机，主要用来分分析计算机的逻辑结构。相比之下，冯·诺伊曼机是实际应用型的体系结构，是今天所有计算机结构的基础。</p>
<p><img src="/post/881a6736/image-20200830133841248.png" alt="冯·诺伊曼机"></p>
<p>​        冯·诺伊曼体系结构的基础是一个<strong>中央处理单元(CPU, Central Processing Unit)</strong>，它与<strong>记忆设备(memory device)</strong>即<strong>广义的内存</strong>进行交互，负责从<strong>输入设备(input device)</strong>接收数据，向<strong>输出设备(output device)</strong>发送数据。体系结构的核心是存储程序的概念：计算机内存不仅存储着要进行操作的数据，还存储着指示计算机运行的指令。</p>
<p>​        广义的内存代表任何具有存储功能的设备和组件。</p>
<p><img src="/post/881a6736/image-20200901111929066.png" alt="DataBus、AddressBus、ControlBus"></p>
<p>​        Data、Address、Control这三部分的每一段信息都由电线实现，通过一组公共总线。公共电线分别有数据总线、地址总线、控制总线。</p>
<p>​        首先是数据总线和<code>ALU</code>的交互，输入数据进行算术运算或逻辑运算，得出结果再输出到数据总线，然后到<strong>内存(memory)</strong>或<strong>寄存器(registers)</strong>。</p>
<p>​        控制总线。<code>ALU</code>需要知道它每次运行的是什么操作，所以它必须从控制总线中重新获取信息，指定它所要进行的操作类型。通过条件分支或循环条件决定下一个指令是什么？这种控制通过控制位(sel)实现, 所以我们需要从<code>ALU</code>中获取控制信息反馈到控制系统的其他部分。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">————</th>
<th style="text-align:center">CPU中的ALU</th>
<th style="text-align:center">CPU中的Registers</th>
<th style="text-align:center">内存Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据总线</td>
<td style="text-align:center">往<code>ALU</code>输入数据进行算术运算 / 逻辑运算，<code>ALU</code>输出运算结果，再反馈到其它</td>
<td style="text-align:center">读写</td>
<td style="text-align:center">读写</td>
</tr>
<tr>
<td style="text-align:center">地址总线</td>
<td style="text-align:center">————</td>
<td style="text-align:center">间接寻址到RAM或者跳到一个ROM地址</td>
<td style="text-align:center">下图一和图二</td>
</tr>
<tr>
<td style="text-align:center">控制总线</td>
<td style="text-align:center">往<code>ALU</code>输入控制位(sel)决定<code>ALU</code>将要进行的运算操作类型；通过条件分支或循环条件决定下一个指令，获取控制信息反馈到控制系统的其他部分。</td>
<td style="text-align:center">反馈到控制系统的其他部分</td>
<td style="text-align:center">反馈到控制系统的其他部分</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/post/881a6736/image-20200901145605717.png" alt="dataMemory"></p>
<p>​        根据地址得到需要操作的数据块，并对其进行读写操作。</p>
<p><img src="/post/881a6736/image-20200901145738663.png" alt="programMemory"></p>
<p>​        需要将下一个程序指令的地址输入到<strong>程序内存</strong>，因为这是我们使用程序指令的地方，放置地址后，从那里得到指令，也可能是数字。程序内存中的指令告诉系统的其他部分该做什么，所以我们需要从下一个指令中获取信息，也即从程序内存的数据输出，并将其输入到控制总线。</p>
<h4 id="3-内存"><a href="#3-内存" class="headerlink" title="3. 内存"></a>3. 内存</h4><p>​        冯·诺伊曼机的内存中存有两种类型的信息：<strong>数据项(data items)</strong> 和 <strong>程序指令(programing instructioins)</strong>。采用不同方式处理两种信息，并被分别存储到不同的内存区，尽管功能不同，但都以二进制数形式存储在具有通用结构的<strong>随机存取器(RAM)</strong>。一个单独的字（一个数据项或者一条指令）通过它的地址指定。</p>
<ul>
<li>数据内存        高级程序操纵的抽象组件，例如变量、数组和对象。这些数据抽象被翻译成机器语言后，变成一连串的二进制数，存储在数据内存。通过指定的地址进行读写操作。</li>
<li>指令内存        高级指令 如上类似处理，并被存储在指令内存。计算机每一步操作，CPU从指令中取出一个字，对其进行解码，从而执行指定的指令，然后计算下一条将要执行的指令。<ul>
<li>指令内存中的指令格式遵守机器语言的规则。</li>
</ul>
</li>
</ul>
<h4 id="4-中央处理器"><a href="#4-中央处理器" class="headerlink" title="4. 中央处理器"></a>4. 中央处理器</h4><p>​        CPU是计算机体系的核心，负责执行已被加载到指令内存的指令。CPU通过使用三个主要的硬件执行指令：<strong>算术逻辑单元(ALU, Arithmetic-Logic Unit)</strong>，一组<strong>寄存器(registers)</strong>和<strong>控制单元(control unit)</strong>。</p>
<ul>
<li><strong>算术逻辑单元（ALU）</strong>        ALU 负责执行计算机中所有底层的算术操作和逻辑操作。</li>
<li><strong>寄存器（Registers）</strong>          CPU 的设计是为了能够快速地执行简单计算。与运算相关的数据暂存到高速寄存器，远比从内存搬进搬出快得多。</li>
<li><strong>控制单元（Control Unit）</strong> 计算机指令用二进制数表示，通常具有16、32或64位宽。在指令可被执行之前，要对其进行解码，指令包含的信息向不同的硬件（ALU，寄存器，内存）发送信号，指使它们如何执行指令。指令解码过程是通过某些<strong>控制单元</strong>完成的。这些控制单元还负责决定下一条读取和执行哪一条指令。</li>
</ul>
<h4 id="5-寄存器"><a href="#5-寄存器" class="headerlink" title="5. 寄存器"></a>5. 寄存器</h4><p>​        内存访问是很慢的过程。当<code>CPU</code>被指示去取内存中地址<code>j</code>的内容时，会连续发生以下操作：</p>
<p>​            (a)  <code>j</code>从<code>CPU</code>传到<code>RAM</code>;</p>
<p>​            (b)  <code>RAM</code>的<strong>直接访问逻辑(direct-access logic)</strong>选中地址为<code>j</code>的寄存器;</p>
<p>​            (c)  <code>RAM[j]</code>的内容传回到<code>CPU</code>;</p>
<p>​        寄存器也能提供同样的数据访问功能， 但没有开会的数据传递和寻址开销。</p>
<ul>
<li><p>寄存器位于<code>CPU</code>内部，所以对它们的访问几乎可以瞬间完成</p>
</li>
<li><p>与数百万个内存单元相比，寄存器数量非常少，机器语言指令可以使用短短几个位就能指定要操作的寄存器在什么位置，指令格式也会更短。</p>
<p>​    </p>
<p>不同的目的，不同的<code>CPU</code>采用不同数量、不同类型的寄存器。</p>
</li>
<li><p><strong>数据寄存器(Data registers)</strong>        为<code>CPU</code>提供短期记忆(memory)服务。例如计算<code>(a+b)*c</code>，必须先计算<code>(a+b)</code>的值并储存，可以暂存<code>(a+b)</code>到数据寄存器。</p>
</li>
<li><p><strong>寻址寄存器(Addressing registers)</strong>   为了进行读写，<code>CPU</code>必须连续访问内存中的数据。这样我们必须确定被访问的<strong>内存字(word)</strong>所在的内存地址。由上条指令得出的地址，地址会被存储在<strong>寻址寄存器</strong>。</p>
</li>
<li><p><strong>程序计数寄存器(Program counter register)</strong>  执行程序时，<code>CPU</code>必须总是知道下一条指令在指令内存中的地址，地址保存在<strong>程序计数寄存器(PC, Program Counter)</strong>中。<code>CPU</code>通过两种方式更新<code>PC</code>的内容：</p>
<ul>
<li>如果当前指令存在需要执行的<code>goto n</code>命令，则<code>CPU</code>将<code>PC</code>置为<code>n</code>；</li>
<li>否则，<code>PC</code>增1以便指针指向程序中的下一条指令。</li>
</ul>
</li>
</ul>
<h4 id="6-输入输出"><a href="#6-输入输出" class="headerlink" title="6.输入输出"></a>6.输入输出</h4><p>​        计算机使用一组<strong>输入输出(I/O)设备</strong>来与其外部环境进行交互。<strong>不考虑</strong>设备本身的构造，每个设备代表一块独立的机器，需要相关的工程知识；CSer设计不同方案将不同外设的<strong>物理细节封装</strong>，让计算机以相同的方式对它们进行操作，其中最简单的实现技巧之一就是<strong>I/O映像(memory-mapped I/O)</strong>。</p>
<p>​        I/O映像的基本思想是：创建I/O设备的二进制仿真，使其对于<code>CPU</code>而言，“看上去”就像普通的内存段。</p>
<h3 id="Hack-硬件平台规范详述"><a href="#Hack-硬件平台规范详述" class="headerlink" title="Hack 硬件平台规范详述"></a>Hack 硬件平台规范详述</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>​        Hack平台是16-位冯·诺伊曼机，一个<code>CPU</code>、两个独立的内存模块（指令内存和数据内存）和两个内存映像I/O设备（屏幕和键盘）。</p>
<p>​        Hack计算机执行位于指令内存中的程序。指令内存是只读设备，可以用ROM芯片实现。加载新的程序意味着要替换整个ROM芯片。HACK平台的硬件仿真器提供了<strong>加载文本文件</strong>的方法，文本文件包含用<strong>Hack机器语言</strong>编写的程序（从新在开始，<strong>分别用RAM和ROM来指代Hack的数据内存和指令内存</strong>）。因此两个独立的内存模块为：RAM和ROM。</p>
<p>​        Hack的CPU由<strong>ALU</strong>和三个分别称为<strong>数据寄存器(D, data regiter)</strong>、<strong>地址寄存器(A, address register)</strong>、<strong>程序计数器(PC, program counter)</strong>的寄存器组成。</p>
<p><img src="/post/881a6736/image-20200902144121386.png" alt="The Hack Computer"></p>
<p>……省略约3000字，请仔细看书🤣</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="[实现]"></a>[实现]</h3><ul>
<li><strong>Memory</strong>：内存，包括数据内存和指令内存，屏幕内存映像和键盘内存映像</li>
<li><strong>CPU</strong>：包含A寄存器，D寄存器，ALU，PC程序计数器</li>
<li><strong>Computer</strong>：完整的一个计算机平台。运行在仿真平台上</li>
</ul>
<h4 id="Memory："><a href="#Memory：" class="headerlink" title="Memory："></a>Memory：</h4><p>输入管脚：<code>in[16]</code>, <code>load</code>,<code>address[15]</code><br>输出管脚：<code>out[16]</code><br>Memory芯片主要由三个底层芯片构建：RAM16K，Screen，KeyBoard。同时我们必须通过这三个底层芯片来实现一个统一的逻辑地址空间，这个空间从地址0到24567。</p>
<ul>
<li>构建这个连续的地址空间的方法我们可以参考之前第三章由小RAM构建大RAM的方法。</li>
<li>内存的功能首先能够根据<code>address</code>选定需要进行操作的单元。</li>
<li>然后将<code>load</code>信号给指定的内存单元。根据<code>load</code>信号判断是进行写入还是继续保持。</li>
<li>下面进行地址连线：（注意此地址只有15位 -&gt; address[15]）<ul>
<li>RAM16K:  (0~16383) -&gt; (<strong>0</strong>00 0000 0000 0000) ~ ‭(<strong>0</strong>11 1111 1111 1111‬)</li>
<li>Screen:  (16384~24575) -&gt; (<strong>10</strong>0 0000 0000 0000) ~ ‭(<strong>10</strong>1 1111 1111 1111‬)</li>
<li>Keyboard: 24576 -&gt; (<strong>11</strong>0 0000 0000 0000)</li>
</ul>
</li>
</ul>
<ol>
<li><p>首先根据地址进行判断<strong>(00, 01, 10, 11)</strong>，应该将控制信号发送给<code>RAM</code>, <code>Screen</code>, <code>Keyboard</code>中的哪个地址空间。可以使用 <code>DMux</code>解复用 实现‬（将一个地址分发到不同的芯片）。</p>
<ol>
<li>由地址的第15位选择输出，区分出 <strong>RAM(0)</strong> 和 <strong>内存映射区(1)</strong>, 实际输出还是load = (0/1).</li>
<li>再由 <strong>内存映射区(1)</strong> 对应地址的第14位进行选择，区分出 <strong>Screen(0)</strong> 和 <strong>Keyboard(1)</strong>, 实际输出还是load = (0/1)</li>
</ol>
<ul>
<li>由于所给出的地址空间不会超过<code>110 0000 0000 0000</code>‬，所以我们只需要进行一次判断就可以了，而不用考虑后面13位的判断。</li>
</ul>
</li>
<li><p>然后将输入数据<code>in</code>，由<code>上个步骤</code>得出的<strong>控制信号</strong>和<strong>片内选择地址(RAM: 0~14bit, Screen: 0~13bit, Keboard: 1bit)</strong>给对应的芯片处理即可。Screen和Keyboard芯片都是内置好的，因此直接调用接口即可。</p>
</li>
</ol>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>输入管脚：<code>inM[16]</code>, <code>instruction[16]</code>, <code>reset</code><br>输出管脚：<code>outM[16]</code>, <code>writeM</code>, <code>addressM[15]</code>, <code>pc[15]</code><br>CPU实现的一种推荐方案：</p>
<p><img src="/post/881a6736/image-20200903101409828.png" alt="CPU-inplement"></p>
<ol>
<li>ALU</li>
<li>三个寄存器：A-Register、D-Register、PC</li>
<li>两个Mux（多路复用器）</li>
<li>利用输入的指令的规范逻辑完善<code>c</code>标签（不同芯片的控制位）的逻辑，即可实现CPU</li>
</ol>
<p><img src="/post/881a6736/image-20200903155249111.png" alt="decode"></p>
<p>​        对指令解码的逻辑，对MSB(0/1)进行区分A-指令和C-指令，提取出另外的15-bit。A-指令保存在<code>A Register</code>，C-指令还需继续解码。</p>
<p><img src="/post/881a6736/image-20200903161122686.png" alt="ALU-input"></p>
<p>​    ALU的数据输入：D-register、A-register/M-register</p>
<p>​    ALU根据<code>comp</code>域 <strong>控制</strong>输入<strong>执行</strong>哪一个运算函数。</p>
<p><img src="/post/881a6736/image-20200903161304535.png" alt="ALU-output"></p>
<p>​    ALU数据输出：D-register，A-register，M-register</p>
<p>​    ALU根据<code>dest</code>域 <strong>控制</strong>输出<strong>写入</strong>哪些寄存器</p>
<p><img src="/post/881a6736/image-20200903161840894.png" alt="reset"></p>
<p>​    计算机已经载入了程序，当按下<code>reset</code>，程序开始运行，重启也可。<strong>(PC=0)</strong></p>
<p><img src="/post/881a6736/image-20200903162246778.png" alt="jump-control"></p>
<p>​    PC概念：总是发送下一个指令的地址；由指令的<code>jump</code>域控制PC的输出</p>
<ul>
<li>开始/重启程序的执行，<code>reset = 1, PC = 0</code></li>
<li>程序不跳转，<code>jump = (000), PC++</code></li>
<li>程序无条件跳转，<code>jump = (111), PC = A</code></li>
<li>程序有条件跳转（判断条件是否满足再跳转），<code>jump = 1~3个1, PC = A</code></li>
</ul>
<p><img src="/post/881a6736/image-20200903163053983.png" alt="jump-implement"></p>
<p>​    PC的实现：</p>
<ul>
<li><code>reset</code>是否为1？</li>
<li><code>load</code>由<code>jump</code>域的3-bits和<strong>ALU的控制输出(ZR、NG)</strong>决定</li>
<li><code>load = 1, PC = A; load = 0, PC++</code></li>
</ul>
<p><img src="/post/881a6736/image-20200903163656399.png" alt="ZR-NG"></p>
<p>​    <strong>ALU的控制输出(ZR、NG)</strong>: 输出是0时，<code>ZR = 1</code>、输出是负数时，<code>NG = 1</code></p>
<h5 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h5><p>对指令进行<strong>解码</strong>，需要回顾一下第四章规范的指令格式：<br><strong>A-指令</strong>：</p>
<script type="math/tex; mode=display">
0vvv~~vvvv~~vvvv~~vvvv</script><p><code>MSB</code>: 0，其余15位表示地址值，存入<code>A Register</code>.</p>
<p> <strong>C-指令</strong>：</p>
<script type="math/tex; mode=display">
111a~~c_1c_2c_3c_4~~c_5c_6d_1d_2~~d_3j_1j_2j_3</script><ul>
<li><p><code>MSB</code>: 1，紧接着的两位无意义；</p>
</li>
<li><p><code>a</code>位域：控制与<code>D Register</code>进行计算的是<code>A Register</code>还是<code>M Register</code>；</p>
</li>
<li><code>comp</code>域：控制运算操作和逻辑操作，具体参考图4.3；</li>
<li><code>dest</code>域：控制目标存储位置，<strong>d~1~</strong>控制是否将ALU的计算结果存入<code>A Register</code>中，<strong>d~2~</strong>控制是否存入<code>D Register</code>中，<strong>d~3~</strong>控制是否存入<code>M Register</code>中;</li>
<li><code>jump</code>域：控制（有条件/无条件）跳转。</li>
</ul>
<h5 id="解码指令"><a href="#解码指令" class="headerlink" title="解码指令"></a>解码指令</h5><p>​        如果是A-指令，那么无论如何都要将地址加载到A寄存器中；如果是C-指令，则需要考虑<strong>d~1~</strong>，是否(1/0)需要将ALU的计算结果保存在A寄存器中。</p>
<p><img src="/post/881a6736/image-20200903110412596.png" alt="A-Instruction"></p>
<p>​        不妨暂时将第一个Mux的控制位记为<strong>c~m~</strong>，将A寄存器的控制位记作<strong>c~a~</strong>。</p>
<p>​        <strong>c~m~</strong>用于区分<strong>A</strong>-指令<strong>(0-vvv)</strong>和<strong>C</strong>-指令<strong>(111-)</strong>；<strong>c~a~</strong>用于控制是否写入<code>A Register</code>.</p>
<p>那么我们可以得到真值表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Instruction</th>
<th style="text-align:center">Instruction[15]</th>
<th style="text-align:center">d~1~</th>
<th style="text-align:center">c~m~</th>
<th style="text-align:center">c~a~</th>
</tr>
</thead>
<tbody>
<tr>
<td>A-instruction</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>A-instruction</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>C-instruction</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td>C-instruction</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>由真值表我们可以得到控制位<strong>c~m~</strong>和<strong>c~a~</strong>的公式：</p>
<script type="math/tex; mode=display">
c_m~=~\overline{Instruction[15]},~c_a~=~\overline{Instruction[15]·\overline{d_1}}~=~Or(\overline{Instruction[15]}, d1)</script><p>对于A-指令以上的工作就已经足够了。而对于C-指令我们还需要做其他的工作。</p>
<h5 id="C-指令的解码"><a href="#C-指令的解码" class="headerlink" title="C-指令的解码"></a>C-指令的解码</h5><p>​        C指令的d~1~位已经被解析完了，接下来从左向右开始解码。</p>
<ul>
<li><strong><em>a</em></strong>是控制选择<strong>A/M</strong>的控制位，所以它应该在第二个Mux，注意要与<code>MSB</code><strong>取与</strong>操作，确保为C-指令。</li>
</ul>
<p><img src="/post/881a6736/image-20200903153107852.png" alt="A/M-Register"></p>
<ul>
<li><strong>d~2~</strong>是控制计算结果是否保存在<code>D Register</code>中的，所以它与<code>MSB</code><strong>取与</strong>操作后，作为控制信号给<code>D Register</code>；</li>
</ul>
<p><img src="/post/881a6736/image-20200903154017004.png" alt="DRegister-C"></p>
<ul>
<li><strong>c~1~~c~6~</strong>是控制ALU的运算函数的，所以它们应该作为ALU的控制位，<code>comp</code>域对应ALU的运算函数。</li>
</ul>
<p><img src="/post/881a6736/image-20200903153824368.png" alt="ALU-c"></p>
<ul>
<li><strong>d~3~</strong>是控制计算结果是否保存在<code>M Register</code>中的，所以它作为输出与<code>MSB</code><strong>取与</strong>操作后，输出给writeM；</li>
</ul>
<p><img src="/post/881a6736/image-20200903154052424.png" alt="MRegister-C"></p>
<ul>
<li><strong><em>j</em>~1~, <em>j</em>~2~, <em>j</em>~3~</strong>是控制跳转的，总体上来看，只有两种现象，一种是顺序执行，即PC+1；另一种是跳转到地址为<code>A Register</code>中的地址单元。根据课本给出的编码：</li>
</ul>
<p><img src="/post/881a6736/image-20200903154135073.png" alt="jump-region"></p>
<p>​        究竟是否需要跳转，要根据ALU的计算结果进行判断。</p>
<p>​        ALU有两个<strong>控制</strong>输出信号：<strong>zr</strong>（当计算结果等于0时为1）对应 <strong>j~1~</strong>，<strong>ng</strong>（当计算结果小于0时为1）对应 <strong>j~2~</strong>；所以我们可以推出：$\overline{ng~+~zr}$（当计算结果大于0时为1）对应 <strong>j~3~</strong></p>
<p>​        结合<code>jump</code>域和ALU的输出结果，可以得到如下真值表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">(j~1~&amp;ng) Or (j~2~&amp;zr) Or (j~3~&amp; $\overline{ng~+~zr}$)</th>
<th style="text-align:center">load</th>
<th style="text-align:center">inc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>Memory</tag>
        <tag>nand2tetris</tag>
        <tag>HDL</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetis C4-机器语言</title>
    <url>/post/dd2b6294/</url>
    <content><![CDATA[<h1 id="机器语言-Machine-Language"><a href="#机器语言-Machine-Language" class="headerlink" title="[机器语言 Machine Language]"></a>[机器语言 Machine Language]</h1><p>借由机器语言，程序员用符号指令表达的抽象思维被转换成执行在硅片上的物理操作。</p>
<p><strong>This chapter is Complicated.</strong></p>
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><p>​        为了对机器语言作一般性描述，只须要集中讨论三个主要的抽象体上：<strong>处理器(processor)</strong>、<strong>内存(memory)</strong>以及一组<strong>寄存器(registers)</strong>。</p>
<h4 id="1-Machines"><a href="#1-Machines" class="headerlink" title="1.Machines"></a>1.Machines</h4><p>​        <strong>机器语言(machine language)</strong>利用<strong>处理器</strong>和<strong>寄存器操控内存</strong>。</p>
<p>​        <strong>内存(memory)</strong>    用来储存数据和指令的硬件设备。所有内存具有相同的结构：一个连续的固定宽度的单元序列，也称为<strong>字(word)</strong>或<strong>内存单元</strong>，每个内存单元都有一个唯一的<strong>地址(address)</strong>。因此可以通过地址描述任一内存单元。</p>
<p>​        <strong>处理器</strong>    <strong>中央处理器</strong>或<strong>CPU(Central Processing Unit)</strong>,是执行一组固定基本操作的设备。包括：算术操作、逻辑操作、内存存取操作和控制操作。操作对象都是二进制数值。</p>
<p>​        <strong>寄存器</strong>    内存访问较慢，需要较长的指令格式（一个地址可能需要32位）。因此，处理器都配有一些寄存器，每个寄存器只存储一位。紧挨着处理器，相当于处理器的一个高速本地内存，使得处理器能快速地操控数据和指令。</p>
<h4 id="2-Languages"><a href="#2-Languages" class="headerlink" title="2.Languages"></a>2.Languages</h4><p>​        16-位的指令包含四个4bit的位域(fileds)：最左边的域是CPU的操作编码，剩下的三个部分表示该操作的操作数。</p>
<p>​        <strong>二进制码</strong> 封装成 <strong>汇编(assembly language)</strong></p>
<p>​        汇编通过文本处理器编写，并由<strong>汇编编译器(assembler)</strong>将汇编程序 翻译成 <strong>二进制码</strong></p>
<h4 id="3-Commands"><a href="#3-Commands" class="headerlink" title="3.Commands"></a>3.Commands</h4><p>​        <strong>算术操作和逻辑操作</strong>    加减、布尔操作（按位取反、移位…）</p>
<p>​        <strong>内存访问</strong>    内存访问命令分两类。第一类是<strong>算术操作和逻辑操作</strong>，不仅可以操控寄存器，还可以操控指定的内存单元。第二类，所有计算机都会使用<code>load</code>和<code>store</code>命令，用来在寄存器和内存之间传递数据。这些命令可能会应用某些类型的寻址方式，在指令中指定目标内存单元的地址。三种绝大多数计算机支持的寻址方式：</p>
<ul>
<li>​    <strong>直接寻址(Direct Addressing)</strong>        最常用的寻址方式。直接 或 用符号表示内存单元的地址。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">LOAD R1, <span class="number">67</span>  <span class="comment">// R1 &lt;- Memory[67]</span></span><br><span class="line"><span class="comment">// 或者假设bar指向内存地址67，那么就有：</span></span><br><span class="line">LOAD R1, bar  <span class="comment">// R1 &lt;- Memory[67]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>​    <strong>立即寻址(Direct Addressing)</strong>        这种寻址方式用来加载常数——也即是，将指令中数据域的内容当作要操作的数据加载到寄存器。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">LOADI R1, <span class="number">67</span>  <span class="comment">// R1 &lt;- 67</span></span><br></pre></td></tr></table></figure>
<ul>
<li>​    <strong>间接寻址(Direct Addressing)</strong>        这种寻址方式用来处理<strong>指针(pointer)</strong>——也即是，将指令中数据域的内容当作要操作的数据加载到寄存器。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将x = foo[j] or x = *(foo+j)翻译成汇编语言</span></span><br><span class="line">ADD R1, foo, j  <span class="comment">// R1 &lt;- (foo+j)</span></span><br><span class="line">LOAD* R2, R1  <span class="comment">// R2 &lt;- Memory[R1]，取值到R2</span></span><br><span class="line">STR R2, x  <span class="comment">// x &lt;- R2，将值赋给x(内存单元)</span></span><br></pre></td></tr></table></figure>
<p>​        当数组在高级语言程序(C/Java…)被声明并被初始化时，编译器分配一组连续的内存单元来保存这个数组数据，并用foo来指代该内存单元组的<strong>基地址(base address)</strong>。于是当编译器以后遇到表示数组单元的符号<strong>(eg: foo[j])</strong>时，解析地址：<code>foo的基地址 + (j × 单个数组元素所占的字节)</code>。</p>
<p>​        <strong>控制流程</strong>        程序通常以先行执行，但也包含分支：<strong>反复</strong>(repetition, 跳回到循环的初始位置)、<strong>有条件的执行</strong>（conditional executioin, 若false向前跳到<code>if-then</code>语句之后）、<strong>子程序调用</strong>（subrouting calling, 跳到另一代码段的第一条命令处）</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高级实现</span></span><br><span class="line"><span class="keyword">while</span> (R1 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    code <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">code <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 底层实现</span></span><br><span class="line"><span class="comment">// while循环结构的典型翻译</span></span><br><span class="line">beginWhile</span><br><span class="line">    JNG R1, endWhile  <span class="comment">// if R1&lt;0 goto endWhile</span></span><br><span class="line">    <span class="comment">// code 1 的翻译</span></span><br><span class="line">JMP beginWhile  <span class="comment">// goto beginWhile</span></span><br><span class="line">endWhile:<span class="type"></span></span><br><span class="line"><span class="type">	</span>// code <span class="number">2</span> 的翻译</span><br></pre></td></tr></table></figure>
<h3 id="Hack机器语言规范详述"><a href="#Hack机器语言规范详述" class="headerlink" title="[Hack机器语言规范详述]"></a>[Hack机器语言规范详述]</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>​        Hack是一个基于冯·诺伊曼架构的16-位计算机，由一个CPU、两个独立的内存模块（instruction memory指令内存  和  data memory数据内存），以及两个内存映射I/O设备（显示器和键盘）组成。</p>
<p>​        <strong>内存地址空间</strong>        Hack程序员要了解，有两个不同的地址空间：<strong>指令地址空间</strong>（instruction memory<strong>指令内存</strong>），<strong>数据地址空间</strong>（data memory<strong>数据内存</strong>）。两个内存区16-位宽，由15-位地址空间，意味着两个内存可设定的最大地址都是<code>32K</code>的<code>16-bit word</code><strong>(2^15^ = 32 × 1024 = 32K)</strong></p>
<p>​        CPU只能执行存储在指令内存中的程序。指令内存是只读设备，程序通过某种外部方法被加载到指令内存中（加载新程序，就像游戏机更换游戏卡切换游戏）.  Hack平台的硬件仿真器提供一种方法，将某文本文件中用机器语言编写的程序加载到指令内存中。</p>
<p>​        <strong>寄存器(Registers)</strong>        Hack程序员要接触两个称为D和A的16-位寄存器，能够被算数和逻辑指令显式地操控(eg: <code>A = D-1</code>或<code>D = !A</code>)。D只作为数据寄存器（储存数据）；A既可以作为数据寄存器，也可以作为地址寄存器（储存地址）。</p>
<p><img src="/post/dd2b6294/image-20200827144620317.png" alt="三个寄存器" style="zoom: 50%;"></p>
<p>​        Hack语言规定，内存的存取指令是对隐式的内存地址“M”进行操作。<code>M-&gt;A, A=512, M = memory[512]</code></p>
<h4 id="2-A-指令-地址指令"><a href="#2-A-指令-地址指令" class="headerlink" title="2. A-指令 (地址指令)"></a>2. A-指令 (地址指令)</h4><p>唯一解析的指令：@value，为A寄存器赋值</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* value:</span></span><br><span class="line"><span class="comment"> *  1.非负的十进制常数≤32767(=2^15 - 1)</span></span><br><span class="line"><span class="comment"> *  2.指向(非负的十进制常数)的符号, eg:sum</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@<span class="number">21</span>：</span><br><span class="line"> - A寄存器赋值为<span class="number">21</span>  data register</span><br><span class="line"> - RAM[<span class="number">21</span>]将成为选定的RAM寄存器  address register</span><br><span class="line"><span class="comment">// 二进制形式：0value</span></span><br></pre></td></tr></table></figure>
<p>​        只要赋值赋值给A寄存器，A寄存器会自动从数据存储器中选中被选择的寄存器，被选择的寄存器就是上图中的M寄存器。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set RAM[100] to -1</span></span><br><span class="line">@<span class="number">100</span>  <span class="comment">// A = 100, 二进制：0value(=0000 0000 0110 0100)</span></span><br><span class="line">M = <span class="number">-1</span>  <span class="comment">// RAM[100] = -1</span></span><br></pre></td></tr></table></figure>
<p>​        此段代码，M就是代表了内存单元中的寄存器RAM[100]。这就是 A-指令 的用法，在内存的存取操作之前，我们总是要用 A-指令 去选择一个寄存器，进而完成内存的存取。</p>
<h4 id="3-C-指令"><a href="#3-C-指令" class="headerlink" title="3. C-指令"></a>3. C-指令</h4><p><img src="/post/dd2b6294/image-20200827153104413.png" alt="C指令" style="zoom:50%;"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dest or jump are optional</span></span><br><span class="line"><span class="comment">// if dest is null, &quot;=&quot; omit</span></span><br><span class="line"><span class="comment">// if jump is null, &quot;;&quot; omit</span></span><br><span class="line">C-instructions: <span class="type">dest </span>= comp;jump</span><br></pre></td></tr></table></figure>
<p>comp域：ALU计算什么；</p>
<p>dest域：计算后的结果（ALU的输出）将被存储到哪里；</p>
<p>jump域：接下来要取出并执行拿一条命令</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set the D register to -1</span></span><br><span class="line">D = <span class="number">-1</span>  <span class="comment">// D in dest table, -1 in comp table</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Set RAM[300] to the value of the D register minus 1</span></span><br><span class="line">@<span class="number">300</span>  <span class="comment">// A = 300, slect the register which I want to operate (access memory)</span></span><br><span class="line">M = D<span class="number">-1</span>  <span class="comment">// (D-1) in comp table</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// If (D-1 == 0) jump to execute the instruction stored in ROM[56]</span></span><br><span class="line">@<span class="number">56</span>  <span class="comment">// A=56</span></span><br><span class="line">D<span class="number">-1</span>;JEQ  <span class="comment">// if (D-1 == 0) go to 56.</span></span><br><span class="line"><span class="comment">// (D-1) in comp table, JEQ is (if out=0 then jump)</span></span><br></pre></td></tr></table></figure>
<p>C-指令的二进制表示：</p>
<p><img src="/post/dd2b6294/image-20200827160411973.png" alt="C指令的二进制形式" style="zoom:50%;"></p>
<p>C-指令的compute域：</p>
<p><img src="/post/dd2b6294/image-20200827160756020.png" alt="C-指令的compute域" style="zoom:50%;"></p>
<p>C-指令的dest域：</p>
<p><img src="/post/dd2b6294/image-20200827160915065.png" alt="C-指令的dest域" style="zoom:50%;"></p>
<p>dest域为3位二进制组合，代表了8种可能。</p>
<p>C-指令的jump域：</p>
<p><img src="/post/dd2b6294/image-20200827161133846.png" alt="C-指令的jump域" style="zoom:50%;">与dest域相似，junp也是3位二进制组合。</p>
<p>特别的，最后一个指令<code>(0;JMP)</code>执行一个无条件跳转。（其实除了0，还可取任意数值）</p>
<h4 id="4-符号"><a href="#4-符号" class="headerlink" title="4. 符号"></a>4. 符号</h4><p>​        汇编命令可以使用常数或符号来表示内存单元位置（地址）。</p>
<h4 id="5-输入-输出处理"><a href="#5-输入-输出处理" class="headerlink" title="5. 输入/输出处理"></a>5. 输入/输出处理</h4><p>Hack能连接两个外设，屏幕和键盘。两个设备与计算机的交互都是通过<strong>内存映像(memory maps)</strong>实现的。</p>
<p>这意味着在屏幕上描述像素是通过<strong>将二进制值写入</strong>与屏幕相关的<strong>内存段</strong>来实现的。</p>
<p>键盘的输入是通过<strong>读取</strong>与键盘相关的<strong>内存单元</strong>来实现的。</p>
<p>物理I/O设备和它们对应的内存映像是通过<strong>连续的循环刷新</strong>进行<strong>同步</strong>的。</p>
<h4 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h4><p>​        屏幕通过电线连接计算机，如果我们追踪电线，我们可以看到它进连接了RAM的一个区域，称为屏幕内存映射。</p>
<p><img src="/post/dd2b6294/image-20200828104048726.png" alt="screen memory map" style="zoom:50%;"></p>
<p>​        1 = 黑，0 = 白。而这中间的困难是，显示单元是二维的；内存映射是一维的，我们必须连接起来。我们只能从内存映射中<strong>读写</strong>16位数据，而无法只<strong>操作</strong>一个单独的位的数据。</p>
<p>​        对内存的存取操作都是16位，因此我们可以取出16位，对其中的1位进行操作之后，再存放。</p>
<p>​        另一难题，如何在内存映射出对应的行-列？</p>
<ol>
<li><p><code>word = Screen[32×row + col/16] (整除)</code></p>
<p>​        屏幕的内容<code>(131072 = 256*512)</code>由RAM<strong>基地址</strong>为<strong>16384(0x4000)</strong>的<strong>8K</strong> 内存映射 来表示，作用和记忆单元完全一样，对内存进行读写操作。而在整个计算机中，这个芯片将会成为数据内存的一部分，所以数据内存将由多个芯片组成。<code>8K = 8192, 8192*16bits = 131072</code></p>
<p><code>word = RAM[16384 + 32×row + col/16]</code></p>
</li>
</ol>
<pre><code> ​    求解出行-列，那么如何存取16位地址块中的 哪一个 二进制数呢？
</code></pre><ol>
<li><code>col%16</code>得到0至15之间的数，可以对其置1或0，修改之后再保存整个16位地址。在下一个时钟周期，就可以改变屏幕显示的像素。</li>
</ol>
<p>书上的例子：(应该是最右的元素)</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在屏幕的右上角换一个黑点</span></span><br><span class="line">@SCREEN  <span class="comment">// 将 A寄存器的值 置入 内存映射区，映射到屏幕第一行的16个像素的内存字</span></span><br><span class="line">M = <span class="number">1</span>  <span class="comment">// 1: (00000000000000001), 将最右边的像素变黑</span></span><br></pre></td></tr></table></figure>
<p>视频上的硬件仿真器的例子：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eg:第3行前16列的所有像素变黑</span></span><br><span class="line">CHIP Screen&#123;</span><br><span class="line">	IN  <span class="keyword">in</span>[<span class="number">16</span>],    <span class="comment">// what to write</span></span><br><span class="line">    load,          <span class="comment">// write-enable bit</span></span><br><span class="line">    address[<span class="number">13</span>];   <span class="comment">// where to read/write</span></span><br><span class="line">    OUT out[<span class="number">16</span>];   <span class="comment">// Screen value at the given address   </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 32*3 = 96; address[13] = 96 = (0000 0000 0110 0000);</span></span><br><span class="line"><span class="comment">// load = 1</span></span><br><span class="line"><span class="comment">// in[16] = (1111 1111 1111 1111) = -1</span></span><br><span class="line"><span class="comment">// 写入内存后，还需要run时钟，将在下一个时钟周期刷新后显示</span></span><br></pre></td></tr></table></figure>
<h4 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h4><p>​        键盘通过电缆连接计算机，如果我们追踪电缆，我们可以看到它进入了RAM的一个区域，称为键盘内存映射。</p>
<p><img src="/post/dd2b6294/image-20200828105047045.png" alt="keyboard memory map" style="zoom:50%;"></p>
<p>​        Hack计算机与物理键盘之间通过RAM基地址为<strong>24576(0x6000)</strong>的单字内存映像进行交互。只要在键盘上敲一个键，其对应的16-位<strong>ASCII码</strong>值就出现在<strong>RAM[24576]</strong>。没有敲键盘时，该内存单元的值就是<strong>0(=0000 0000 0000 0000)</strong>。除了常用的<strong>ASCII码</strong>之外，Hack键盘还可以识别：</p>
<p><img src="/post/dd2b6294/image-20200828105539792.png" alt="键盘识别额外的键" style="zoom:50%;"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Read-Only</span></span><br><span class="line">CHIP Keyboard &#123;</span><br><span class="line">    OUT out[<span class="number">16</span>];   <span class="comment">// The ASCII code of the pressed key, </span></span><br><span class="line">                   <span class="comment">// or 0 if no key is currently pressed, </span></span><br><span class="line">                   <span class="comment">// or one the special codes listed in Figure 5.5.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        按下瞬间识别，松手则无键按下，置0.</p>
<h3 id="zap-zap-zap-机器语言实践"><a href="#zap-zap-zap-机器语言实践" class="headerlink" title=":zap::zap::zap:[机器语言实践]"></a>:zap::zap::zap:[机器语言实践]</h3><p><strong>D: data register</strong></p>
<p><strong>A: (address / data) register</strong></p>
<p><strong>M: the currently selelcted memory register, M = RAM[A]</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// D = 10</span></span><br><span class="line">@<span class="number">10</span></span><br><span class="line">D=A</span><br><span class="line"></span><br><span class="line"><span class="comment">// D++</span></span><br><span class="line">D+<span class="number">1</span>  <span class="comment">// D+1 in comp table of C-instruction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// D=RAM[17]</span></span><br><span class="line">@<span class="number">17</span>  <span class="comment">// now, M=RAM[17]</span></span><br><span class="line">D=M</span><br><span class="line"></span><br><span class="line"><span class="comment">// RAM[17]=0</span></span><br><span class="line">@<span class="number">17</span></span><br><span class="line">M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RAM[17]=10</span></span><br><span class="line">@<span class="number">10</span></span><br><span class="line">D=A  <span class="comment">// store the value</span></span><br><span class="line">@<span class="number">17</span>  <span class="comment">// slelect the register</span></span><br><span class="line">M=D</span><br><span class="line"></span><br><span class="line"><span class="comment">// RAM[5] = RAM[3]</span></span><br><span class="line">@<span class="number">3</span></span><br><span class="line">D=M</span><br><span class="line">@<span class="number">5</span></span><br><span class="line">M=D</span><br></pre></td></tr></table></figure>
<p>Computes: RAM[2] = RAM[0] + RAM[1]</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@<span class="number">0</span>  <span class="comment">// R0 may be better</span></span><br><span class="line">D=M</span><br><span class="line"></span><br><span class="line">@<span class="number">1</span>  <span class="comment">// R1 may be better</span></span><br><span class="line">D=D+M  <span class="comment">// D+M in comp table of C-instruction</span></span><br><span class="line"></span><br><span class="line">@<span class="number">2</span>  <span class="comment">// R2 may be better</span></span><br><span class="line">M=D</span><br><span class="line">    </span><br><span class="line">@<span class="number">6</span></span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// end of program, use infinite loop to avoid </span></span><br></pre></td></tr></table></figure>
<p>空格在翻译时被忽略。</p>
<p>当我们要使用<strong>寄存器(R0~R15)</strong>时，利用符号表示，以获得更好的可读性：（此时A寄存器作为 address register）</p>
<p><img src="/post/dd2b6294/image-20200828141806438.png" alt="symbols" style="zoom:50%;"></p>
<p>符号严格区分大小写，请只使用‘R’。</p>
<p>SCREEN、KBD以及其他的内置符号</p>
<p><img src="/post/dd2b6294/image-20200828142217495.png" alt="extra symbols" style="zoom:50%;"></p>
<p>SCREEN和KBD代表的分别是：输出和输入设备内存映射的基地址。</p>
<h4 id="分支-Branching"><a href="#分支-Branching" class="headerlink" title="[分支 Branching]"></a>[分支 Branching]</h4><p><img src="/post/dd2b6294/image-20200828144432517.png" alt="branch" style="zoom:50%;"></p>
<p><strong>@LABEL</strong>会被翻译成@n，其中n是<strong>(LABEL)</strong>声明后的<strong>指令号</strong>。</p>
<p>(POSITIVE)是8，(END)是10</p>
<h4 id="Variables"><a href="#Variables" class="headerlink" title="[Variables]"></a>[Variables]</h4><p><img src="/post/dd2b6294/image-20200828161742688.png" alt="flip" style="zoom:50%;"></p>
<p>@temp变成中间变量，效果相当于@n，</p>
<p>@temp变量从地址16开始，可声明n个变量。</p>
<p>计算累加和</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Computes RAM[1] = 1+2+ ... +RAM[0]</span></span><br><span class="line">    <span class="keyword">int</span> n = R0;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">LOOP:</span><br><span class="line">    <span class="keyword">if</span> i &gt; n <span class="keyword">goto</span> STOP;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> LOOP;</span><br><span class="line">STOP:</span><br><span class="line">    R1 = sum; </span><br></pre></td></tr></table></figure>
<p>将伪代码转换成我们的Hack汇编</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Computes RAM[1] = 1+2+ ... +n</span></span><br><span class="line"><span class="comment">// Usage: put a number (n) in RAM[0]</span></span><br><span class="line"></span><br><span class="line">    @R0</span><br><span class="line">    D=M</span><br><span class="line">    @n</span><br><span class="line">    M=D  <span class="comment">// n = R0</span></span><br><span class="line">    @i</span><br><span class="line">    M=<span class="number">1</span>  <span class="comment">// i = 1</span></span><br><span class="line">    @sum</span><br><span class="line">    M=<span class="number">0</span>  <span class="comment">// sum = 0</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    @i</span><br><span class="line">    D=M</span><br><span class="line">    @n</span><br><span class="line">    D=D-M  <span class="comment">// n - i</span></span><br><span class="line">    @STOP</span><br><span class="line">    D;JGT  <span class="comment">// jump (if) greater than; if i &gt; n goto STOP</span></span><br><span class="line"></span><br><span class="line">    @sum</span><br><span class="line">    D=M</span><br><span class="line">    @i</span><br><span class="line">    D=D+M</span><br><span class="line">    @sum</span><br><span class="line">    M=D</span><br><span class="line">    @i</span><br><span class="line">    M=M+<span class="number">1</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(STOP)</span><br><span class="line">    @sum</span><br><span class="line">    D=M</span><br><span class="line">    @R1</span><br><span class="line">    M=D  <span class="comment">// R[1] = sum</span></span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
<p>​    这是我们最佳的Hack汇编实践方式：</p>
<ol>
<li>Design the program using pseudo code and Make sure it works.</li>
<li>Write the program in assembly language.</li>
<li>Test the program (on paper) using a variable-value trace table.</li>
</ol>
<h4 id="指针"><a href="#指针" class="headerlink" title="[指针]"></a>[指针]</h4><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for(i=0; i&lt;n; i++)&#123;</span></span><br><span class="line"><span class="comment">// 		arr[i] = -1;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// Suppose that arr=100 and n=10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr = 100</span></span><br><span class="line">    @<span class="number">100</span></span><br><span class="line">    D=A</span><br><span class="line">    @arr</span><br><span class="line">    M=D</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n = 10</span></span><br><span class="line">    @<span class="number">10</span></span><br><span class="line">    D=A</span><br><span class="line">    @n</span><br><span class="line">    M=D</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize i = 0</span></span><br><span class="line">    @i</span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    <span class="comment">// if (i==n) goto END. (not STOP cause we dont intent to valuation)</span></span><br><span class="line">    @i</span><br><span class="line">    D=M</span><br><span class="line">    @n</span><br><span class="line">    D=D-M</span><br><span class="line">    @END</span><br><span class="line">    D;JEQ</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RAM[arr+i] = -1</span></span><br><span class="line">    @arr</span><br><span class="line">    D=M</span><br><span class="line">    @i</span><br><span class="line">    A=D+M  <span class="comment">// A = arr+i</span></span><br><span class="line">    M=<span class="number">-1</span>  <span class="comment">// RAM[arr+i] = -1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// i++</span></span><br><span class="line">    @i</span><br><span class="line">    M=M+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
<p><img src="/post/dd2b6294/image-20200828210609280.png" alt="pointers" style="zoom:50%;"></p>
<ul>
<li><p>高级语言中，<code>arr</code>和<code>i</code>之类<strong>存储地址</strong>的变量称为<strong>指针</strong>。</p>
</li>
<li><p>Hack指针的逻辑：无论何时，当我们必须用指针访问内存，我们需要像<code>A=M</code>的指令。（对<code>RAM[M]</code>操作）</p>
</li>
<li>将地址寄存器（A register）设置为某个内存寄存器的内容，其中我们做了一些指针运算，计算我们需要操作的地址。</li>
</ul>
<h4 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入 / 输出"></a>输入 / 输出</h4><p><img src="/post/dd2b6294/image-20200828211646079.png" alt="input/output" style="zoom:50%;"></p>
<p>上图知识回顾。</p>
<p>我们需要在屏幕上画全黑的矩形，简单的思路是迭代足够多的行，让屏幕显示“黑块”。</p>
<p>psuedu code: </p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for (i=0; i&lt;n; i++)&#123;</span></span><br><span class="line"><span class="comment">// 		draw 16 block pixels at the beginning of row i</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">	addr = SCREEN</span><br><span class="line">    n = RAM[<span class="number">0</span>]</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    LOOP:<span class="type"></span></span><br><span class="line"><span class="type">        if i &gt; n goto END</span></span><br><span class="line"><span class="type">        RAM</span>[addr] = <span class="number">-1</span>  <span class="comment">// 1111 1111 1111 1111(= 16 black pixels)</span></span><br><span class="line">        <span class="comment">// advances to the next row</span></span><br><span class="line">        addr = addr + <span class="number">32</span>  <span class="comment">// 我们用内存映射的前32行代表一整行512(=32*16)个像素，每行如此</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        goto LOOP</span><br><span class="line"></span><br><span class="line">    END:<span class="type"></span></span><br><span class="line"><span class="type">        goto END</span></span><br></pre></td></tr></table></figure>
<p>实现的Hack汇编：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">   @SCREEN</span><br><span class="line">   D=A</span><br><span class="line">   @addr</span><br><span class="line">   M=D  <span class="comment">// addr = 16384(base address)</span></span><br><span class="line"></span><br><span class="line">   @R0</span><br><span class="line">   D=M</span><br><span class="line">   @n</span><br><span class="line">   M=D  <span class="comment">// n = RAM[0]</span></span><br><span class="line"></span><br><span class="line">   @i</span><br><span class="line">   M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    @i</span><br><span class="line">    D=M</span><br><span class="line">    @n</span><br><span class="line">    D=D-M</span><br><span class="line">    @END</span><br><span class="line">    D;JGT  <span class="comment">// if i &gt; n goto END</span></span><br><span class="line"></span><br><span class="line">    @addr</span><br><span class="line">    A=M</span><br><span class="line">    M=<span class="number">-1</span>  <span class="comment">// RAM[addr] = 1111 1111 1111 1111</span></span><br><span class="line"></span><br><span class="line">    @i</span><br><span class="line">    M=M+<span class="number">1</span>  <span class="comment">// i = i + 1</span></span><br><span class="line">    @<span class="number">1</span></span><br><span class="line">    D=A  <span class="comment">// D = RAM[32]</span></span><br><span class="line">    @addr</span><br><span class="line">    M=M+D  <span class="comment">// addr = addr + 32</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP  <span class="comment">// goto END</span></span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END  <span class="comment">// program&#x27;s end</span></span><br><span class="line">    <span class="number">0</span>;JMP  <span class="comment">// infinite loop</span></span><br></pre></td></tr></table></figure>
<h5 id="键盘-1"><a href="#键盘-1" class="headerlink" title="键盘"></a>键盘</h5><p><img src="/post/dd2b6294/image-20200828222504824.png" alt="keyboard" style="zoom:50%;"></p>
<ul>
<li>读出RAM[24576]的内容<ul>
<li>如果寄存器存储了0，说明无键输入；</li>
<li>否则，寄存器存储了现在按下的键的<strong>键盘扫描码</strong>。</li>
</ul>
</li>
</ul>
<h4 id="Project"><a href="#Project" class="headerlink" title="[Project]"></a>[Project]</h4><h5 id="1-Mult"><a href="#1-Mult" class="headerlink" title="1. Mult"></a>1. Mult</h5><p>a program performing <code>R2 = R0 * R1</code>.</p>
<p>pseudo code:</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">   i = RAM[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">   LOOP:<span class="type"></span></span><br><span class="line"><span class="type">       </span>// This is assembly, may be variable <span class="string">&#x27;i&#x27;</span> isnt so necessary like C program, can use RAM[<span class="number">0</span>] directly.</span><br><span class="line">       <span class="keyword">if</span> i ≤ <span class="number">0</span> goto STOP  </span><br><span class="line">       i = i - <span class="number">1</span></span><br><span class="line">       sum = sum + RAM[<span class="number">1</span>]</span><br><span class="line">       goto LOOP</span><br><span class="line"></span><br><span class="line">   STOP:<span class="type"></span></span><br><span class="line"><span class="type">       RAM</span>[<span class="number">2</span>] = sum</span><br><span class="line">       </span><br><span class="line">   END:<span class="type"></span></span><br><span class="line"><span class="type">       goto END</span></span><br></pre></td></tr></table></figure>
<p>impletement: mult.asm</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book &quot;The Elements of Computing Systems&quot;</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/04/Mult.asm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiplies R0 and R1 and stores the result in R2.</span></span><br><span class="line"><span class="comment">// (R0, R1, R2 refer to RAM[0], RAM[1], and RAM[2], respectively.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Put your code here.</span></span><br><span class="line"></span><br><span class="line">    @sum</span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line">    @R0</span><br><span class="line">    D=M</span><br><span class="line">    @i</span><br><span class="line">    M=D</span><br><span class="line">    @R2</span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    @i</span><br><span class="line">    D=M</span><br><span class="line">    @STOP</span><br><span class="line">    D;JLE  <span class="comment">// jump less equal; if R[0] &lt;= 0 goto STOP</span></span><br><span class="line">    @i</span><br><span class="line">    M=M<span class="number">-1</span>  <span class="comment">// i--</span></span><br><span class="line"></span><br><span class="line">    @R1</span><br><span class="line">    D=M</span><br><span class="line">    @sum</span><br><span class="line">    M=M+D  <span class="comment">// D = sum + R[0]</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(STOP)</span><br><span class="line">    @sum</span><br><span class="line">    D=M</span><br><span class="line">    @R2</span><br><span class="line">    M=D  <span class="comment">// R[2] = sum</span></span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
<h5 id="2-Fill"><a href="#2-Fill" class="headerlink" title="2. Fill"></a>2. Fill</h5><p><strong>持续监听</strong>键盘输入，只要有<strong>任何键被按下</strong>，屏幕全黑；只要<strong>松开按键</strong>，屏幕恢复全白。</p>
<ol>
<li>如何定义无限循环？</li>
<li>什么意味着监听到按键？</li>
<li>监听到按键后，如何将屏幕变黑？</li>
<li>如何清屏？</li>
</ol>
<p><strong>如何定义无限循环？</strong></p>
<p>关键在于程序结束时的跳转，只要我们能保证，程序总是跳转到循环开始的地方即可。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">(LOOP)</span><br><span class="line">...</span><br><span class="line">@LOOP</span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// 程序结束，跳转到 LOOP tag</span></span><br></pre></td></tr></table></figure>
<p><strong>什么意味着监听到按键？</strong></p>
<p>​        当键盘任意键被按下，那么<strong>键盘的内存映射区</strong>的值一定大于0，所以判断 <strong>键盘基地址(KBD)对应的值</strong> 是否大于0即可。由于程序在<strong>无限循环</strong>，所以只要按键不松开，那么 <strong>KBD的值</strong> 就不会变回0，我们的程序就会一直输出，直到屏幕被填满。</p>
<p>​        如果<strong>KBD的值</strong>为0，说明键盘<strong>空置</strong>，我们的程序应该转而去执行<strong>恢复白屏</strong>的操作。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@KBD</span><br><span class="line">D=M  <span class="comment">// D-register gets the basic address of the keyboard memory-map.</span></span><br><span class="line">@FILL</span><br><span class="line">D;JGT  <span class="comment">// jump (to FILL if D) greater than 0.</span></span><br><span class="line">@CLEAR</span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// other case(= D≤0), unconditional jump to CLEAR</span></span><br></pre></td></tr></table></figure>
<p><strong>监听到按键后，如何将屏幕变黑？</strong></p>
<p>​        这正是<code>FILL</code>需要实现的功能。我们通过课堂的例子知道，一次<strong>存取</strong>操作<strong>最多</strong>只可以将<strong>16bit</strong>的数据置为<strong>-1(= 1111 1111 1111 1111)</strong>，从而变黑。因此如果将全屏幕变黑，就需要通过循环实现，循环需要知道起点和终点或者起点和长度。</p>
<p>​        (起点)我们可以存储当前的地址到变量<code>@current</code>，(终点)存储<strong>屏幕内存映射区的最大单元地址(=24575)</strong>到变量<code>@max</code>。另外，要用长度也可以存储<strong>屏幕最大长度8K(=8192)</strong>。需要注意的是，当前地址表示的是第一个可用的单元地址，如果无可用单元，那么<code>current - max &lt; 0</code>，若等于0，则表示最后一个单元可用。（24576恰好为键盘的内存映射地址）</p>
<p>​        循环条件已经解决，如果填充满了，直接返回LOOP；如果未满，则继续。</p>
<p>​        如果按键不松，那么循环会一直检测到按键，也就会一直执行FILL模块，每执行一次会填充一个单元(=16bits)的黑色像素，因此，在屏幕上看到的像素显示是幕帘式的，而不是骤变的。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@SCREEN</span><br><span class="line">D=A  <span class="comment">// D-register gets the basic address of the screen memory-map.</span></span><br><span class="line">@current</span><br><span class="line">M=D</span><br><span class="line">@<span class="number">24575</span>  <span class="comment">// max address of  the screen memory-map.</span></span><br><span class="line">D=A</span><br><span class="line">@max</span><br><span class="line">M=D</span><br><span class="line"></span><br><span class="line">(FILL)</span><br><span class="line">@current</span><br><span class="line">D=M</span><br><span class="line">@max</span><br><span class="line">D=D-M  <span class="comment">// current - max</span></span><br><span class="line">@LOOP</span><br><span class="line">D;JGT  <span class="comment">// jump if current &gt; max</span></span><br><span class="line"></span><br><span class="line">@current</span><br><span class="line">D=M  <span class="comment">// get address</span></span><br><span class="line">A=D  <span class="comment">// A = current address, in order to change Memory[current]</span></span><br><span class="line">M=<span class="number">-1</span>  <span class="comment">// current address turn black</span></span><br><span class="line">@current</span><br><span class="line">M=M+<span class="number">1</span></span><br><span class="line">@LOOP</span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// return LOOP</span></span><br></pre></td></tr></table></figure>
<p><strong>如何清屏？</strong></p>
<p>​        这正是<code>CLEAR</code>需要实现的功能，是<code>FILL</code>的逆过程。当程序检测到<strong>无按键(KBD的值为0)</strong>，进入<code>CLEAR</code>模块。</p>
<p>​        清屏操作，获取当前地址，并循环：减一，并与屏幕基地址SCREEN比较，若小于则清屏结束；否则，继续清屏。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">(CLEAR)</span><br><span class="line">@current</span><br><span class="line">D=M</span><br><span class="line">D=D<span class="number">-1</span>  <span class="comment">// 先减一</span></span><br><span class="line">@SCREEN</span><br><span class="line">D=D-A  <span class="comment">// (current address) minus (SCREEN basic address)</span></span><br><span class="line">@LOOP</span><br><span class="line">D;JLT</span><br><span class="line">@current</span><br><span class="line">D=M  <span class="comment">// get address</span></span><br><span class="line">A=D  <span class="comment">// A = current address, in order to change Memory[current]</span></span><br><span class="line">M=<span class="number">0</span>  <span class="comment">// current address turn white</span></span><br><span class="line">@LOOP</span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// return LOOP</span></span><br></pre></td></tr></table></figure>
<p>Pseudo code</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">max = <span class="number">24575</span>;</span><br><span class="line">current = SCREEN;</span><br><span class="line">LOOP()&#123;</span><br><span class="line">    <span class="keyword">if</span>(Memory[KBD] &gt; <span class="number">0</span>)&#123;  <span class="comment">// 键盘有按键</span></span><br><span class="line">        FILL();</span><br><span class="line">    &#125;</span><br><span class="line">    CLEAR();</span><br><span class="line">&#125;</span><br><span class="line">FILL()&#123;</span><br><span class="line">    <span class="keyword">if</span>((current-max) &gt; <span class="number">0</span>)&#123;  <span class="comment">// 当前地址大于屏幕显示内存映射区的最大地址，已填满屏幕</span></span><br><span class="line">      LOOP();  </span><br><span class="line">    &#125;</span><br><span class="line">    Memory[current] = <span class="number">-1</span>;</span><br><span class="line">    current++;</span><br><span class="line">    LOOP();</span><br><span class="line">&#125;</span><br><span class="line">CLEAR()&#123;</span><br><span class="line">    <span class="keyword">if</span>((SCREEN-current) &gt; <span class="number">0</span>)&#123;  <span class="comment">// 当前地址小于屏幕显示内存映射区的最小地址，已清空屏幕</span></span><br><span class="line">        LOOP();</span><br><span class="line">    &#125;</span><br><span class="line">    Memory[current] = <span class="number">0</span>;</span><br><span class="line">    current--;</span><br><span class="line">    LOOP();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>implement:</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// max = 24575, store as a address</span></span><br><span class="line">    @<span class="number">24575</span></span><br><span class="line">    D=A</span><br><span class="line">    @max</span><br><span class="line">    M=D</span><br><span class="line"></span><br><span class="line">    <span class="comment">// current = SCREEN, store as a address</span></span><br><span class="line">    @SCREEN</span><br><span class="line">    D=A</span><br><span class="line">    @current</span><br><span class="line">    M=D</span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    <span class="comment">// if(Memory[KBD] &gt; 0)&#123;  // 键盘有按键</span></span><br><span class="line">    <span class="comment">//     FILL();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    @KBD</span><br><span class="line">    D=M  <span class="comment">// *** get Memory[KBD]</span></span><br><span class="line">    @FILL</span><br><span class="line">    D;JGT</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CLEAR();  // no conditional</span></span><br><span class="line">    @CLEAR</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(FILL)</span><br><span class="line">    @current</span><br><span class="line">    D=M</span><br><span class="line">    @max</span><br><span class="line">    D=D-M  <span class="comment">// current - max</span></span><br><span class="line">    @LOOP</span><br><span class="line">    D;JGT</span><br><span class="line"></span><br><span class="line">    @current</span><br><span class="line">    A=M</span><br><span class="line">    M=<span class="number">-1</span></span><br><span class="line">    @current</span><br><span class="line">    M=M+<span class="number">1</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(CLEAR)</span><br><span class="line">    @SCREEN</span><br><span class="line">    D=A  <span class="comment">// *** get SCREEN address</span></span><br><span class="line">    @current</span><br><span class="line">    D=D-M  <span class="comment">// SCREEN - current</span></span><br><span class="line">    @LOOP</span><br><span class="line">    D;JGT</span><br><span class="line"></span><br><span class="line">    @current</span><br><span class="line">    A=M</span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    @current</span><br><span class="line">    M=M<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
<p>做的时候困扰我的反而是：@KBD之后获取Memory[KBD]的值，以及@SCREEN之后获取SCREEN地址。成功把我绕晕了….</p>
<p><img src="/post/dd2b6294/image-20200830115543297.png" alt="result00" style="zoom:50%;"></p>
<p><img src="/post/dd2b6294/image-20200830115451987.png" alt="result01" style="zoom:50%;"></p>
<p>A-register、D-register and @value:</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@<span class="number">1024</span>  <span class="comment">// 传说中的 A-instruction  也就是A指令, 下面的都是C指令</span></span><br><span class="line">D=A    <span class="comment">// 读取数据1024, 并赋值给 D-Register 也就是 data-Register 数据寄存器</span></span><br><span class="line">D=M    <span class="comment">// 读取内存地址为1024 的值也就是 Memory[1024]</span></span><br><span class="line">D;JEQ  <span class="comment">// 跳转逻辑 如果当前数据寄存器中的值等于0, 则pc = 1024, 也就是当前下一个输入的指令地址为1</span></span><br></pre></td></tr></table></figure>
<p><em>test:</em>(from阿德莱德大学)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rust 伪代码 add up all 10 numbers in the array numbers</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = sum + *numbers++;</span><br><span class="line">    <span class="keyword">let</span> x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>implement: (passed test)</em></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">    @x  <span class="comment">// 16</span></span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line">    @sum  <span class="comment">// 17</span></span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line">    @numbers  <span class="comment">// address in [18,27]</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    @x</span><br><span class="line">    D=M</span><br><span class="line">    @<span class="number">10</span></span><br><span class="line">    D=D-A  <span class="comment">// (x-10)</span></span><br><span class="line">    @END</span><br><span class="line">    D;JGE  <span class="comment">// 与伪代码符号完全相反：‘＞’ =&gt; ‘≤’</span></span><br><span class="line"></span><br><span class="line">    @numbers  <span class="comment">// array</span></span><br><span class="line">    A=M</span><br><span class="line">    D=M  <span class="comment">// D = *numbers</span></span><br><span class="line">    @sum</span><br><span class="line">    M=D+M  <span class="comment">// sum = *numbers + sum</span></span><br><span class="line">    @numbers</span><br><span class="line">    A=A+<span class="number">1</span>  <span class="comment">// numbers++, get the next one in array</span></span><br><span class="line">    @x</span><br><span class="line">    M=M+<span class="number">1</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetis C7-汇编编译器</title>
    <url>/post/feff5e0b/</url>
    <content><![CDATA[<h1 id="汇编编译器-Assembler"><a href="#汇编编译器-Assembler" class="headerlink" title="[汇编编译器 Assembler]"></a>[汇编编译器 Assembler]</h1><p>​        我们已经完成了计算机的<strong>硬件平台(hardware platform)</strong>，此后我们将集中探讨计算机的<strong>软件阶层体系(software hierarchy)</strong>，直到最后为简单的面向对象编程语言开发<strong>编译器</strong>和<strong>基本的操作系统</strong>为止。</p>
<p>​        在软件阶层体系中，最基本的模块就是<strong>汇编编译器(assembler)</strong>。在C4中介绍了机器语言的两种表达形式，即<strong>汇编形式</strong>和<strong>二进制形式</strong>。在这里我们将了解编译器如何系统地将汇编语言编写的程序<strong>翻译</strong>成二进制形式。</p>
<p>​        因为<strong>符号化汇编命令(symbolic assembler commands)</strong>与其对应的二进制代码之间的关系很简单，唯一的复杂性在于：<strong>允许汇编程序使用符号来指代内存地址</strong>。我们希望通过编译器来管理这些<strong>用户自定义的符号(symbols)</strong>，将它们解析成物理内存地址。一般使用<strong>符号表(symbol table)</strong>来完成这个任务，这种符号表是经典的数据结构，应用在很多软件编译过程中。</p>
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><h4 id="1-符号-Symbols"><a href="#1-符号-Symbols" class="headerlink" title="1. 符号(Symbols)"></a>1. 符号(Symbols)</h4><p>​        符号在汇编程序通常有两个用途：</p>
<ul>
<li><p><strong>变量(Variables)</strong>：<strong>程序员可以使用符号的变量名称，翻译器会“自动地”为其分配内存地址</strong>。这些地址的实际值是没有意义的，只要在程序的整个编译过程中，<strong>每个符号始终被指代为同一内存地址</strong>即可。</p>
</li>
<li><p><strong>标签(Labels)</strong>：<strong>程序员可以在程序中用符号来标注不同的位置</strong>。比如，可以用标签<code>loop</code>来指代特定代码段的起始位置。程序中的其它指令就可以有条件或无条件地执行<code>goto loop</code>指令。</p>
<p>​        用户定义的<strong>变量名称</strong>和<strong>符号标签(symbolic labels)</strong>，与实际内存地址的映射则不是这么简单。确定符号地址的任务是从用硬件层级上升到软件层级过程中遇到的第一个挑战。</p>
</li>
<li><p><strong>符号解析(Sybol Resolution)</strong>：如下图，该程序包含4个用户自定义的符号：2个变量名称(<strong>i</strong>和<strong>sum</strong>)；2个标签(<strong>loop</strong>和<strong>end</strong>)。<strong><em>如何系统的将符号转换为不含符号的代码呢？</em></strong>制定两个任意性的<strong>规则</strong>：</p>
<ol>
<li><p><strong>翻译后的代码</strong>将被存储到计算机中<strong>起始地址为0的内存</strong>中；</p>
</li>
<li><p><strong>变量</strong>将会被分配到<strong>起始地址为1024的内存</strong>中（这些规则依赖于特定的目标硬件平台）。</p>
</li>
</ol>
<ul>
<li>数据结构处理方式：构建一个<strong>符号表(symbol table)</strong>. 在源代码中，每遇到一个新符号<strong><em>xxx</em></strong>，就在符号表中添加一行<strong>(<em>xxx</em></strong>, <strong><em>n</em>)</strong>。<em>n</em>是分配给对应符号的内存地址。符号表建立完成后，利用他来将程序翻译成无符号的版本。</li>
</ul>
</li>
</ul>
<p><img src="/post/feff5e0b/image-20200905143509717.png" alt="符号解析"></p>
<p>​    如上，符号表的各项键值对 对应了源代码中的自定义符号。只是最后一句需要解释一下，代表了无限循环<code>end:  goto end</code>.</p>
<p>​    其中，有3个要点需要说明。</p>
<ol>
<li>我们定义的变量分配的规则决定了能运行的程序<strong>最多</strong>只能有1024条指令。为了不使实际程序（如操作系统）<strong>溢出</strong>到符号表，存储变量的基地址应该<strong>更远</strong>一些。<strong>(base address&gt;&gt;1024)</strong></li>
<li><strong>“每条源代码命令映射到一个字(word)”</strong>的假设过于天真。一般情况下，某些汇编指令(<code>if i = 101 goto end</code>)会被翻译成几条机器指令，因此每条源代码会占据好几个内存单元。为了解决此问题，翻译程序会记录每条源代码产生的字的个数，然后相应的更新它的<strong>“指令内存计数器(Insvachion memory counter)”</strong>.</li>
<li>对于<strong>“每个变量用一个单一的内存单元来表示”</strong>的假设可能也不实际。编程语言支持<strong>多种类型的变量</strong>，各自占用着<strong>不同的内存空间</strong>。因此，当为变量分配内存空间时，翻译程序必须考虑他们的<strong>数据类型</strong>和<strong>硬件内存单元的宽度</strong>。</li>
</ol>
<h4 id="2-汇编编译器-Assembler"><a href="#2-汇编编译器-Assembler" class="headerlink" title="2.汇编编译器(Assembler)"></a>2.汇编编译器(Assembler)</h4><p>​        汇编编译器将汇编程序翻译成计算机的二进制机器语言，才能被计算机执行。生成的代码被加载到计算机的内存中然后被硬件执行。</p>
<p>​        可见，汇编编译器实际上主要是个文本处理程序，设计目的是提供翻译服务。因此我们要有完整的汇编语法说明文档和相应的二进制代码。有了这样的约定（通常称为机器语言规范），让每个符号命令执行下面的任务：</p>
<ul>
<li><p>解析出符号命令内在的<strong>域</strong>。（解析）</p>
</li>
<li><p>对于每个域，<strong>产生</strong>机器语言中相应的<strong>位域</strong>。（代码生成）</p>
</li>
<li><p>用内存单元的<strong>数字地址</strong>来<strong>替换</strong>所有的<strong>符号引用</strong>。（符号处理）</p>
</li>
<li><p>将二进制码<strong>汇编</strong>成完整的机器指令。（汇编）</p>
<p>其中三个任务（解析、代码生成和汇编）是相当容易实现的。而符号处理则相对复杂，是汇编编译器的主要功能。(——符号表)</p>
</li>
</ul>
<h3 id="Hack-汇编到二进制的翻译规范详述"><a href="#Hack-汇编到二进制的翻译规范详述" class="headerlink" title="[Hack 汇编到二进制的翻译规范详述]"></a>[Hack 汇编到二进制的翻译规范详述]</h3><p>​        总的来说，Assembler是一个翻译挑战，从源语言到目标语言。为了做到这点，我们必须知道两种语言的语法。</p>
<h4 id="1-语法规约和文件格式"><a href="#1-语法规约和文件格式" class="headerlink" title="1. 语法规约和文件格式"></a>1. 语法规约和文件格式</h4><p><strong>文件名称</strong>        习惯上，二进制机器码程序后缀名为“Hack”，汇编代码程序的后缀名为“asm”。因此，Prog.asm文件会被汇编翻译器翻译成Prog.hack文件。</p>
<p><strong>二进制代码(.hack)文件</strong>        二进制代码文件由<strong>文本行</strong>组成。<strong>第一行由16个0/1组成的ASCⅡ码构成一个序列，该序列对一个单一的16-位机器语言指令进行编码</strong>。当机器语言程序被<strong>加载</strong>进计算机的<strong>指令内存</strong>中时，文件的<strong>第n行二进制码</strong>被存储到<strong>地址为n</strong>的指令内存单元内（设命令行的技术和指令内存的起始地址都是从0开始）。    </p>
<p><img src="/post/feff5e0b/memory_layout.png" alt="内存布局"></p>
<p><strong>汇编语言(.asm)文件</strong>        由<strong>文本行</strong>组成，每一行代表一条<strong>指令(instrution)</strong>或者一个<strong>符号声明(symbol declaration)</strong>.</p>
<ul>
<li><strong>指令(Instrution)</strong>        A-指令或C-指令</li>
<li><strong>(Symbol)</strong>        <strong>该伪命令将Symbol绑定到该程序中下一条命令的地址上</strong>。因为它并<strong>不产生机器代码</strong>，所以称之为<strong>“伪代码(pseudo-command)”.</strong>      (eg: (END))</li>
</ul>
<p>（下面的语法仅适用于汇编程序）</p>
<p><strong>常数(constants)和符号(Symbols)</strong>        常数必须是<strong>非负</strong>的，用<strong>十进制</strong>表示。用户定义的符号可以由字母、数字、下划线(_)、点(.)、美元符号($)和冒号(:)组成的字母序列，但是<strong>不能以字母开头</strong>。</p>
<p><strong>注释</strong>        以两条斜线(//)开头的文本行，注释不会被计算机执行。</p>
<p><strong>空格</strong>        空格字符和空行被忽略。</p>
<p><strong>大小写习惯</strong>        <strong>所有的汇编助记符必须大写</strong>。用户<strong>自定义</strong>的符号和变量是<strong>区分大小写</strong>的。一般的习惯是，<strong>标签(labels)大写</strong>，<strong>变量名称小写</strong>。</p>
<h4 id="2-指令"><a href="#2-指令" class="headerlink" title="2. 指令"></a>2. 指令</h4><p>Hack计算机包含两种指令类型，分别称为<strong>寻址指令(A-指令, Addressing Instrution)</strong>和<strong>计算指令(C-指令, Compute Instruction)</strong>。指令格式如下：</p>
<p><img src="/post/feff5e0b/image-20200906092445956.png" alt="A-指令"></p>
<p><img src="/post/feff5e0b/image-20200906092528300.png" alt="C-指令"></p>
<h4 id="3-符号"><a href="#3-符号" class="headerlink" title="3. 符号"></a>3. 符号</h4><p>Hack汇编命令通过使用<strong>常数</strong>或<strong>符号</strong>来指代<strong>内存单元<em>(地址)</em></strong></p>
<blockquote>
<p>从C6开始，若未经特殊说明，内存单元可以用名词“地址”代替，如变量Value的地址是0X5B46，这包含两层意思：</p>
<p>1）说明Value的物理地址是数值0X5B46；</p>
<p>2）<strong>Value代表的变量存储在地址为0X5B46的内存单元中</strong>。</p>
<p>MOV  AX，Value   等价于  MOV  AX，(0X5B46)</p>
</blockquote>
<p>汇编程序中的符号来源于三个方面。</p>
<p><strong>预定义符号(Predefined Symbols)</strong>        任何Hack程序允许使用下面的预定义符号。</p>
<p><img src="/post/feff5e0b/image-20200906093259952.png" alt="预定义符号"></p>
<p><strong>标签符合(Labels Symbols)</strong>        伪命令(Xxx)定义符号Xxx来指代存有程序中下一条命令在指令内存中的地址。每个标签只能定义一次，可以在任何地方使用，甚至在定义之前。有两种实现方法：</p>
<ol>
<li><p>先存储Symbol到符号表(但不知道它在哪里)，当真正遇到正确地址的定义时补上。</p>
</li>
<li><p>第一次遍历程序的Labels和对应的位置，并存储在符号表，第二次遍历把Labels换成Address。(更简单)</p>
</li>
</ol>
<p><strong>变量符号(Variable Symbols)</strong>        任何出现在汇编程序中的符号Xxx，如果它<strong>不是预定义符号也没有在其他地方使用(Xxx)命令</strong>，那么它就被当作是变量。每遇到一个新的变量时，就把它<strong>连续地映射到从16开始的内存中去</strong>。</p>
<h3 id="基本的汇编编译器逻辑"><a href="#基本的汇编编译器逻辑" class="headerlink" title="[基本的汇编编译器逻辑]"></a>[基本的汇编编译器逻辑]</h3><p><img src="/post/feff5e0b/image-20200906095023883.png" alt="汇编编译器的逻辑"></p>
<p>汇编编译器 <strong>(Assembler模块)</strong>循环执行：</p>
<ul>
<li>从输入的文本文件中读取下一个汇编语言的命令（无需记住上一个命令）</li>
<li>把命令分为不同的部分</li>
<li>每个部分都可以用我们的语言指定的一种独特的方式翻译成二进制代码</li>
<li>将这些代码合并为一个机器语言命令（得到的二进制代码直接等同于汇编语言）</li>
<li>输出这个机器语言命令</li>
</ul>
<p>循环直到 文末(EOF)</p>
<p>第一个问题：如何从输入的文本文件中读取下一个汇编语言的命令？</p>
<p>​        唯一的<strong>困难</strong>是我们可能需要跳过所有的注释、空格和空行。我们需要<strong>确保</strong>我们读<strong>取了下一个命令，而不是注释、空格和空行</strong>。</p>
<p>​        读取当前命令，并将其各部分放入某种字符串变量中，变成了一些我们以后可以处理的字符数组。</p>
<p>第二个问题：如何把命令分为不同的部分？</p>
<p>​        利用一些语法，把原来的字符串分成多个部分，其中涉及到一些简单的字符串操作。</p>
<p>第三个问题：如何把ASM翻译成二进制代码？</p>
<p><img src="/post/feff5e0b/image-20200906111607583.png" alt="翻译" style="zoom:67%;"></p>
<p>​        通过查询符号表根据<strong>命令和符号</strong>找到出对应的二进制代码，而数字则直接转换成二进制。</p>
<p>第四个问题：如何将二进制代码合并？</p>
<p><img src="/post/feff5e0b/image-20200906111849947.png" alt="合并" style="zoom:67%;"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="[实现]"></a>[实现]</h3><p>实现计划：</p>
<ol>
<li>我们将从编写一个基本的汇编程序开始，它可以处理那些没有符号的程序。（推迟对符号的处理，直接忽略所有的“空白”）</li>
<li>我们将会发展出处理和使用符号的能力。</li>
<li>最后，使用这个功能，我们会返回到基本的汇编程序<strong>(1.)</strong>，然后将其拓展为通用的汇编程序，它可以翻译任何给定的程序，用Hack汇编代码写成二进制代码。</li>
</ol>
<h4 id="1-1-翻译A-指令"><a href="#1-1-翻译A-指令" class="headerlink" title="1.1 翻译A-指令"></a>1.1 翻译A-指令</h4><p><img src="/post/feff5e0b/image-20200906210200090.png" alt="A-指令" style="zoom: 67%;"></p>
<p>​        当<code>value</code>是非负的十进制常数，或者一个符号指向这样的常数时，就是A-指令。二进制语法<code>0-valueBinary</code>。</p>
<p>​        翻译成二进制码：</p>
<ul>
<li>如果<code>value</code>是十进制常数，那么我们就计算该值的二进制码。为了把它变成一个15位的常数，我们需要加多少个0。</li>
<li>如果是<code>symbol</code>，迟点解决。</li>
</ul>
<h4 id="1-2-翻译C-指令"><a href="#1-2-翻译C-指令" class="headerlink" title="1.2 翻译C-指令"></a>1.2 翻译C-指令</h4><p><img src="/post/feff5e0b/image-20200906211938885.png" alt="image-20200906211938885" style="zoom:67%;"></p>
<p>​        由汇编编译器的解析器，将C-指令分成<code>dest</code>、<code>comp</code>和<code>jump</code>三个部分解析。解析器会获得一个源语句或汇编指令，将它分为三个单独的字段，然后我们可以单独检查每个字段。</p>
<p>​        当设计到C-指令的二进制形式，我们初始化我们正构建的字符串开头有<strong>3个<code>1</code></strong>；</p>
<p>​        接下来的7个位对应于<code>comp</code>域</p>
<p><img src="/post/feff5e0b/image-20200906213014717.png" alt="image-20200906213014717" style="zoom:67%;"></p>
<p>​        根据<code>D+1</code>在表中查询，可得<code>a=0, c=011111</code>，然后把它附加到我逐渐构建的字符串。</p>
<p>​        指令的下一个部分与目标相对应。</p>
<p><img src="/post/feff5e0b/image-20200906213749551.png" alt="C-指令 dest" style="zoom:67%;"></p>
<p>​        根据<code>MD</code>查询相关的表，可得<code>MD=011</code>，并将其附加到逐渐构建的字符串。</p>
<p>​        指令的最后一部分对应于跳转指令。</p>
<p><img src="/post/feff5e0b/image-20200906214014761.png" alt="C-指令 jump" style="zoom:67%;"></p>
<p>​        根据无跳转查询表，可得<code>null=000</code>，附加到字符串，最后构建完成汇编语句对应的二进制码。</p>
<p>​        正如上述，我们在这里所做的一切都是文本处理、字符串处理。我得到一个源字符串，通过特定的解析方式，我在一个渐进的过程中构建目标字符串，每一种高级语言都有执行字符串处理的能力。</p>
<h4 id="1-3-要构建的汇编器的完整逻辑"><a href="#1-3-要构建的汇编器的完整逻辑" class="headerlink" title="1.3 要构建的汇编器的完整逻辑"></a>1.3 要构建的汇编器的完整逻辑</h4><p><img src="/post/feff5e0b/image-20200906214901531.png" alt="image-20200906214901531" style="zoom:67%;"></p>
<p>对于每个指令：</p>
<ul>
<li><p>解析指令：将它分成多个模块。A-：<code>0-value</code>；C-：<code>111a cccc ccdd djjj</code></p>
</li>
<li><p>A-指令：将十进制常数翻译成二进制码；</p>
</li>
<li><p>C-指令：生成指令中各个域对应的二进制码；</p>
<p>将翻译好的二进制码汇编成16-位的机器指令</p>
</li>
<li><p>将16-位的机器指令写入输出文件。</p>
</li>
</ul>
<h3 id="开发一个Hack汇编器"><a href="#开发一个Hack汇编器" class="headerlink" title="[开发一个Hack汇编器]"></a>[开发一个Hack汇编器]</h3><p><img src="/post/feff5e0b/image-20200906220942772.png" alt="开发Hack汇编器" style="zoom:50%;"></p>
<p>规定：</p>
<ul>
<li>开发一个Hack汇编编译器程序，将Hack汇编程序翻译成可执行的Hack二进制码</li>
<li>源程序写在后缀为<code>Prog.asm</code>的文本文件中</li>
<li>生成的二进制码写入到后缀为<code>Prog.hack</code>的文本文件中</li>
<li>假设：<code>Prog.asm</code>无错误检测</li>
</ul>
<p>用法：</p>
<p>命令行语法。该命令应该创建（或覆盖）一个可原封不动在Hack计算机中执行的<code>Xxx.hack</code>文件。</p>
<p>​        构建编译器分为两个阶段。第一阶段，编写汇编编译器(<strong>Paeser模块</strong>和<strong>Code模块</strong>)来翻译<strong>无符号汇编程序</strong>。第二阶段，拓展成为具有<strong>符号处理能力</strong>的汇编编译器。</p>
<h4 id="1-无符号程序的汇编编译器"><a href="#1-无符号程序的汇编编译器" class="headerlink" title="1. 无符号程序的汇编编译器"></a>1. 无符号程序的汇编编译器</h4><ul>
<li>输入的<code>Prog.asm</code>程序不包含符号。A-指令<code>@Xxx</code>必须是十进制非负常数，不能是符号。</li>
<li>不能包含符号命令，<code>(Xxx)</code>不可用。</li>
</ul>
<ol>
<li>打开名为<code>Prog.hack</code>的输出文件</li>
<li>开始处理<code>Prog.asm</code>文件的每一行汇编指令  (Loop)<ul>
<li>对于C-指令，程序将翻译后的指令域的二进制码连接到一个单一的16-位字上，并将其写入<code>Prog.hack</code>文件</li>
<li>对于A-指令，程序将语法分析器返回地十进制常数翻译成对应的二进制表示，并将得到的16-位字写入<code>Prog.hack</code>文件</li>
</ul>
</li>
</ol>
<p><em>Parser.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理.asm文件的指令  eg: @常数, AMD comp JGT/..  (AMD=)(comp运算)(;JGT/...), (Symbol)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 扫描器(Scanner对象)存储输入流，准备语法分析</span></span><br><span class="line">    <span class="comment">// String对象存储当前行的指令</span></span><br><span class="line">    <span class="comment">// 构造器：为汇编编译器构造语法分析器的实例，传入Scanner对象(而Scanner对象由汇编编译器需要编译的文件构造)</span></span><br><span class="line">    <span class="comment">// API:</span></span><br><span class="line">    <span class="comment">// boolean hasMoreCommands(): 扫描器.hasNextLine</span></span><br><span class="line">    <span class="comment">// void advance(): 当前指令.nextLine</span></span><br><span class="line">    <span class="comment">// enum commandType: 三种指令类型</span></span><br><span class="line">    <span class="comment">// void skipSpacesAndComments(): 注释:subString()截掉&#x27;//&#x27;之后的内容, 空白:replace()替换所有空格和制表符</span></span><br><span class="line">    <span class="comment">// int Length(): 当前指令长度</span></span><br><span class="line">    <span class="comment">// commandType CommandType(): 根据当前指令，返回判断得出的指令类型。判断出A-指令和伪指令，剩下的就是C-指令</span></span><br><span class="line">    <span class="comment">// C-指令 API</span></span><br><span class="line">    <span class="comment">// String dest(): 将当前指令分割，返回当前C-指令的dest助记符</span></span><br><span class="line">    <span class="comment">// String comp(): 将当前指令分割，返回当前C-指令的comp助记符</span></span><br><span class="line">    <span class="comment">// String jump(): 将当前指令分割，返回当前C-指令的jump助记符</span></span><br><span class="line">    <span class="comment">// A-指令 API</span></span><br><span class="line">    <span class="comment">// String symbol(): 直接返回@之后的内容，无符号: 必为非负十进制常数</span></span><br><span class="line">    <span class="comment">// void close(): 关闭资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Code.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入一个域的助记符，返回域对应的二进制码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Code</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C-指令</span></span><br><span class="line">    <span class="comment">// comp域</span></span><br><span class="line">    <span class="comment">// HashMap&lt;String, String&gt;对象，存储comp域助记符到二进制码的转换表</span></span><br><span class="line">    <span class="comment">// String comp(): 错误处理,若HashMap对象不存在该comp域指令. 存在则根据HashMap返回comp域助记符**对应的二进制码**</span></span><br><span class="line">    <span class="comment">// dest域, 无需表</span></span><br><span class="line">    <span class="comment">// void checkDest(): 根据dest域助记符判断是否需要存储到寄存器，并往对应的二进制码添加(0/1)</span></span><br><span class="line">    <span class="comment">// String dest(): 用StringBuilder对象存储dest二进制形式，调用checkDest()得到dest正确的二进制表达式，并返回</span></span><br><span class="line">    <span class="comment">// jump域</span></span><br><span class="line">    <span class="comment">// String jump(): 根据jump域助记符，返回jump对应得二进制表达式</span></span><br><span class="line">    <span class="comment">// A-指令</span></span><br><span class="line">    <span class="comment">// String binary(): 对常数的大小进行错误判断，根据十进制常数返回二进制的对应形式，并填充0直至二进制码为15位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Assembler.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assembler</span></span>&#123;</span><br><span class="line">    <span class="comment">// Parser getParser(): 根据文件名创建Parser对象</span></span><br><span class="line">    <span class="comment">// boolean isValidName(): 判断文件是否为.asm文件</span></span><br><span class="line">    <span class="comment">// int getInt(): 返回三种字符串对应的十进制常数</span></span><br><span class="line">    <span class="comment">// main(): </span></span><br><span class="line">    <span class="comment">// 1.解析命令行: (java 包名/类名 .asm文件位置)</span></span><br><span class="line">    <span class="comment">//                                (0)</span></span><br><span class="line">    <span class="comment">// 2.错误处理，命令参数必须是是两个，文件必须是.asm文件; 获得文件名</span></span><br><span class="line">    <span class="comment">// 3.根据文件名实例化Parser对象</span></span><br><span class="line">    <span class="comment">// 4.创建同名的输出流文件.hack，并存储在PrintWriter对象</span></span><br><span class="line">    <span class="comment">// loop</span></span><br><span class="line">    <span class="comment">// 5.循环利用parser解析指令，当前输入还有更多指令时，指令跳向下一行，跳过所有的&quot;空白&quot;，(如果此时指令长度为0，则下一个循环)，否则，创建出Parser对象的CommandType类型对象.</span></span><br><span class="line">    <span class="comment">// 6.根据CommandType对象，进行三种指令的处理</span></span><br><span class="line">    <span class="comment">// C-指令：3个区域分别用Code调用类静态方法，获取3个区域的二进制码，并往输出流对象PrintWriter写入&quot;111 comp dest jump&quot;</span></span><br><span class="line">    <span class="comment">// 伪指令：不处理</span></span><br><span class="line">    <span class="comment">// A-指令：用Code调用类静态方法获取A-指令的二进制码，并输出流对象PrintWriter写入&quot;0 binary&quot;</span></span><br><span class="line">    <span class="comment">// 如果Parser对象判断还有指令则创建新行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-完整的汇编编译器"><a href="#2-完整的汇编编译器" class="headerlink" title="2. 完整的汇编编译器"></a>2. 完整的汇编编译器</h4><h5 id="SymbolTable模块"><a href="#SymbolTable模块" class="headerlink" title="SymbolTable模块"></a>SymbolTable模块</h5><p>​        因为Hack指令可能包含符号，作为翻译的一部分，必须为这些符号确定<strong>实际的地址</strong>。</p>
<p>​        我们用<strong>符号表(symbol table)</strong>来完成，符号表用来建立和维护符号与地质之间的关联。<strong>哈希表(hash table)</strong>就是表示这种关系的经典数据结构之一。</p>
<p><img src="/post/feff5e0b/image-20200910212336715.png" alt="symbolTable"></p>
<h5 id="有符号程序的汇编编译器"><a href="#有符号程序的汇编编译器" class="headerlink" title="有符号程序的汇编编译器"></a>有符号程序的汇编编译器</h5><p>​        有效的方法之一是，从头至尾地读取两次代码。</p>
<p>​        Hack语言有三种类型的符号：预编译符号(predefined symbols)，标签(labels)和变量(variables)。符号表应该包含并处理所有这些符号。</p>
<p>​        <strong>初始化</strong>        创建符号表；根据下表，用所有预定义符号和他们预分配的RAM地址对符号表进行初始化。</p>
<p><img src="/post/feff5e0b/image-20200910212821490.png" alt="预定义符号表"></p>
<p>​        <strong>第一遍读取阶段</strong>        该阶段主要是<strong>在符号表建立每条命令及其对应的地址</strong>。处理程序的每一行时，利用数字来记录ROM地址——当前指令最终将被加载到这个地址中。每次遇到一条<strong>伪指令<em>(Xxx)</em></strong>时，在<strong>符号表</strong>上加一个新条目来<strong>将<em>Xxx</em>与最终用于存储程序中下一条指令的ROM地址关联</strong>。此阶段所有标记和他们的ROM地址被加入到符号表中。</p>
<p>​        <strong>第二遍读取阶段</strong>        重新对每一行指令进行语法分析，每次遇到<strong>符号化A-指令</strong>，就在符号表中查找<strong><em>Xxx</em></strong>。如果在符号表中找到了该符号，就<strong>用其对应的地址来替换该符号与完成指令的翻译</strong>。如果在符合表中<strong>没找到该符号</strong>，那么它必定代表<strong>变量</strong>。为处理这个变量，<strong>在符号表中添加<em>(Xxx, n)</em>，这里<em>n</em>代表下一个可用的个RAM地址</strong>。分配的RAM地址是连续数字，从地址16开始。(紧接着预定义符号之后)</p>
<p><img src="/post/feff5e0b/image-20200910223225858.png" alt="image-20200910223225858" style="zoom:67%;"></p>
<p><em>Parser.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span></span>&#123;</span><br><span class="line">    <span class="comment">// Modify</span></span><br><span class="line">    <span class="comment">// String symbol(): 增加@Variable和(Symbol)的处理。@..返回处理统一，不变；而(Symbol)，只返回Symbol</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>SymbolTable.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Symboltable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 符号表：HashTable&lt;String, Integer&gt;</span></span><br><span class="line">    <span class="comment">// 当前更新变量的地址：16(init)</span></span><br><span class="line">    <span class="comment">// SymbolTable(): 初始化HashTable，并初始化预定义的符号</span></span><br><span class="line">    <span class="comment">// void addEntry(String symbol, int address)</span></span><br><span class="line">    <span class="comment">// boolean contains(String symbol): 是否包含Key</span></span><br><span class="line">    <span class="comment">// int getAddress(String symbol): 根据Key获得Address</span></span><br><span class="line">    <span class="comment">// int getNextAddAndIncrement(): 获取当前更新变量的地址，并令地址加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Assembler.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assembler</span></span>&#123;</span><br><span class="line">    <span class="comment">// Add</span></span><br><span class="line">    <span class="comment">// 添加第一次遍历：主要是构建符号表，将伪指令添加到符号表</span></span><br><span class="line">    <span class="comment">// 记录当前命令被加载到的地址</span></span><br><span class="line">    <span class="comment">// loop</span></span><br><span class="line">    <span class="comment">// 1.循环利用parser解析指令，当前输入还有更多指令时，指令跳向下一行，跳过所有的&quot;空白&quot;，(如果此时指令长度为0，则下一个循环)，否则，创建出Parser对象的CommandType类型对象.</span></span><br><span class="line">    <span class="comment">// 如果指令类型是伪指令，将(符号,当前程序指令地址+1)添加到符号表; 否则当前程序指令地址自增</span></span><br><span class="line">    <span class="comment">// 关闭parser资源</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Modify</span></span><br><span class="line">    <span class="comment">// int getInt(String input, SymbolTable symbolTable): 当input是符号化常数，转换为int并返回; 若不是，处理数字格式异常，(只能是 预定义变量 / 用户自定义变量).</span></span><br><span class="line">    <span class="comment">// - 预定义变量: 返回 根据input符号返回符号表对应的地址</span></span><br><span class="line">    <span class="comment">// - 用户自定义变量: 将(符号，符号表中的当前更新变量的地址)，并返回地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
        <tag>Assembly</tag>
        <tag>Hack汇编编译器</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetis C7-虚拟机Ⅰ堆栈运算</title>
    <url>/post/90466d95/</url>
    <content><![CDATA[<h1 id="虚拟机Ⅰ-堆栈运算-Stack-Arithmetic"><a href="#虚拟机Ⅰ-堆栈运算-Stack-Arithmetic" class="headerlink" title="[虚拟机Ⅰ: 堆栈运算 Stack Arithmetic]"></a>[虚拟机Ⅰ: 堆栈运算 Stack Arithmetic]</h1><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><h4 id="1-虚拟机范型"><a href="#1-虚拟机范型" class="headerlink" title="1.虚拟机范型"></a>1.虚拟机范型</h4><p>​        高级语言程序能够在计算机上运行之前，它必须被翻译成计算机的机器语言，即<strong>编译</strong>。如果每种高级语言被编译成对应于目标硬件平台的机器语言，那么我们必须维护多个版本的代码，这是一种无尽的折磨…</p>
<p><img src="/post/90466d95/image-20200911163424313.png" alt="pain" style="zoom:67%;"></p>
<p>​        减少高级语言和机器语言<strong>依赖性</strong>的方法之一是将编译过程分为<strong>两个几乎独立的阶段</strong>。基本思想：中间代码运行在<strong>虚拟机(virtual Machine)</strong>上，而不是正式的硬件平台。</p>
<p><img src="/post/90466d95/image-20200911163242720.png" alt="virtualMachine instance"></p>
<p>​        第一个阶段：高级程序被解析出来，其命令被翻译成中间结果。第二个阶段：这些中间结果被进一步翻译成目标硬件的机器语言。当然，两个编译阶段之间的接口<strong>(接口就是中间处理步骤的精确定义)</strong>必须仔细地进行设计。</p>
<p>​        原来作用为一个独立程序的编译器被分成两个独立的程序。第一个程序，编译器(Compiler)，将高级代码翻译成中间VM指令；第二个程序将这个<strong>VM代码翻译成目标计算机硬件平台的机器语言</strong>。</p>
<p>​        Java编译器也是<strong>两层(two-tiered)结构</strong>，它生成运行在JVM虚拟机上(也称为Java运行时环境，<strong>Java Runtime Enviroment</strong>)的byte-code语言。</p>
<p>​        明确且正式的虚拟机语言概念有很多务实的优点。首先，仅需要<strong>替换虚拟机实现部分</strong>（有时候称为编译器的后端程序， backend）就能相对容易地<strong>得到不同硬件平台的编译器</strong>。因此，虚拟机在不同硬件平台之间的<strong>可移植性</strong>可以实现代码效率、硬件成本和程序开发难度之间的权衡。其次，很多语言的编译器能够<strong>共享VM后端程序</strong>，允许<strong>代码共享和语言互用性</strong>。比如，某种高级语言善于科学计算，而另一种在处理用户接口方面很突出。<strong>如果把两种语言编译到通用的VM层，那么通过使用约定的调用语法，其中一种语言的程序就能够很容易地调用另一种语言的程序</strong>。</p>
<p>​        虚拟机方法的另一个优点是<strong>模块化</strong>。<strong>VM的每一个改善都会立即被所有构建于其上的编译器继承</strong>。同样地，每个安装有VM实现的数字设备都能够受益于现有软件的庞大基础。</p>
<p>​        将高级语言翻译成中间代码的程序可以称为<strong>编译器前端程序</strong>，而将中间代码翻译成机器语言的程序可以称为<strong>编译器后端程序</strong>。</p>
<p>​        比如<code>Java</code>，<code>Java</code>的源码经翻译后形成<code>Byte Code</code>文件，<code>Byte Code</code>文件是运行在<code>Java</code>虚拟机上的，而<code>Byte Code</code>文件经翻译后得到机器语言，机器语言运行在硬件平台上。因此，中间代码运行在虚拟机上，机器语言运行在硬件上。</p>
<p>​        编译器的后端程序负责的是将中间代码翻译成机器语言，所以它与硬件平台的关系性非常大，如果我们需要运行在不同的硬件平台上，那么机器语言就会发生变化，因此后端程序就需要改变，而前端程序不需要改变，因而虚拟机可以使语言很方便的进行<strong>跨平台使用</strong>。</p>
<p>​        在此虚拟机中，虚拟机语言共包含4种类型的指令：算术指令，内存访问指令，程序流程控制指令和子程序调用指令。</p>
<p>​        </p>
<h4 id="2-栈式计算机模型"><a href="#2-栈式计算机模型" class="headerlink" title="2.栈式计算机模型"></a>2.栈式计算机模型</h4><p>​        在VM操作中的操作数和结果应该驻留在哪里。也许“最干净利落”的方法是将其放在<strong>栈式(stack)</strong>数据结构。</p>
<h5 id="栈式计算机模型的实现"><a href="#栈式计算机模型的实现" class="headerlink" title="栈式计算机模型的实现"></a>栈式计算机模型的实现</h5><p><img src="/post/90466d95/image-20200913101004893.png" alt="stack machine inplementation" style="zoom:50%;"></p>
<p><em>Logic</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*sp = <span class="number">17</span>;</span><br><span class="line">sp++;</span><br></pre></td></tr></table></figure>
<p><em>Hack assembly</em></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@<span class="number">17</span>;  <span class="comment">// A=17</span></span><br><span class="line">D=A;  <span class="comment">// D=17</span></span><br><span class="line"><span class="comment">// *SP=D</span></span><br><span class="line">@SP;  <span class="comment">// A = SP</span></span><br><span class="line">A=M;  <span class="comment">// A = Memory[SP]: indirect address</span></span><br><span class="line">M=D;  <span class="comment">// M = D,( M is (*SP) )</span></span><br><span class="line"><span class="comment">// SP++</span></span><br><span class="line">@SP;</span><br><span class="line">M=M+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="from-VM-to-Assembly"><a href="#from-VM-to-Assembly" class="headerlink" title="[from VM to Assembly]"></a>[from VM to Assembly]</h3><p><strong><em>push &amp; pop</em> implementation:</strong></p>
<p><img src="/post/90466d95/image-20200923124849383.png" alt="push/pop" style="zoom:67%;"></p>
<p><strong><em>stack</em> implementation</strong></p>
<p><img src="/post/90466d95/image-20200923125313183.png" alt="image-20200923125313183" style="zoom:67%;"></p>
<p><strong><em>implement constant:</em></strong>no <code>pop</code></p>
<p><img src="/post/90466d95/image-20200913111011987.png" alt="implement constant" style="zoom:50%;"></p>
<ul>
<li>不允许存储任何东西到<code>constant</code>段</li>
</ul>
<p><strong>Implementing <em>local</em></strong></p>
<p><img src="/post/90466d95/image-20200913103134064.png" alt="local" style="zoom:50%;"></p>
<p><em>logic</em>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addr = LCL + <span class="number">2</span>;</span><br><span class="line">SP--;</span><br><span class="line">*addr = *SP;</span><br></pre></td></tr></table></figure>
<p><em>implement:</em></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@<span class="number">2</span>;</span><br><span class="line">D=A;</span><br><span class="line">@LCL;</span><br><span class="line">D=M+D;</span><br><span class="line">@addr;</span><br><span class="line">M=D;</span><br><span class="line"><span class="comment">// SP--, SP is a pointer</span></span><br><span class="line">@SP;</span><br><span class="line">A=M;</span><br><span class="line">M=M<span class="number">-1</span>;  <span class="comment">// SP--</span></span><br><span class="line">D=M;  <span class="comment">// D=SP</span></span><br><span class="line">@addr;</span><br><span class="line">A=M;  <span class="comment">// A=addr, M=*addr</span></span><br><span class="line">M=D;</span><br></pre></td></tr></table></figure>
<h5 id="summary"><a href="#summary" class="headerlink" title="summary:"></a>summary:</h5><p>previous <em>Logic</em> is <code>pop local i</code>, and <code>push local i</code> is similiar.</p>
<p><code>pop local i</code>is to<code>addr = LCL + i, SP--, *addr = *SP</code></p>
<p><code>push local i</code> is to<code>addr = LCL + i, *SP = *addr, SP++</code></p>
<p><img src="/post/90466d95/image-20200913104413496.png" alt="summary" style="zoom:50%;"></p>
<p><strong>implement <em>lcoal, argument, this, that</em></strong>:</p>
<p><img src="/post/90466d95/image-20200923151620070.png" alt="image-20200923151620070" style="zoom:67%;"></p>
<ul>
<li>将函数方法局部变量和参数变量映射到<code>local</code>和<code>argument</code>段</li>
<li>将函数方法正在处理的对象属性字段和数组项(条目)映射到<code>this</code>和<code>that</code>段</li>
</ul>
<p><img src="/post/90466d95/image-20200913144322327.png" alt="four segment" style="zoom: 80%;"></p>
<p><code>local</code>, <code>argument</code>, <code>this</code> 和 <code>that</code>都是同样的实现，只需要将<code>segment</code>替换就可以得到另一种。</p>
<script type="math/tex; mode=display">
segment = \{lcoal, argument, this, that\}</script><p><strong><em>implement static</em></strong>:class level variable</p>
<p><img src="/post/90466d95/image-20200913150214722.png" alt="static-variable" style="zoom: 80%;"></p>
<p>​    挑战：<code>static</code>变量应该对程序中的所有函数方法可见</p>
<p>​    解决方法：将其存储在<code>global space</code>全局段中</p>
<ul>
<li>VM翻译器必须翻译每一个VM指向的<code>static i</code>(in the file <em>Foo.vm</em>)到Hack汇编程序的<code>Foo.i</code></li>
<li>遵循Hack汇编的语法，Hack汇编编译器将会把这些reference映射到<code>RAM[16], ... , RAM[255]</code></li>
</ul>
<p><em>implement Memory segment:</em> <code>temp</code></p>
<p><img src="/post/90466d95/image-20200913162748968.png" alt="temp01" style="zoom: 67%;"></p>
<ul>
<li>有些时候，编译器需要用一些中间变量，我们的VM提供了8个类似的变量，存储在<code>temp</code>段</li>
</ul>
<p><img src="/post/90466d95/image-20200913163030397.png" alt="temp02" style="zoom:67%;"></p>
<p>✨✨<code>temp</code>: from VM code to Assembly pseudo code</p>
<p>8个变量存储在<code>RAM[5]~RAM[12]</code></p>
<p><strong><em>implement pointer 0/1</em></strong></p>
<ul>
<li>用于存储<code>this</code>和<code>that</code>段的基地址</li>
<li>当我们编写编译器时，就会知道<code>this</code>的重要性</li>
</ul>
<p><img src="/post/90466d95/image-20200922135814987.png" alt="pointer"></p>
<ul>
<li>通过访问<code>THIS</code>从而访问<code>pointer 0: this</code></li>
<li>通过访问<code>THAT</code>从而访问<code>pointer 1: that</code></li>
</ul>
<h5 id="Summary"><a href="#Summary" class="headerlink" title="Summary:"></a>Summary:</h5><p><img src="/post/90466d95/image-20200922135405740.png" alt="总结1" style="zoom:67%;"></p>
<p><img src="/post/90466d95/image-20200922135427724.png" alt="总结2" style="zoom:67%;"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="[实现]"></a>[实现]</h3><h5 id="综合内存映射分析堆栈运算"><a href="#综合内存映射分析堆栈运算" class="headerlink" title="综合内存映射分析堆栈运算"></a><strong>综合内存映射分析堆栈运算</strong></h5><p>​        做好本章的项目，理解好<strong>内存映射(Memory Map)</strong>是关键，只有理解了内存映射才能知道去哪里取数据，将数据存储到哪里。</p>
<p>​        综合来看，本章的大致思路就是：从<strong>RAM[1]~RAM[4]</strong>中找到<strong>基址</strong>，根据偏移量计算出地址，再去获取数据，并将数据放入堆栈中，在栈区中完成一定操作后，再将结果从堆栈中弹出，放到指定的内存单元（这里实际上还需要计算基址和偏移量）。不同的是<code>temp</code>段，它可以直接在<strong>RAM[5]</strong>上加上偏移量得到存储单元的地址。</p>
<p>​        在整个操作过程中，如果需要使用除D寄存器和A寄存器之外的寄存器暂时存储结果的时候，就会使用到<strong>RAM[13]~RAM[15]</strong>的通用寄存器。</p>
<p><strong><em>Review:</em></strong></p>
<ol>
<li><p><code>@X</code>的意义为把<code>X</code>存入A寄存器，M代表的是<code>Memory[A]</code>，即A映射的地址中所存的值。<br><code>A=M, M=D</code>两句意味着1. A更新为M寄存器存储的数据所指向的地址，2.将D寄存器存储的的数据存入<code>Memory[A]</code>，这是这一章中用得最多的逻辑语句。</p>
</li>
<li><p>在实现<code>eq</code>, <code>gt</code>, <code>lt</code>时，需要用汇编语言实现<code>if</code>分支，这里需要用到两个<code>lable</code>，一个<strong>有条件</strong><code>jump</code>，一个<strong>无条件</strong><code>jump</code>，代码实现为：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compare R1=R2 set result in R3</span></span><br><span class="line">@SP</span><br><span class="line">AM=M<span class="number">-1</span></span><br><span class="line">D=M</span><br><span class="line">A=A<span class="number">-1</span></span><br><span class="line">D=M-D</span><br><span class="line">@RET_TRUE</span><br><span class="line">D;JEQ</span><br><span class="line">@SP         <span class="comment">// need to return False</span></span><br><span class="line">A=M<span class="number">-1</span></span><br><span class="line">M=<span class="number">0</span></span><br><span class="line">@CONTINUE</span><br><span class="line"><span class="number">0</span>;JMP</span><br><span class="line">(RET_TRUE)</span><br><span class="line">@SP        <span class="comment">// need to return True</span></span><br><span class="line">A=M<span class="number">-1</span></span><br><span class="line">M=<span class="number">-1</span></span><br><span class="line">(CONTINUE)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>push segment i</code>的实现：<code>addr = segmentPointer+i, *SP = *addr, SP++</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@segmentPointer</span><br><span class="line">D=M</span><br><span class="line">@index</span><br><span class="line">A=D+A</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>pop segment i</code>的实现：<code>addr = segmentPointer+i, SP--, *addr = *SP</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@segmentPointer</span><br><span class="line">D=M</span><br><span class="line">@index</span><br><span class="line">D=D+A</span><br><span class="line">@R13</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">AM=M<span class="number">-1</span></span><br><span class="line">D=M</span><br><span class="line">@R13</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure>
<p><code>push/pop temp i</code>的实现</p>
<p>push: <code>addr = 5 + i, *SP = *addr, SP++</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@<span class="number">5</span>+index</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>pop:  <code>addr = 5 + i, SP--, *addr = *SP</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@SP</span><br><span class="line">AM=M<span class="number">-1</span></span><br><span class="line">D=M</span><br><span class="line">@<span class="number">5</span>+index</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>push pointer 0/1</code>的实现：<code>*SP = THIS/THAT, SP++</code></p>
<p><code>pop pointer 0/1</code>的实现：<code>SP--, THIS/THAT = *SP</code></p>
<p>与temp类似</p>
</li>
<li><p><code>push/pop static i</code>的实现：<code>@vmName.index ...</code></p>
<p>与temp类似</p>
</li>
<li><p><code>segment</code>和<code>pointer</code>,<code>static</code>,<code>temp</code>段的区别只有：<code>segment</code>段需要额外计算地址</p>
<p>即<code>push/pop local 2</code>，需要计算<code>LCL+2</code>再进行<code>push/pop</code>操作</p>
</li>
</ol>
<p><strong><em>Recommand:</em></strong></p>
<ol>
<li>按照书中推荐的实现步骤，依次实现5个.vm文件的转化</li>
<li>对于每个步骤，先在VM Emulator中运行.vm文件和VME.tst测试文件，通过观察其每一步是如何实现的，深入理解VM语言中<code>push</code>，<code>pop</code>和各个参数的实际意义</li>
<li>手写练习相关Hack汇编语言，对于每个<code>segment</code>段的转换，至少完成一个例子</li>
<li>将转换过程用高级语言实现(Java/Python/…)，测试修改，抽象方法，代码复用</li>
</ol>
<p><img src="/post/90466d95/image-20200922135207520.png" alt="建议实现步骤" style="zoom: 80%;"></p>
<p><img src="/post/90466d95/image-20200922135257496.png" alt="建议实现步骤2" style="zoom:80%;"></p>
<p><strong><em>Tips:</em></strong></p>
<ol>
<li><p>第七章中的机器语言和第六章中的机器语言在结构上略有不同，这一章中的语言更加向高级语言靠拢，在有些地方显得“啰嗦”</p>
<p><code>push constant 7</code>需要如此多的汇编语言实现，但是其中每一句话都是有意义的，所以一定要理解每一句VM语言究竟做了哪些事</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@<span class="number">7</span>          <span class="comment">// constant 7</span></span><br><span class="line">D=A         <span class="comment">// D=7</span></span><br><span class="line">@SP         <span class="comment">// A=栈顶指针=RAM[0]</span></span><br><span class="line">A=M         <span class="comment">// A=Memory[A], A更新为M存储的数据所指向的地址</span></span><br><span class="line">M=D         <span class="comment">// Memory[A]=D</span></span><br><span class="line">@SP         <span class="comment">// A=栈顶指针</span></span><br><span class="line">M=M+<span class="number">1</span>       <span class="comment">// 栈顶指针++</span></span><br></pre></td></tr></table></figure>
<p><code>pop constant 7</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@<span class="number">7</span></span><br><span class="line">D=A</span><br><span class="line">@SP</span><br><span class="line">M=M<span class="number">-1</span></span><br><span class="line">A=M</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>因为一个vm文件中可能会同时出现许多<code>eq</code>，<code>lt</code>这样的涉及<code>jump</code>的语句，如果每一个<code>lable</code>都相同的话，那么<code>lable</code>就会产生重复冲突，如：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@Label</span><br><span class="line">...</span><br><span class="line">(Label)</span><br><span class="line">...</span><br><span class="line">@Label</span><br><span class="line">...</span><br><span class="line">(Label)</span><br></pre></td></tr></table></figure>
<p>当机器到达第一个<code>@lable</code>点时，就会跳到最后一处<code>(lable)</code>。为了避免这种情况，需要给不同的<code>lable</code>依次加上编号，如<code>lable1</code>，<code>lable2</code>，这里可以使用定义全局变量来实现。</p>
</li>
</ol>
<ol>
<li>翻译<code>pop segment index</code>的过程中，首先需要获取<code>segment</code>中存储的地址，然后将<code>index</code>加在这个地址上，得到目标地址。最后把当前<code>SP</code>所指向的地址中的值弹入这个目标地址。这个过程是无法用机器语言直接实现的，因为当中涉及两次调用寄存器D。唯一的解决方案就是在翻译过程中用<code>index</code>控制循环语句，让其自动添加<code>index</code>次的<code>A=A+1</code>，这样的话就免去了多次调用D寄存器的困难。</li>
</ol>
<p><em>Parser.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析.vm文件，封装对输入代码的访问操作</span></span><br><span class="line"><span class="comment"> * 读取vm指令并解析，然后为它各个部分提供方便的访问入口</span></span><br><span class="line"><span class="comment"> * 移除代码中所有空格和注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span></span>&#123;</span><br><span class="line">    <span class="comment">// variable: 文件扫描、当前指令、当前文件名</span></span><br><span class="line">    <span class="comment">// 算术指令的字符串数组</span></span><br><span class="line">    <span class="comment">// Paser模块基本函数：构造函数、更多指令、advance()、commandType()区分指令类型、返回指令第一个参数、返回指令第二个参数</span></span><br><span class="line">    <span class="comment">// 当前指令长度</span></span><br><span class="line">    <span class="comment">// 返回完整指令</span></span><br><span class="line">    <span class="comment">// 设置和获取文件名</span></span><br><span class="line">    <span class="comment">// 关闭资源</span></span><br><span class="line">    <span class="comment">// 判断是否为算术指令  be used in commandType()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>CodeWriter.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeWriter</span></span>&#123;</span><br><span class="line">    <span class="comment">// PrintWriter对象、当前文件名、区分分支标签的数字</span></span><br><span class="line">    <span class="comment">// 构造函数(PrintWriter): 区分分支标签的数字置零</span></span><br><span class="line">    <span class="comment">// 设置翻译出来的的.vm文件的文件名(提取出文件名)</span></span><br><span class="line">    <span class="comment">// writeArithmetic(String command): 将给定的算术操作所对应的汇编写到输出文件</span></span><br><span class="line">    <span class="comment">// writePushAndPop(Parser.Command command, String segment, int index): </span></span><br><span class="line">    <span class="comment">//   1.constant: @idnex, D=A, 将D寄存器的值存储在SP所指向的内存单元, SP++</span></span><br><span class="line">    <span class="comment">//   2.local,argument,this,that: </span></span><br><span class="line">    <span class="comment">//     (1)push: (addr = segmentPointer+i, *SP = *addr, SP++)</span></span><br><span class="line">    <span class="comment">//             获取对应(segmentPointer+i)所指向的地址,M[SP]获取对应的值,SP++</span></span><br><span class="line">    <span class="comment">//     (2)pop: (addr = segmentPointer+i, SP--, *addr = *SP) 需要借助R13存储中间值</span></span><br><span class="line">    <span class="comment">//             获取对应(segmentPointer+i)所指向的地址,SP--,对应的内存单元获取M[SP]的值</span></span><br><span class="line">    <span class="comment">//   3.temp: </span></span><br><span class="line">    <span class="comment">//     (1)push: (*SP = 5+i, SP++)</span></span><br><span class="line">    <span class="comment">//     (2)pop: (SP--, 5+i = *SP)</span></span><br><span class="line">    <span class="comment">//   4.pointer: </span></span><br><span class="line">    <span class="comment">//     (1)push pointer 0/1: (*SP = THIS/THAT, SP++) 根据0/1决定THIS/THAT</span></span><br><span class="line">    <span class="comment">//     (2)pop  pointer 0/1: (SP--, THIS/THAT = *addr)</span></span><br><span class="line">    <span class="comment">//   5.static:</span></span><br><span class="line">    <span class="comment">//     (1)push: (*SP = fileName.index, SP++)</span></span><br><span class="line">    <span class="comment">//     (2)pop: (SP--, fileName.index = *SP)</span></span><br><span class="line">    <span class="comment">// segment: local,argument,this,that  </span></span><br><span class="line">    <span class="comment">//   void writeBasePush(String segmentPointer, int index)</span></span><br><span class="line">    <span class="comment">//   void writeBasePop(String segmentPointer, int index)</span></span><br><span class="line">    <span class="comment">// poiner, static, temp</span></span><br><span class="line">    <span class="comment">//   void writeMappedPush(String location)</span></span><br><span class="line">    <span class="comment">//   void writeMappedPop(String location)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>VMTranslator.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VMTranslator</span></span>&#123;</span><br><span class="line">    <span class="comment">// 需要解析的.vm文件数组链表，处理无.vm文件的情况</span></span><br><span class="line">    <span class="comment">// getParser(File): 根据File文件对象创建Parser对象，与chap6类似</span></span><br><span class="line">    <span class="comment">// printCommandLineErrorAndExit(): 命令行错误处理</span></span><br><span class="line">    <span class="comment">// 判断命令行是否正确，错误则调用函数处理</span></span><br><span class="line">    <span class="comment">// 检查提供的命令行参数，以确定它是有效的文件或目录(1.不存在，2.文件，3.目录)</span></span><br><span class="line">    <span class="comment">// if 1.输出错误</span></span><br><span class="line">    <span class="comment">// else if 2.确定是.vm文件，获取Parser对象，并解析指令参数(路径+文件名)初始化Parser对象的文件名; 调用翻译函数</span></span><br><span class="line">    <span class="comment">// else if 3.将指令参数arg[0]映射路径下的所有文件转换成File对象，并用File[]数组存储; 遍历所有文件，找出.vm文件并根据File获取Parser，依据.vm文件File对象设置Paser对象文件名，设置输出文件名(绝对路径+&#x27;/&#x27;+文件名+&#x27;.asm&#x27;)，调用函数翻译成.asm文件，并把该文件加入到数组链表</span></span><br><span class="line">    <span class="comment">// 			if 若Parser对象的数组链表为空则输出错误并退出</span></span><br><span class="line">    <span class="comment">// else 4.错误处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// writeVM2ASM(String, Parser): 空建CideWriter对象，根据String构造PrintWriter对象，再由其构造CodeWriter对象，并从parser获取文件名设置CodeWriter对象的文件名。</span></span><br><span class="line">    <span class="comment">// 还有命令:向前，跳空白，parser长度为0下一循环，若parser的命令类型是&#x27;push&#x27;或&#x27;pop&#x27;则调用codewriter对象写入Push和Pop相应的ASM指令，算术指令调用相应的函数</span></span><br><span class="line">    <span class="comment">// finally 释放parser和codewriter资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
        <tag>VirtualMachine</tag>
        <tag>vm</tag>
      </tags>
  </entry>
</search>
