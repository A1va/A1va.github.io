<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>nand2tetris C4-机器语言 | Alva</title><meta name="keywords" content="nand2tetris,Assembly"><meta name="author" content="Alva"><meta name="copyright" content="Alva"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="nand2tetris第四章节的知识笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="nand2tetris C4-机器语言">
<meta property="og:url" content="https://a1va.gitee.io/post/f125af90/index.html">
<meta property="og:site_name" content="Alva">
<meta property="og:description" content="nand2tetris第四章节的知识笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-10-24T03:03:03.000Z">
<meta property="article:modified_time" content="2020-10-24T03:11:24.435Z">
<meta property="article:author" content="Alva">
<meta property="article:tag" content="nand2tetris">
<meta property="article:tag" content="Assembly">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/A1va/A1va.github.io@1.0/img/favicon.ico"><link rel="canonical" href="https://a1va.gitee.io/post/f125af90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta name="baidu-site-verification" content="code-q1vRuOFMVW"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Alva","link":"链接: ","source":"来源: Alva","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-10-24 11:11:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><link rel="stylesheet" href="/css/customize.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/A1va/A1va.github.io@1.0/img/avatar.png" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/A1va/A1va.github.io@1.0/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">19</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80-Machine-Language"><span class="toc-number">1.</span> <span class="toc-text">[机器语言 Machine Language]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-number">1.0.1.</span> <span class="toc-text">[背景知识]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Machines"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">1.Machines</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Languages"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">2.Languages</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Commands"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">3.Commands</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hack%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%E8%AF%A6%E8%BF%B0"><span class="toc-number">1.0.2.</span> <span class="toc-text">[Hack机器语言规范详述]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-A-%E6%8C%87%E4%BB%A4-%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">2. A-指令 (地址指令)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-C-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">3. C-指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">4. 符号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">5. 输入&#x2F;输出处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95"><span class="toc-number">1.0.2.6.</span> <span class="toc-text">屏幕</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E7%9B%98"><span class="toc-number">1.0.2.7.</span> <span class="toc-text">键盘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zap-zap-zap-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.0.3.</span> <span class="toc-text">:zap::zap::zap:[机器语言实践]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%94%AF-Branching"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">[分支 Branching]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Variables"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">[Variables]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">[指针]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">输入 &#x2F; 输出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%AE%E7%9B%98-1"><span class="toc-number">1.0.3.4.1.</span> <span class="toc-text">键盘</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Project"><span class="toc-number">1.0.3.5.</span> <span class="toc-text">[Project]</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Mult"><span class="toc-number">1.0.3.5.1.</span> <span class="toc-text">1. Mult</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Fill"><span class="toc-number">1.0.3.5.2.</span> <span class="toc-text">2. Fill</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Alva</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">nand2tetris C4-机器语言</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-24T03:03:03.000Z" title="发表于 2020-10-24 11:03:03">2020-10-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-24T03:11:24.435Z" title="更新于 2020-10-24 11:11:24">2020-10-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Architecture/">Computer Architecture</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="机器语言-Machine-Language"><a href="#机器语言-Machine-Language" class="headerlink" title="[机器语言 Machine Language]"></a>[机器语言 Machine Language]</h1><p>借由机器语言，程序员用符号指令表达的抽象思维被转换成执行在硅片上的物理操作。</p>
<p><strong>This chapter is Complicated.</strong></p>
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><p>​        为了对机器语言作一般性描述，只须要集中讨论三个主要的抽象体上：<strong>处理器(processor)</strong>、<strong>内存(memory)</strong>以及一组<strong>寄存器(registers)</strong>。</p>
<h4 id="1-Machines"><a href="#1-Machines" class="headerlink" title="1.Machines"></a>1.Machines</h4><p>​        <strong>机器语言(machine language)</strong>利用<strong>处理器</strong>和<strong>寄存器操控内存</strong>。</p>
<p>​        <strong>内存(memory)</strong>    用来储存数据和指令的硬件设备。所有内存具有相同的结构：一个连续的固定宽度的单元序列，也称为<strong>字(word)</strong>或<strong>内存单元</strong>，每个内存单元都有一个唯一的<strong>地址(address)</strong>。因此可以通过地址描述任一内存单元。</p>
<p>​        <strong>处理器</strong>    <strong>中央处理器</strong>或<strong>CPU(Central Processing Unit)</strong>,是执行一组固定基本操作的设备。包括：算术操作、逻辑操作、内存存取操作和控制操作。操作对象都是二进制数值。</p>
<p>​        <strong>寄存器</strong>    内存访问较慢，需要较长的指令格式（一个地址可能需要32位）。因此，处理器都配有一些寄存器，每个寄存器只存储一位。紧挨着处理器，相当于处理器的一个高速本地内存，使得处理器能快速地操控数据和指令。</p>
<h4 id="2-Languages"><a href="#2-Languages" class="headerlink" title="2.Languages"></a>2.Languages</h4><p>​        16-位的指令包含四个4bit的位域(fileds)：最左边的域是CPU的操作编码，剩下的三个部分表示该操作的操作数。</p>
<p>​        <strong>二进制码</strong> 封装成 <strong>汇编(assembly language)</strong></p>
<p>​        汇编通过文本处理器编写，并由<strong>汇编编译器(assembler)</strong>将汇编程序 翻译成 <strong>二进制码</strong></p>
<h4 id="3-Commands"><a href="#3-Commands" class="headerlink" title="3.Commands"></a>3.Commands</h4><p>​        <strong>算术操作和逻辑操作</strong>    加减、布尔操作（按位取反、移位…）</p>
<p>​        <strong>内存访问</strong>    内存访问命令分两类。第一类是<strong>算术操作和逻辑操作</strong>，不仅可以操控寄存器，还可以操控指定的内存单元。第二类，所有计算机都会使用<code>load</code>和<code>store</code>命令，用来在寄存器和内存之间传递数据。这些命令可能会应用某些类型的寻址方式，在指令中指定目标内存单元的地址。三种绝大多数计算机支持的寻址方式：</p>
<ul>
<li>​    <strong>直接寻址(Direct Addressing)</strong>        最常用的寻址方式。直接 或 用符号表示内存单元的地址。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOAD R1, <span class="number">67</span>  <span class="comment">// R1 &lt;- Memory[67]</span></span><br><span class="line"><span class="comment">// 或者假设bar指向内存地址67，那么就有：</span></span><br><span class="line">LOAD R1, bar  <span class="comment">// R1 &lt;- Memory[67]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>​    <strong>立即寻址(Direct Addressing)</strong>        这种寻址方式用来加载常数——也即是，将指令中数据域的内容当作要操作的数据加载到寄存器。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOADI R1, <span class="number">67</span>  <span class="comment">// R1 &lt;- 67</span></span><br></pre></td></tr></table></figure>
<ul>
<li>​    <strong>间接寻址(Direct Addressing)</strong>        这种寻址方式用来处理<strong>指针(pointer)</strong>——也即是，将指令中数据域的内容当作要操作的数据加载到寄存器。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将x = foo[j] or x = *(foo+j)翻译成汇编语言</span></span><br><span class="line">ADD R1, foo, j  <span class="comment">// R1 &lt;- (foo+j)</span></span><br><span class="line">LOAD* R2, R1  <span class="comment">// R2 &lt;- Memory[R1]，取值到R2</span></span><br><span class="line">STR R2, x  <span class="comment">// x &lt;- R2，将值赋给x(内存单元)</span></span><br></pre></td></tr></table></figure>
<p>​        当数组在高级语言程序(C/Java…)被声明并被初始化时，编译器分配一组连续的内存单元来保存这个数组数据，并用foo来指代该内存单元组的<strong>基地址(base address)</strong>。于是当编译器以后遇到表示数组单元的符号<strong>(eg: foo[j])</strong>时，解析地址：<code>foo的基地址 + (j × 单个数组元素所占的字节)</code>。</p>
<p>​        <strong>控制流程</strong>        程序通常以先行执行，但也包含分支：<strong>反复</strong>(repetition, 跳回到循环的初始位置)、<strong>有条件的执行</strong>（conditional executioin, 若false向前跳到<code>if-then</code>语句之后）、<strong>子程序调用</strong>（subrouting calling, 跳到另一代码段的第一条命令处）</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高级实现</span></span><br><span class="line"><span class="keyword">while</span> (R1 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    code <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">code <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 底层实现</span></span><br><span class="line"><span class="comment">// while循环结构的典型翻译</span></span><br><span class="line">beginWhile</span><br><span class="line">    JNG R1, endWhile  <span class="comment">// if R1&lt;0 goto endWhile</span></span><br><span class="line">    <span class="comment">// code 1 的翻译</span></span><br><span class="line">JMP beginWhile  <span class="comment">// goto beginWhile</span></span><br><span class="line">endWhile:<span class="type"></span></span><br><span class="line"><span class="type">	</span>// code <span class="number">2</span> 的翻译</span><br></pre></td></tr></table></figure>
<h3 id="Hack机器语言规范详述"><a href="#Hack机器语言规范详述" class="headerlink" title="[Hack机器语言规范详述]"></a>[Hack机器语言规范详述]</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>​        Hack是一个基于冯·诺伊曼架构的16-位计算机，由一个CPU、两个独立的内存模块（instruction memory指令内存  和  data memory数据内存），以及两个内存映射I/O设备（显示器和键盘）组成。</p>
<p>​        <strong>内存地址空间</strong>        Hack程序员要了解，有两个不同的地址空间：<strong>指令地址空间</strong>（instruction memory<strong>指令内存</strong>），<strong>数据地址空间</strong>（data memory<strong>数据内存</strong>）。两个内存区16-位宽，由15-位地址空间，意味着两个内存可设定的最大地址都是<code>32K</code>的<code>16-bit word</code><strong>(2^15^ = 32 × 1024 = 32K)</strong></p>
<p>​        CPU只能执行存储在指令内存中的程序。指令内存是只读设备，程序通过某种外部方法被加载到指令内存中（加载新程序，就像游戏机更换游戏卡切换游戏）.  Hack平台的硬件仿真器提供一种方法，将某文本文件中用机器语言编写的程序加载到指令内存中。</p>
<p>​        <strong>寄存器(Registers)</strong>        Hack程序员要接触两个称为D和A的16-位寄存器，能够被算数和逻辑指令显式地操控(eg: <code>A = D-1</code>或<code>D = !A</code>)。D只作为数据寄存器（储存数据）；A既可以作为数据寄存器，也可以作为地址寄存器（储存地址）。</p>
<p><img src="/post/f125af90/image-20200827144620317.png" alt="三个寄存器" style="zoom: 50%;"></p>
<p>​        Hack语言规定，内存的存取指令是对隐式的内存地址“M”进行操作。<code>M-&gt;A, A=512, M = memory[512]</code></p>
<h4 id="2-A-指令-地址指令"><a href="#2-A-指令-地址指令" class="headerlink" title="2. A-指令 (地址指令)"></a>2. A-指令 (地址指令)</h4><p>唯一解析的指令：@value，为A寄存器赋值</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* value:</span></span><br><span class="line"><span class="comment"> *  1.非负的十进制常数≤32767(=2^15 - 1)</span></span><br><span class="line"><span class="comment"> *  2.指向(非负的十进制常数)的符号, eg:sum</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@<span class="number">21</span>：</span><br><span class="line"> - A寄存器赋值为<span class="number">21</span>  data register</span><br><span class="line"> - RAM[<span class="number">21</span>]将成为选定的RAM寄存器  address register</span><br><span class="line"><span class="comment">// 二进制形式：0value</span></span><br></pre></td></tr></table></figure>
<p>​        只要赋值赋值给A寄存器，A寄存器会自动从数据存储器中选中被选择的寄存器，被选择的寄存器就是上图中的M寄存器。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set RAM[100] to -1</span></span><br><span class="line">@<span class="number">100</span>  <span class="comment">// A = 100, 二进制：0value(=0000 0000 0110 0100)</span></span><br><span class="line">M = <span class="number">-1</span>  <span class="comment">// RAM[100] = -1</span></span><br></pre></td></tr></table></figure>
<p>​        此段代码，M就是代表了内存单元中的寄存器RAM[100]。这就是 A-指令 的用法，在内存的存取操作之前，我们总是要用 A-指令 去选择一个寄存器，进而完成内存的存取。</p>
<h4 id="3-C-指令"><a href="#3-C-指令" class="headerlink" title="3. C-指令"></a>3. C-指令</h4><p><img src="/post/f125af90/image-20200827153104413.png" alt="C指令" style="zoom:50%;"></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dest or jump are optional</span></span><br><span class="line"><span class="comment">// if dest is null, &quot;=&quot; omit</span></span><br><span class="line"><span class="comment">// if jump is null, &quot;;&quot; omit</span></span><br><span class="line">C-instructions: <span class="type">dest </span>= comp;jump</span><br></pre></td></tr></table></figure>
<p>comp域：ALU计算什么；</p>
<p>dest域：计算后的结果（ALU的输出）将被存储到哪里；</p>
<p>jump域：接下来要取出并执行拿一条命令</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the D register to -1</span></span><br><span class="line">D = <span class="number">-1</span>  <span class="comment">// D in dest table, -1 in comp table</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Set RAM[300] to the value of the D register minus 1</span></span><br><span class="line">@<span class="number">300</span>  <span class="comment">// A = 300, slect the register which I want to operate (access memory)</span></span><br><span class="line">M = D<span class="number">-1</span>  <span class="comment">// (D-1) in comp table</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// If (D-1 == 0) jump to execute the instruction stored in ROM[56]</span></span><br><span class="line">@<span class="number">56</span>  <span class="comment">// A=56</span></span><br><span class="line">D<span class="number">-1</span>;JEQ  <span class="comment">// if (D-1 == 0) go to 56.</span></span><br><span class="line"><span class="comment">// (D-1) in comp table, JEQ is (if out=0 then jump)</span></span><br></pre></td></tr></table></figure>
<p>C-指令的二进制表示：</p>
<p><img src="/post/f125af90/image-20200827160411973.png" alt="C指令的二进制形式" style="zoom:50%;"></p>
<p>C-指令的compute域：</p>
<p><img src="/post/f125af90/image-20200827160756020.png" alt="C-指令的compute域" style="zoom:50%;"></p>
<p>C-指令的dest域：</p>
<p><img src="/post/f125af90/image-20200827160915065.png" alt="C-指令的dest域" style="zoom:50%;"></p>
<p>dest域为3位二进制组合，代表了8种可能。</p>
<p>C-指令的jump域：</p>
<p><img src="/post/f125af90/image-20200827161133846.png" alt="C-指令的jump域" style="zoom:50%;">与dest域相似，junp也是3位二进制组合。</p>
<p>特别的，最后一个指令<code>(0;JMP)</code>执行一个无条件跳转。（其实除了0，还可取任意数值）</p>
<h4 id="4-符号"><a href="#4-符号" class="headerlink" title="4. 符号"></a>4. 符号</h4><p>​        汇编命令可以使用常数或符号来表示内存单元位置（地址）。</p>
<h4 id="5-输入-输出处理"><a href="#5-输入-输出处理" class="headerlink" title="5. 输入/输出处理"></a>5. 输入/输出处理</h4><p>Hack能连接两个外设，屏幕和键盘。两个设备与计算机的交互都是通过<strong>内存映像(memory maps)</strong>实现的。</p>
<p>这意味着在屏幕上描述像素是通过<strong>将二进制值写入</strong>与屏幕相关的<strong>内存段</strong>来实现的。</p>
<p>键盘的输入是通过<strong>读取</strong>与键盘相关的<strong>内存单元</strong>来实现的。</p>
<p>物理I/O设备和它们对应的内存映像是通过<strong>连续的循环刷新</strong>进行<strong>同步</strong>的。</p>
<h4 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h4><p>​        屏幕通过电线连接计算机，如果我们追踪电线，我们可以看到它进连接了RAM的一个区域，称为屏幕内存映射。</p>
<p><img src="/post/f125af90/image-20200828104048726.png" alt="screen memory map" style="zoom:50%;"></p>
<p>​        1 = 黑，0 = 白。而这中间的困难是，显示单元是二维的；内存映射是一维的，我们必须连接起来。我们只能从内存映射中<strong>读写</strong>16位数据，而无法只<strong>操作</strong>一个单独的位的数据。</p>
<p>​        对内存的存取操作都是16位，因此我们可以取出16位，对其中的1位进行操作之后，再存放。</p>
<p>​        另一难题，如何在内存映射出对应的行-列？</p>
<ol>
<li><p><code>word = Screen[32×row + col/16] (整除)</code></p>
<p>​        屏幕的内容<code>(131072 = 256*512)</code>由RAM<strong>基地址</strong>为<strong>16384(0x4000)</strong>的<strong>8K</strong> 内存映射 来表示，作用和记忆单元完全一样，对内存进行读写操作。而在整个计算机中，这个芯片将会成为数据内存的一部分，所以数据内存将由多个芯片组成。<code>8K = 8192, 8192*16bits = 131072</code></p>
<p><code>word = RAM[16384 + 32×row + col/16]</code></p>
</li>
</ol>
<pre><code> ​    求解出行-列，那么如何存取16位地址块中的 哪一个 二进制数呢？
</code></pre><ol>
<li><code>col%16</code>得到0至15之间的数，可以对其置1或0，修改之后再保存整个16位地址。在下一个时钟周期，就可以改变屏幕显示的像素。</li>
</ol>
<p>书上的例子：(应该是最右的元素)</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在屏幕的右上角换一个黑点</span></span><br><span class="line">@SCREEN  <span class="comment">// 将 A寄存器的值 置入 内存映射区，映射到屏幕第一行的16个像素的内存字</span></span><br><span class="line">M = <span class="number">1</span>  <span class="comment">// 1: (00000000000000001), 将最右边的像素变黑</span></span><br></pre></td></tr></table></figure>
<p>视频上的硬件仿真器的例子：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg:第3行前16列的所有像素变黑</span></span><br><span class="line">CHIP Screen&#123;</span><br><span class="line">	IN  <span class="keyword">in</span>[<span class="number">16</span>],    <span class="comment">// what to write</span></span><br><span class="line">    load,          <span class="comment">// write-enable bit</span></span><br><span class="line">    address[<span class="number">13</span>];   <span class="comment">// where to read/write</span></span><br><span class="line">    OUT out[<span class="number">16</span>];   <span class="comment">// Screen value at the given address   </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 32*3 = 96; address[13] = 96 = (0000 0000 0110 0000);</span></span><br><span class="line"><span class="comment">// load = 1</span></span><br><span class="line"><span class="comment">// in[16] = (1111 1111 1111 1111) = -1</span></span><br><span class="line"><span class="comment">// 写入内存后，还需要run时钟，将在下一个时钟周期刷新后显示</span></span><br></pre></td></tr></table></figure>
<h4 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h4><p>​        键盘通过电缆连接计算机，如果我们追踪电缆，我们可以看到它进入了RAM的一个区域，称为键盘内存映射。</p>
<p><img src="/post/f125af90/image-20200828105047045.png" alt="keyboard memory map" style="zoom:50%;"></p>
<p>​        Hack计算机与物理键盘之间通过RAM基地址为<strong>24576(0x6000)</strong>的单字内存映像进行交互。只要在键盘上敲一个键，其对应的16-位<strong>ASCII码</strong>值就出现在<strong>RAM[24576]</strong>。没有敲键盘时，该内存单元的值就是<strong>0(=0000 0000 0000 0000)</strong>。除了常用的<strong>ASCII码</strong>之外，Hack键盘还可以识别：</p>
<p><img src="/post/f125af90/image-20200828105539792.png" alt="键盘识别额外的键" style="zoom:50%;"></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read-Only</span></span><br><span class="line">CHIP Keyboard &#123;</span><br><span class="line">    OUT out[<span class="number">16</span>];   <span class="comment">// The ASCII code of the pressed key, </span></span><br><span class="line">                   <span class="comment">// or 0 if no key is currently pressed, </span></span><br><span class="line">                   <span class="comment">// or one the special codes listed in Figure 5.5.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        按下瞬间识别，松手则无键按下，置0.</p>
<h3 id="zap-zap-zap-机器语言实践"><a href="#zap-zap-zap-机器语言实践" class="headerlink" title=":zap::zap::zap:[机器语言实践]"></a>:zap::zap::zap:[机器语言实践]</h3><p><strong>D: data register</strong></p>
<p><strong>A: (address / data) register</strong></p>
<p><strong>M: the currently selelcted memory register, M = RAM[A]</strong></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// D = 10</span></span><br><span class="line">@<span class="number">10</span></span><br><span class="line">D=A</span><br><span class="line"></span><br><span class="line"><span class="comment">// D++</span></span><br><span class="line">D+<span class="number">1</span>  <span class="comment">// D+1 in comp table of C-instruction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// D=RAM[17]</span></span><br><span class="line">@<span class="number">17</span>  <span class="comment">// now, M=RAM[17]</span></span><br><span class="line">D=M</span><br><span class="line"></span><br><span class="line"><span class="comment">// RAM[17]=0</span></span><br><span class="line">@<span class="number">17</span></span><br><span class="line">M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RAM[17]=10</span></span><br><span class="line">@<span class="number">10</span></span><br><span class="line">D=A  <span class="comment">// store the value</span></span><br><span class="line">@<span class="number">17</span>  <span class="comment">// slelect the register</span></span><br><span class="line">M=D</span><br><span class="line"></span><br><span class="line"><span class="comment">// RAM[5] = RAM[3]</span></span><br><span class="line">@<span class="number">3</span></span><br><span class="line">D=M</span><br><span class="line">@<span class="number">5</span></span><br><span class="line">M=D</span><br></pre></td></tr></table></figure>
<p>Computes: RAM[2] = RAM[0] + RAM[1]</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="number">0</span>  <span class="comment">// R0 may be better</span></span><br><span class="line">D=M</span><br><span class="line"></span><br><span class="line">@<span class="number">1</span>  <span class="comment">// R1 may be better</span></span><br><span class="line">D=D+M  <span class="comment">// D+M in comp table of C-instruction</span></span><br><span class="line"></span><br><span class="line">@<span class="number">2</span>  <span class="comment">// R2 may be better</span></span><br><span class="line">M=D</span><br><span class="line">    </span><br><span class="line">@<span class="number">6</span></span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// end of program, use infinite loop to avoid </span></span><br></pre></td></tr></table></figure>
<p>空格在翻译时被忽略。</p>
<p>当我们要使用<strong>寄存器(R0~R15)</strong>时，利用符号表示，以获得更好的可读性：（此时A寄存器作为 address register）</p>
<p><img src="/post/f125af90/image-20200828141806438.png" alt="symbols" style="zoom:50%;"></p>
<p>符号严格区分大小写，请只使用‘R’。</p>
<p>SCREEN、KBD以及其他的内置符号</p>
<p><img src="/post/f125af90/image-20200828142217495.png" alt="extra symbols" style="zoom:50%;"></p>
<p>SCREEN和KBD代表的分别是：输出和输入设备内存映射的基地址。</p>
<h4 id="分支-Branching"><a href="#分支-Branching" class="headerlink" title="[分支 Branching]"></a>[分支 Branching]</h4><p><img src="/post/f125af90/image-20200828144432517.png" alt="branch" style="zoom:50%;"></p>
<p><strong>@LABEL</strong>会被翻译成@n，其中n是<strong>(LABEL)</strong>声明后的<strong>指令号</strong>。</p>
<p>(POSITIVE)是8，(END)是10</p>
<h4 id="Variables"><a href="#Variables" class="headerlink" title="[Variables]"></a>[Variables]</h4><p><img src="/post/f125af90/image-20200828161742688.png" alt="flip" style="zoom:50%;"></p>
<p>@temp变成中间变量，效果相当于@n，</p>
<p>@temp变量从地址16开始，可声明n个变量。</p>
<p>计算累加和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Computes RAM[1] = 1+2+ ... +RAM[0]</span></span><br><span class="line">    <span class="keyword">int</span> n = R0;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">LOOP:</span><br><span class="line">    <span class="keyword">if</span> i &gt; n <span class="keyword">goto</span> STOP;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> LOOP;</span><br><span class="line">STOP:</span><br><span class="line">    R1 = sum; </span><br></pre></td></tr></table></figure>
<p>将伪代码转换成我们的Hack汇编</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Computes RAM[1] = 1+2+ ... +n</span></span><br><span class="line"><span class="comment">// Usage: put a number (n) in RAM[0]</span></span><br><span class="line"></span><br><span class="line">    @R0</span><br><span class="line">    D=M</span><br><span class="line">    @n</span><br><span class="line">    M=D  <span class="comment">// n = R0</span></span><br><span class="line">    @i</span><br><span class="line">    M=<span class="number">1</span>  <span class="comment">// i = 1</span></span><br><span class="line">    @sum</span><br><span class="line">    M=<span class="number">0</span>  <span class="comment">// sum = 0</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    @i</span><br><span class="line">    D=M</span><br><span class="line">    @n</span><br><span class="line">    D=D-M  <span class="comment">// n - i</span></span><br><span class="line">    @STOP</span><br><span class="line">    D;JGT  <span class="comment">// jump (if) greater than; if i &gt; n goto STOP</span></span><br><span class="line"></span><br><span class="line">    @sum</span><br><span class="line">    D=M</span><br><span class="line">    @i</span><br><span class="line">    D=D+M</span><br><span class="line">    @sum</span><br><span class="line">    M=D</span><br><span class="line">    @i</span><br><span class="line">    M=M+<span class="number">1</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(STOP)</span><br><span class="line">    @sum</span><br><span class="line">    D=M</span><br><span class="line">    @R1</span><br><span class="line">    M=D  <span class="comment">// R[1] = sum</span></span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
<p>​    这是我们最佳的Hack汇编实践方式：</p>
<ol>
<li>Design the program using pseudo code and Make sure it works.</li>
<li>Write the program in assembly language.</li>
<li>Test the program (on paper) using a variable-value trace table.</li>
</ol>
<h4 id="指针"><a href="#指针" class="headerlink" title="[指针]"></a>[指针]</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for(i=0; i&lt;n; i++)&#123;</span></span><br><span class="line"><span class="comment">// 		arr[i] = -1;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// Suppose that arr=100 and n=10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr = 100</span></span><br><span class="line">    @<span class="number">100</span></span><br><span class="line">    D=A</span><br><span class="line">    @arr</span><br><span class="line">    M=D</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n = 10</span></span><br><span class="line">    @<span class="number">10</span></span><br><span class="line">    D=A</span><br><span class="line">    @n</span><br><span class="line">    M=D</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize i = 0</span></span><br><span class="line">    @i</span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    <span class="comment">// if (i==n) goto END. (not STOP cause we dont intent to valuation)</span></span><br><span class="line">    @i</span><br><span class="line">    D=M</span><br><span class="line">    @n</span><br><span class="line">    D=D-M</span><br><span class="line">    @END</span><br><span class="line">    D;JEQ</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RAM[arr+i] = -1</span></span><br><span class="line">    @arr</span><br><span class="line">    D=M</span><br><span class="line">    @i</span><br><span class="line">    A=D+M  <span class="comment">// A = arr+i</span></span><br><span class="line">    M=<span class="number">-1</span>  <span class="comment">// RAM[arr+i] = -1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// i++</span></span><br><span class="line">    @i</span><br><span class="line">    M=M+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
<p><img src="/post/f125af90/image-20200828210609280.png" alt="pointers" style="zoom:50%;"></p>
<ul>
<li><p>高级语言中，<code>arr</code>和<code>i</code>之类<strong>存储地址</strong>的变量称为<strong>指针</strong>。</p>
</li>
<li><p>Hack指针的逻辑：无论何时，当我们必须用指针访问内存，我们需要像<code>A=M</code>的指令。（对<code>RAM[M]</code>操作）</p>
</li>
<li>将地址寄存器（A register）设置为某个内存寄存器的内容，其中我们做了一些指针运算，计算我们需要操作的地址。</li>
</ul>
<h4 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入 / 输出"></a>输入 / 输出</h4><p><img src="/post/f125af90/image-20200828211646079.png" alt="input/output" style="zoom:50%;"></p>
<p>上图知识回顾。</p>
<p>我们需要在屏幕上画全黑的矩形，简单的思路是迭代足够多的行，让屏幕显示“黑块”。</p>
<p>psuedu code: </p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for (i=0; i&lt;n; i++)&#123;</span></span><br><span class="line"><span class="comment">// 		draw 16 block pixels at the beginning of row i</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">	addr = SCREEN</span><br><span class="line">    n = RAM[<span class="number">0</span>]</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    LOOP:<span class="type"></span></span><br><span class="line"><span class="type">        if i &gt; n goto END</span></span><br><span class="line"><span class="type">        RAM</span>[addr] = <span class="number">-1</span>  <span class="comment">// 1111 1111 1111 1111(= 16 black pixels)</span></span><br><span class="line">        <span class="comment">// advances to the next row</span></span><br><span class="line">        addr = addr + <span class="number">32</span>  <span class="comment">// 我们用内存映射的前32行代表一整行512(=32*16)个像素，每行如此</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        goto LOOP</span><br><span class="line"></span><br><span class="line">    END:<span class="type"></span></span><br><span class="line"><span class="type">        goto END</span></span><br></pre></td></tr></table></figure>
<p>实现的Hack汇编：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">   @SCREEN</span><br><span class="line">   D=A</span><br><span class="line">   @addr</span><br><span class="line">   M=D  <span class="comment">// addr = 16384(base address)</span></span><br><span class="line"></span><br><span class="line">   @R0</span><br><span class="line">   D=M</span><br><span class="line">   @n</span><br><span class="line">   M=D  <span class="comment">// n = RAM[0]</span></span><br><span class="line"></span><br><span class="line">   @i</span><br><span class="line">   M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    @i</span><br><span class="line">    D=M</span><br><span class="line">    @n</span><br><span class="line">    D=D-M</span><br><span class="line">    @END</span><br><span class="line">    D;JGT  <span class="comment">// if i &gt; n goto END</span></span><br><span class="line"></span><br><span class="line">    @addr</span><br><span class="line">    A=M</span><br><span class="line">    M=<span class="number">-1</span>  <span class="comment">// RAM[addr] = 1111 1111 1111 1111</span></span><br><span class="line"></span><br><span class="line">    @i</span><br><span class="line">    M=M+<span class="number">1</span>  <span class="comment">// i = i + 1</span></span><br><span class="line">    @<span class="number">1</span></span><br><span class="line">    D=A  <span class="comment">// D = RAM[32]</span></span><br><span class="line">    @addr</span><br><span class="line">    M=M+D  <span class="comment">// addr = addr + 32</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP  <span class="comment">// goto END</span></span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END  <span class="comment">// program&#x27;s end</span></span><br><span class="line">    <span class="number">0</span>;JMP  <span class="comment">// infinite loop</span></span><br></pre></td></tr></table></figure>
<h5 id="键盘-1"><a href="#键盘-1" class="headerlink" title="键盘"></a>键盘</h5><p><img src="/post/f125af90/image-20200828222504824.png" alt="keyboard" style="zoom:50%;"></p>
<ul>
<li>读出RAM[24576]的内容<ul>
<li>如果寄存器存储了0，说明无键输入；</li>
<li>否则，寄存器存储了现在按下的键的<strong>键盘扫描码</strong>。</li>
</ul>
</li>
</ul>
<h4 id="Project"><a href="#Project" class="headerlink" title="[Project]"></a>[Project]</h4><h5 id="1-Mult"><a href="#1-Mult" class="headerlink" title="1. Mult"></a>1. Mult</h5><p>a program performing <code>R2 = R0 * R1</code>.</p>
<p>pseudo code:</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">   i = RAM[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">   LOOP:<span class="type"></span></span><br><span class="line"><span class="type">       </span>// This is assembly, may be variable <span class="string">&#x27;i&#x27;</span> isnt so necessary like C program, can use RAM[<span class="number">0</span>] directly.</span><br><span class="line">       <span class="keyword">if</span> i ≤ <span class="number">0</span> goto STOP  </span><br><span class="line">       i = i - <span class="number">1</span></span><br><span class="line">       sum = sum + RAM[<span class="number">1</span>]</span><br><span class="line">       goto LOOP</span><br><span class="line"></span><br><span class="line">   STOP:<span class="type"></span></span><br><span class="line"><span class="type">       RAM</span>[<span class="number">2</span>] = sum</span><br><span class="line">       </span><br><span class="line">   END:<span class="type"></span></span><br><span class="line"><span class="type">       goto END</span></span><br></pre></td></tr></table></figure>
<p>impletement: mult.asm</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book &quot;The Elements of Computing Systems&quot;</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/04/Mult.asm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiplies R0 and R1 and stores the result in R2.</span></span><br><span class="line"><span class="comment">// (R0, R1, R2 refer to RAM[0], RAM[1], and RAM[2], respectively.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Put your code here.</span></span><br><span class="line"></span><br><span class="line">    @sum</span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line">    @R0</span><br><span class="line">    D=M</span><br><span class="line">    @i</span><br><span class="line">    M=D</span><br><span class="line">    @R2</span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    @i</span><br><span class="line">    D=M</span><br><span class="line">    @STOP</span><br><span class="line">    D;JLE  <span class="comment">// jump less equal; if R[0] &lt;= 0 goto STOP</span></span><br><span class="line">    @i</span><br><span class="line">    M=M<span class="number">-1</span>  <span class="comment">// i--</span></span><br><span class="line"></span><br><span class="line">    @R1</span><br><span class="line">    D=M</span><br><span class="line">    @sum</span><br><span class="line">    M=M+D  <span class="comment">// D = sum + R[0]</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(STOP)</span><br><span class="line">    @sum</span><br><span class="line">    D=M</span><br><span class="line">    @R2</span><br><span class="line">    M=D  <span class="comment">// R[2] = sum</span></span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
<h5 id="2-Fill"><a href="#2-Fill" class="headerlink" title="2. Fill"></a>2. Fill</h5><p><strong>持续监听</strong>键盘输入，只要有<strong>任何键被按下</strong>，屏幕全黑；只要<strong>松开按键</strong>，屏幕恢复全白。</p>
<ol>
<li>如何定义无限循环？</li>
<li>什么意味着监听到按键？</li>
<li>监听到按键后，如何将屏幕变黑？</li>
<li>如何清屏？</li>
</ol>
<p><strong>如何定义无限循环？</strong></p>
<p>关键在于程序结束时的跳转，只要我们能保证，程序总是跳转到循环开始的地方即可。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(LOOP)</span><br><span class="line">...</span><br><span class="line">@LOOP</span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// 程序结束，跳转到 LOOP tag</span></span><br></pre></td></tr></table></figure>
<p><strong>什么意味着监听到按键？</strong></p>
<p>​        当键盘任意键被按下，那么<strong>键盘的内存映射区</strong>的值一定大于0，所以判断 <strong>键盘基地址(KBD)对应的值</strong> 是否大于0即可。由于程序在<strong>无限循环</strong>，所以只要按键不松开，那么 <strong>KBD的值</strong> 就不会变回0，我们的程序就会一直输出，直到屏幕被填满。</p>
<p>​        如果<strong>KBD的值</strong>为0，说明键盘<strong>空置</strong>，我们的程序应该转而去执行<strong>恢复白屏</strong>的操作。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@KBD</span><br><span class="line">D=M  <span class="comment">// D-register gets the basic address of the keyboard memory-map.</span></span><br><span class="line">@FILL</span><br><span class="line">D;JGT  <span class="comment">// jump (to FILL if D) greater than 0.</span></span><br><span class="line">@CLEAR</span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// other case(= D≤0), unconditional jump to CLEAR</span></span><br></pre></td></tr></table></figure>
<p><strong>监听到按键后，如何将屏幕变黑？</strong></p>
<p>​        这正是<code>FILL</code>需要实现的功能。我们通过课堂的例子知道，一次<strong>存取</strong>操作<strong>最多</strong>只可以将<strong>16bit</strong>的数据置为<strong>-1(= 1111 1111 1111 1111)</strong>，从而变黑。因此如果将全屏幕变黑，就需要通过循环实现，循环需要知道起点和终点或者起点和长度。</p>
<p>​        (起点)我们可以存储当前的地址到变量<code>@current</code>，(终点)存储<strong>屏幕内存映射区的最大单元地址(=24575)</strong>到变量<code>@max</code>。另外，要用长度也可以存储<strong>屏幕最大长度8K(=8192)</strong>。需要注意的是，当前地址表示的是第一个可用的单元地址，如果无可用单元，那么<code>current - max &lt; 0</code>，若等于0，则表示最后一个单元可用。（24576恰好为键盘的内存映射地址）</p>
<p>​        循环条件已经解决，如果填充满了，直接返回LOOP；如果未满，则继续。</p>
<p>​        如果按键不松，那么循环会一直检测到按键，也就会一直执行FILL模块，每执行一次会填充一个单元(=16bits)的黑色像素，因此，在屏幕上看到的像素显示是幕帘式的，而不是骤变的。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@SCREEN</span><br><span class="line">D=A  <span class="comment">// D-register gets the basic address of the screen memory-map.</span></span><br><span class="line">@current</span><br><span class="line">M=D</span><br><span class="line">@<span class="number">24575</span>  <span class="comment">// max address of  the screen memory-map.</span></span><br><span class="line">D=A</span><br><span class="line">@max</span><br><span class="line">M=D</span><br><span class="line"></span><br><span class="line">(FILL)</span><br><span class="line">@current</span><br><span class="line">D=M</span><br><span class="line">@max</span><br><span class="line">D=D-M  <span class="comment">// current - max</span></span><br><span class="line">@LOOP</span><br><span class="line">D;JGT  <span class="comment">// jump if current &gt; max</span></span><br><span class="line"></span><br><span class="line">@current</span><br><span class="line">D=M  <span class="comment">// get address</span></span><br><span class="line">A=D  <span class="comment">// A = current address, in order to change Memory[current]</span></span><br><span class="line">M=<span class="number">-1</span>  <span class="comment">// current address turn black</span></span><br><span class="line">@current</span><br><span class="line">M=M+<span class="number">1</span></span><br><span class="line">@LOOP</span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// return LOOP</span></span><br></pre></td></tr></table></figure>
<p><strong>如何清屏？</strong></p>
<p>​        这正是<code>CLEAR</code>需要实现的功能，是<code>FILL</code>的逆过程。当程序检测到<strong>无按键(KBD的值为0)</strong>，进入<code>CLEAR</code>模块。</p>
<p>​        清屏操作，获取当前地址，并循环：减一，并与屏幕基地址SCREEN比较，若小于则清屏结束；否则，继续清屏。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(CLEAR)</span><br><span class="line">@current</span><br><span class="line">D=M</span><br><span class="line">D=D<span class="number">-1</span>  <span class="comment">// 先减一</span></span><br><span class="line">@SCREEN</span><br><span class="line">D=D-A  <span class="comment">// (current address) minus (SCREEN basic address)</span></span><br><span class="line">@LOOP</span><br><span class="line">D;JLT</span><br><span class="line">@current</span><br><span class="line">D=M  <span class="comment">// get address</span></span><br><span class="line">A=D  <span class="comment">// A = current address, in order to change Memory[current]</span></span><br><span class="line">M=<span class="number">0</span>  <span class="comment">// current address turn white</span></span><br><span class="line">@LOOP</span><br><span class="line"><span class="number">0</span>;JMP  <span class="comment">// return LOOP</span></span><br></pre></td></tr></table></figure>
<p>Pseudo code</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">max = <span class="number">24575</span>;</span><br><span class="line">current = SCREEN;</span><br><span class="line">LOOP()&#123;</span><br><span class="line">    <span class="keyword">if</span>(Memory[KBD] &gt; <span class="number">0</span>)&#123;  <span class="comment">// 键盘有按键</span></span><br><span class="line">        FILL();</span><br><span class="line">    &#125;</span><br><span class="line">    CLEAR();</span><br><span class="line">&#125;</span><br><span class="line">FILL()&#123;</span><br><span class="line">    <span class="keyword">if</span>((current-max) &gt; <span class="number">0</span>)&#123;  <span class="comment">// 当前地址大于屏幕显示内存映射区的最大地址，已填满屏幕</span></span><br><span class="line">      LOOP();  </span><br><span class="line">    &#125;</span><br><span class="line">    Memory[current] = <span class="number">-1</span>;</span><br><span class="line">    current++;</span><br><span class="line">    LOOP();</span><br><span class="line">&#125;</span><br><span class="line">CLEAR()&#123;</span><br><span class="line">    <span class="keyword">if</span>((SCREEN-current) &gt; <span class="number">0</span>)&#123;  <span class="comment">// 当前地址小于屏幕显示内存映射区的最小地址，已清空屏幕</span></span><br><span class="line">        LOOP();</span><br><span class="line">    &#125;</span><br><span class="line">    Memory[current] = <span class="number">0</span>;</span><br><span class="line">    current--;</span><br><span class="line">    LOOP();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>implement:</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// max = 24575, store as a address</span></span><br><span class="line">    @<span class="number">24575</span></span><br><span class="line">    D=A</span><br><span class="line">    @max</span><br><span class="line">    M=D</span><br><span class="line"></span><br><span class="line">    <span class="comment">// current = SCREEN, store as a address</span></span><br><span class="line">    @SCREEN</span><br><span class="line">    D=A</span><br><span class="line">    @current</span><br><span class="line">    M=D</span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    <span class="comment">// if(Memory[KBD] &gt; 0)&#123;  // 键盘有按键</span></span><br><span class="line">    <span class="comment">//     FILL();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    @KBD</span><br><span class="line">    D=M  <span class="comment">// *** get Memory[KBD]</span></span><br><span class="line">    @FILL</span><br><span class="line">    D;JGT</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CLEAR();  // no conditional</span></span><br><span class="line">    @CLEAR</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(FILL)</span><br><span class="line">    @current</span><br><span class="line">    D=M</span><br><span class="line">    @max</span><br><span class="line">    D=D-M  <span class="comment">// current - max</span></span><br><span class="line">    @LOOP</span><br><span class="line">    D;JGT</span><br><span class="line"></span><br><span class="line">    @current</span><br><span class="line">    A=M</span><br><span class="line">    M=<span class="number">-1</span></span><br><span class="line">    @current</span><br><span class="line">    M=M+<span class="number">1</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(CLEAR)</span><br><span class="line">    @SCREEN</span><br><span class="line">    D=A  <span class="comment">// *** get SCREEN address</span></span><br><span class="line">    @current</span><br><span class="line">    D=D-M  <span class="comment">// SCREEN - current</span></span><br><span class="line">    @LOOP</span><br><span class="line">    D;JGT</span><br><span class="line"></span><br><span class="line">    @current</span><br><span class="line">    A=M</span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    @current</span><br><span class="line">    M=M<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
<p>做的时候困扰我的反而是：@KBD之后获取Memory[KBD]的值，以及@SCREEN之后获取SCREEN地址。成功把我绕晕了….</p>
<p><img src="/post/f125af90/image-20200830115543297.png" alt="result00" style="zoom:50%;"></p>
<p><img src="/post/f125af90/image-20200830115451987.png" alt="result01" style="zoom:50%;"></p>
<p>A-register、D-register and @value:</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="number">1024</span>  <span class="comment">// 传说中的 A-instruction  也就是A指令, 下面的都是C指令</span></span><br><span class="line">D=A    <span class="comment">// 读取数据1024, 并赋值给 D-Register 也就是 data-Register 数据寄存器</span></span><br><span class="line">D=M    <span class="comment">// 读取内存地址为1024 的值也就是 Memory[1024]</span></span><br><span class="line">D;JEQ  <span class="comment">// 跳转逻辑 如果当前数据寄存器中的值等于0, 则pc = 1024, 也就是当前下一个输入的指令地址为1</span></span><br></pre></td></tr></table></figure>
<p><em>test:</em>(from阿德莱德大学)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rust 伪代码 add up all 10 numbers in the array numbers</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = sum + *numbers++;</span><br><span class="line">    <span class="keyword">let</span> x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>implement: (passed test)</em></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    @x  <span class="comment">// 16</span></span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line">    @sum  <span class="comment">// 17</span></span><br><span class="line">    M=<span class="number">0</span></span><br><span class="line">    @numbers  <span class="comment">// address in [18,27]</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    @x</span><br><span class="line">    D=M</span><br><span class="line">    @<span class="number">10</span></span><br><span class="line">    D=D-A  <span class="comment">// (x-10)</span></span><br><span class="line">    @END</span><br><span class="line">    D;JGE  <span class="comment">// 与伪代码符号完全相反：‘＞’ =&gt; ‘≤’</span></span><br><span class="line"></span><br><span class="line">    @numbers  <span class="comment">// array</span></span><br><span class="line">    A=M</span><br><span class="line">    D=M  <span class="comment">// D = *numbers</span></span><br><span class="line">    @sum</span><br><span class="line">    M=D+M  <span class="comment">// sum = *numbers + sum</span></span><br><span class="line">    @numbers</span><br><span class="line">    A=A+<span class="number">1</span>  <span class="comment">// numbers++, get the next one in array</span></span><br><span class="line">    @x</span><br><span class="line">    M=M+<span class="number">1</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Alva</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://a1va.gitee.io/post/f125af90/">https://a1va.gitee.io/post/f125af90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://A1va.gitee.io" target="_blank">Alva</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/nand2tetris/">nand2tetris</a><a class="post-meta__tags" href="/tags/Assembly/">Assembly</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/1404dacc/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/A1va/A1va.github.io@1.0/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">nand2tetris C5-计算机体系结构</div></div></a></div><div class="next-post pull-right"><a href="/post/5b81f62b/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/A1va/A1va.github.io@1.0/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">nand2tetris C3-时序逻辑</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/e93fe37f/" title="nand2tetris C6-汇编编译器"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-24</div><div class="title">nand2tetris C6-汇编编译器</div></div></a></div><div><a href="/post/a2d606e7/" title="nand2tetris C1-布尔逻辑"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-24</div><div class="title">nand2tetris C1-布尔逻辑</div></div></a></div><div><a href="/post/c8f554f1/" title="nand2tetris C2-布尔算法"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-24</div><div class="title">nand2tetris C2-布尔算法</div></div></a></div><div><a href="/post/5b81f62b/" title="nand2tetris C3-时序逻辑"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-24</div><div class="title">nand2tetris C3-时序逻辑</div></div></a></div><div><a href="/post/26de550e/" title="nand2tetris C8-虚拟机Ⅱ程序控制"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-24</div><div class="title">nand2tetris C8-虚拟机Ⅱ程序控制</div></div></a></div><div><a href="/post/1404dacc/" title="nand2tetris C5-计算机体系结构"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-24</div><div class="title">nand2tetris C5-计算机体系结构</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By Alva</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const initData = {
      el: '#vcomment',
      appId: 'gRj7X8BmfpoOT3o7iRuwkv9N-MdYXbMMI',
      appKey: 'qACqGG8iNaELki3G1PJg9gwq',
      placeholder: '请留下你的脚印吧~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }

    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/customize.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>