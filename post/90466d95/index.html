<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>nand2tetis C7-虚拟机Ⅰ堆栈运算 | Alva</title><meta name="keywords" content="nand2tetris,VirtualMachine,vm"><meta name="author" content="Alva"><meta name="copyright" content="Alva"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="nand2tetris第七章节的知识笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="nand2tetis C7-虚拟机Ⅰ堆栈运算">
<meta property="og:url" content="https://a1va.github.io/post/90466d95/index.html">
<meta property="og:site_name" content="Alva">
<meta property="og:description" content="nand2tetris第七章节的知识笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-10-23T13:33:15.000Z">
<meta property="article:modified_time" content="2020-10-23T13:46:48.476Z">
<meta property="article:author" content="Alva">
<meta property="article:tag" content="nand2tetris">
<meta property="article:tag" content="VirtualMachine">
<meta property="article:tag" content="vm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="https://a1va.github.io/post/90466d95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Alva","link":"链接: ","source":"来源: Alva","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-10-23 21:46:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><link rel="stylesheet" href="/css/customize.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%85%A0-%E5%A0%86%E6%A0%88%E8%BF%90%E7%AE%97-Stack-Arithmetic"><span class="toc-number">1.</span> <span class="toc-text">[虚拟机Ⅰ: 堆栈运算 Stack Arithmetic]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-number">1.0.1.</span> <span class="toc-text">[背景知识]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%8C%83%E5%9E%8B"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">1.虚拟机范型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%88%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">2.栈式计算机模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.1.2.1.</span> <span class="toc-text">栈式计算机模型的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#from-VM-to-Assembly"><span class="toc-number">1.0.2.</span> <span class="toc-text">[from VM to Assembly]</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#summary"><span class="toc-number">1.0.2.0.1.</span> <span class="toc-text">summary:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Summary"><span class="toc-number">1.0.2.0.2.</span> <span class="toc-text">Summary:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.3.</span> <span class="toc-text">[实现]</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%88%86%E6%9E%90%E5%A0%86%E6%A0%88%E8%BF%90%E7%AE%97"><span class="toc-number">1.0.3.0.1.</span> <span class="toc-text">综合内存映射分析堆栈运算</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Alva</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">nand2tetis C7-虚拟机Ⅰ堆栈运算</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-23T13:33:15.000Z" title="发表于 2020-10-23 21:33:15">2020-10-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-23T13:46:48.476Z" title="更新于 2020-10-23 21:46:48">2020-10-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Architecture/">Computer Architecture</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="虚拟机Ⅰ-堆栈运算-Stack-Arithmetic"><a href="#虚拟机Ⅰ-堆栈运算-Stack-Arithmetic" class="headerlink" title="[虚拟机Ⅰ: 堆栈运算 Stack Arithmetic]"></a>[虚拟机Ⅰ: 堆栈运算 Stack Arithmetic]</h1><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="[背景知识]"></a>[背景知识]</h3><h4 id="1-虚拟机范型"><a href="#1-虚拟机范型" class="headerlink" title="1.虚拟机范型"></a>1.虚拟机范型</h4><p>​        高级语言程序能够在计算机上运行之前，它必须被翻译成计算机的机器语言，即<strong>编译</strong>。如果每种高级语言被编译成对应于目标硬件平台的机器语言，那么我们必须维护多个版本的代码，这是一种无尽的折磨…</p>
<p><img src="/post/90466d95/image-20200911163424313.png" alt="pain" style="zoom:67%;"></p>
<p>​        减少高级语言和机器语言<strong>依赖性</strong>的方法之一是将编译过程分为<strong>两个几乎独立的阶段</strong>。基本思想：中间代码运行在<strong>虚拟机(virtual Machine)</strong>上，而不是正式的硬件平台。</p>
<p><img src="/post/90466d95/image-20200911163242720.png" alt="virtualMachine instance"></p>
<p>​        第一个阶段：高级程序被解析出来，其命令被翻译成中间结果。第二个阶段：这些中间结果被进一步翻译成目标硬件的机器语言。当然，两个编译阶段之间的接口<strong>(接口就是中间处理步骤的精确定义)</strong>必须仔细地进行设计。</p>
<p>​        原来作用为一个独立程序的编译器被分成两个独立的程序。第一个程序，编译器(Compiler)，将高级代码翻译成中间VM指令；第二个程序将这个<strong>VM代码翻译成目标计算机硬件平台的机器语言</strong>。</p>
<p>​        Java编译器也是<strong>两层(two-tiered)结构</strong>，它生成运行在JVM虚拟机上(也称为Java运行时环境，<strong>Java Runtime Enviroment</strong>)的byte-code语言。</p>
<p>​        明确且正式的虚拟机语言概念有很多务实的优点。首先，仅需要<strong>替换虚拟机实现部分</strong>（有时候称为编译器的后端程序， backend）就能相对容易地<strong>得到不同硬件平台的编译器</strong>。因此，虚拟机在不同硬件平台之间的<strong>可移植性</strong>可以实现代码效率、硬件成本和程序开发难度之间的权衡。其次，很多语言的编译器能够<strong>共享VM后端程序</strong>，允许<strong>代码共享和语言互用性</strong>。比如，某种高级语言善于科学计算，而另一种在处理用户接口方面很突出。<strong>如果把两种语言编译到通用的VM层，那么通过使用约定的调用语法，其中一种语言的程序就能够很容易地调用另一种语言的程序</strong>。</p>
<p>​        虚拟机方法的另一个优点是<strong>模块化</strong>。<strong>VM的每一个改善都会立即被所有构建于其上的编译器继承</strong>。同样地，每个安装有VM实现的数字设备都能够受益于现有软件的庞大基础。</p>
<p>​        将高级语言翻译成中间代码的程序可以称为<strong>编译器前端程序</strong>，而将中间代码翻译成机器语言的程序可以称为<strong>编译器后端程序</strong>。</p>
<p>​        比如<code>Java</code>，<code>Java</code>的源码经翻译后形成<code>Byte Code</code>文件，<code>Byte Code</code>文件是运行在<code>Java</code>虚拟机上的，而<code>Byte Code</code>文件经翻译后得到机器语言，机器语言运行在硬件平台上。因此，中间代码运行在虚拟机上，机器语言运行在硬件上。</p>
<p>​        编译器的后端程序负责的是将中间代码翻译成机器语言，所以它与硬件平台的关系性非常大，如果我们需要运行在不同的硬件平台上，那么机器语言就会发生变化，因此后端程序就需要改变，而前端程序不需要改变，因而虚拟机可以使语言很方便的进行<strong>跨平台使用</strong>。</p>
<p>​        在此虚拟机中，虚拟机语言共包含4种类型的指令：算术指令，内存访问指令，程序流程控制指令和子程序调用指令。</p>
<p>​        </p>
<h4 id="2-栈式计算机模型"><a href="#2-栈式计算机模型" class="headerlink" title="2.栈式计算机模型"></a>2.栈式计算机模型</h4><p>​        在VM操作中的操作数和结果应该驻留在哪里。也许“最干净利落”的方法是将其放在<strong>栈式(stack)</strong>数据结构。</p>
<h5 id="栈式计算机模型的实现"><a href="#栈式计算机模型的实现" class="headerlink" title="栈式计算机模型的实现"></a>栈式计算机模型的实现</h5><p><img src="/post/90466d95/image-20200913101004893.png" alt="stack machine inplementation" style="zoom:50%;"></p>
<p><em>Logic</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*sp = <span class="number">17</span>;</span><br><span class="line">sp++;</span><br></pre></td></tr></table></figure>
<p><em>Hack assembly</em></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="number">17</span>;  <span class="comment">// A=17</span></span><br><span class="line">D=A;  <span class="comment">// D=17</span></span><br><span class="line"><span class="comment">// *SP=D</span></span><br><span class="line">@SP;  <span class="comment">// A = SP</span></span><br><span class="line">A=M;  <span class="comment">// A = Memory[SP]: indirect address</span></span><br><span class="line">M=D;  <span class="comment">// M = D,( M is (*SP) )</span></span><br><span class="line"><span class="comment">// SP++</span></span><br><span class="line">@SP;</span><br><span class="line">M=M+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="from-VM-to-Assembly"><a href="#from-VM-to-Assembly" class="headerlink" title="[from VM to Assembly]"></a>[from VM to Assembly]</h3><p><strong><em>push &amp; pop</em> implementation:</strong></p>
<p><img src="/post/90466d95/image-20200923124849383.png" alt="push/pop" style="zoom:67%;"></p>
<p><strong><em>stack</em> implementation</strong></p>
<p><img src="/post/90466d95/image-20200923125313183.png" alt="image-20200923125313183" style="zoom:67%;"></p>
<p><strong><em>implement constant:</em></strong>no <code>pop</code></p>
<p><img src="/post/90466d95/image-20200913111011987.png" alt="implement constant" style="zoom:50%;"></p>
<ul>
<li>不允许存储任何东西到<code>constant</code>段</li>
</ul>
<p><strong>Implementing <em>local</em></strong></p>
<p><img src="/post/90466d95/image-20200913103134064.png" alt="local" style="zoom:50%;"></p>
<p><em>logic</em>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addr = LCL + <span class="number">2</span>;</span><br><span class="line">SP--;</span><br><span class="line">*addr = *SP;</span><br></pre></td></tr></table></figure>
<p><em>implement:</em></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@<span class="number">2</span>;</span><br><span class="line">D=A;</span><br><span class="line">@LCL;</span><br><span class="line">D=M+D;</span><br><span class="line">@addr;</span><br><span class="line">M=D;</span><br><span class="line"><span class="comment">// SP--, SP is a pointer</span></span><br><span class="line">@SP;</span><br><span class="line">A=M;</span><br><span class="line">M=M<span class="number">-1</span>;  <span class="comment">// SP--</span></span><br><span class="line">D=M;  <span class="comment">// D=SP</span></span><br><span class="line">@addr;</span><br><span class="line">A=M;  <span class="comment">// A=addr, M=*addr</span></span><br><span class="line">M=D;</span><br></pre></td></tr></table></figure>
<h5 id="summary"><a href="#summary" class="headerlink" title="summary:"></a>summary:</h5><p>previous <em>Logic</em> is <code>pop local i</code>, and <code>push local i</code> is similiar.</p>
<p><code>pop local i</code>is to<code>addr = LCL + i, SP--, *addr = *SP</code></p>
<p><code>push local i</code> is to<code>addr = LCL + i, *SP = *addr, SP++</code></p>
<p><img src="/post/90466d95/image-20200913104413496.png" alt="summary" style="zoom:50%;"></p>
<p><strong>implement <em>lcoal, argument, this, that</em></strong>:</p>
<p><img src="/post/90466d95/image-20200923151620070.png" alt="image-20200923151620070" style="zoom:67%;"></p>
<ul>
<li>将函数方法局部变量和参数变量映射到<code>local</code>和<code>argument</code>段</li>
<li>将函数方法正在处理的对象属性字段和数组项(条目)映射到<code>this</code>和<code>that</code>段</li>
</ul>
<p><img src="/post/90466d95/image-20200913144322327.png" alt="four segment" style="zoom: 80%;"></p>
<p><code>local</code>, <code>argument</code>, <code>this</code> 和 <code>that</code>都是同样的实现，只需要将<code>segment</code>替换就可以得到另一种。</p>
<script type="math/tex; mode=display">
segment = \{lcoal, argument, this, that\}</script><p><strong><em>implement static</em></strong>:class level variable</p>
<p><img src="/post/90466d95/image-20200913150214722.png" alt="static-variable" style="zoom: 80%;"></p>
<p>​    挑战：<code>static</code>变量应该对程序中的所有函数方法可见</p>
<p>​    解决方法：将其存储在<code>global space</code>全局段中</p>
<ul>
<li>VM翻译器必须翻译每一个VM指向的<code>static i</code>(in the file <em>Foo.vm</em>)到Hack汇编程序的<code>Foo.i</code></li>
<li>遵循Hack汇编的语法，Hack汇编编译器将会把这些reference映射到<code>RAM[16], ... , RAM[255]</code></li>
</ul>
<p><em>implement Memory segment:</em> <code>temp</code></p>
<p><img src="/post/90466d95/image-20200913162748968.png" alt="temp01" style="zoom: 67%;"></p>
<ul>
<li>有些时候，编译器需要用一些中间变量，我们的VM提供了8个类似的变量，存储在<code>temp</code>段</li>
</ul>
<p><img src="/post/90466d95/image-20200913163030397.png" alt="temp02" style="zoom:67%;"></p>
<p>✨✨<code>temp</code>: from VM code to Assembly pseudo code</p>
<p>8个变量存储在<code>RAM[5]~RAM[12]</code></p>
<p><strong><em>implement pointer 0/1</em></strong></p>
<ul>
<li>用于存储<code>this</code>和<code>that</code>段的基地址</li>
<li>当我们编写编译器时，就会知道<code>this</code>的重要性</li>
</ul>
<p><img src="/post/90466d95/image-20200922135814987.png" alt="pointer"></p>
<ul>
<li>通过访问<code>THIS</code>从而访问<code>pointer 0: this</code></li>
<li>通过访问<code>THAT</code>从而访问<code>pointer 1: that</code></li>
</ul>
<h5 id="Summary"><a href="#Summary" class="headerlink" title="Summary:"></a>Summary:</h5><p><img src="/post/90466d95/image-20200922135405740.png" alt="总结1" style="zoom:67%;"></p>
<p><img src="/post/90466d95/image-20200922135427724.png" alt="总结2" style="zoom:67%;"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="[实现]"></a>[实现]</h3><h5 id="综合内存映射分析堆栈运算"><a href="#综合内存映射分析堆栈运算" class="headerlink" title="综合内存映射分析堆栈运算"></a><strong>综合内存映射分析堆栈运算</strong></h5><p>​        做好本章的项目，理解好<strong>内存映射(Memory Map)</strong>是关键，只有理解了内存映射才能知道去哪里取数据，将数据存储到哪里。</p>
<p>​        综合来看，本章的大致思路就是：从<strong>RAM[1]~RAM[4]</strong>中找到<strong>基址</strong>，根据偏移量计算出地址，再去获取数据，并将数据放入堆栈中，在栈区中完成一定操作后，再将结果从堆栈中弹出，放到指定的内存单元（这里实际上还需要计算基址和偏移量）。不同的是<code>temp</code>段，它可以直接在<strong>RAM[5]</strong>上加上偏移量得到存储单元的地址。</p>
<p>​        在整个操作过程中，如果需要使用除D寄存器和A寄存器之外的寄存器暂时存储结果的时候，就会使用到<strong>RAM[13]~RAM[15]</strong>的通用寄存器。</p>
<p><strong><em>Review:</em></strong></p>
<ol>
<li><p><code>@X</code>的意义为把<code>X</code>存入A寄存器，M代表的是<code>Memory[A]</code>，即A映射的地址中所存的值。<br><code>A=M, M=D</code>两句意味着1. A更新为M寄存器存储的数据所指向的地址，2.将D寄存器存储的的数据存入<code>Memory[A]</code>，这是这一章中用得最多的逻辑语句。</p>
</li>
<li><p>在实现<code>eq</code>, <code>gt</code>, <code>lt</code>时，需要用汇编语言实现<code>if</code>分支，这里需要用到两个<code>lable</code>，一个<strong>有条件</strong><code>jump</code>，一个<strong>无条件</strong><code>jump</code>，代码实现为：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compare R1=R2 set result in R3</span></span><br><span class="line">@SP</span><br><span class="line">AM=M<span class="number">-1</span></span><br><span class="line">D=M</span><br><span class="line">A=A<span class="number">-1</span></span><br><span class="line">D=M-D</span><br><span class="line">@RET_TRUE</span><br><span class="line">D;JEQ</span><br><span class="line">@SP         <span class="comment">// need to return False</span></span><br><span class="line">A=M<span class="number">-1</span></span><br><span class="line">M=<span class="number">0</span></span><br><span class="line">@CONTINUE</span><br><span class="line"><span class="number">0</span>;JMP</span><br><span class="line">(RET_TRUE)</span><br><span class="line">@SP        <span class="comment">// need to return True</span></span><br><span class="line">A=M<span class="number">-1</span></span><br><span class="line">M=<span class="number">-1</span></span><br><span class="line">(CONTINUE)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>push segment i</code>的实现：<code>addr = segmentPointer+i, *SP = *addr, SP++</code></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@segmentPointer</span><br><span class="line">D=M</span><br><span class="line">@index</span><br><span class="line">A=D+A</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>pop segment i</code>的实现：<code>addr = segmentPointer+i, SP--, *addr = *SP</code></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@segmentPointer</span><br><span class="line">D=M</span><br><span class="line">@index</span><br><span class="line">D=D+A</span><br><span class="line">@R13</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">AM=M<span class="number">-1</span></span><br><span class="line">D=M</span><br><span class="line">@R13</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure>
<p><code>push/pop temp i</code>的实现</p>
<p>push: <code>addr = 5 + i, *SP = *addr, SP++</code></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="number">5</span>+index</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>pop:  <code>addr = 5 + i, SP--, *addr = *SP</code></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SP</span><br><span class="line">AM=M<span class="number">-1</span></span><br><span class="line">D=M</span><br><span class="line">@<span class="number">5</span>+index</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>push pointer 0/1</code>的实现：<code>*SP = THIS/THAT, SP++</code></p>
<p><code>pop pointer 0/1</code>的实现：<code>SP--, THIS/THAT = *SP</code></p>
<p>与temp类似</p>
</li>
<li><p><code>push/pop static i</code>的实现：<code>@vmName.index ...</code></p>
<p>与temp类似</p>
</li>
<li><p><code>segment</code>和<code>pointer</code>,<code>static</code>,<code>temp</code>段的区别只有：<code>segment</code>段需要额外计算地址</p>
<p>即<code>push/pop local 2</code>，需要计算<code>LCL+2</code>再进行<code>push/pop</code>操作</p>
</li>
</ol>
<p><strong><em>Recommand:</em></strong></p>
<ol>
<li>按照书中推荐的实现步骤，依次实现5个.vm文件的转化</li>
<li>对于每个步骤，先在VM Emulator中运行.vm文件和VME.tst测试文件，通过观察其每一步是如何实现的，深入理解VM语言中<code>push</code>，<code>pop</code>和各个参数的实际意义</li>
<li>手写练习相关Hack汇编语言，对于每个<code>segment</code>段的转换，至少完成一个例子</li>
<li>将转换过程用高级语言实现(Java/Python/…)，测试修改，抽象方法，代码复用</li>
</ol>
<p><img src="/post/90466d95/image-20200922135207520.png" alt="建议实现步骤" style="zoom: 80%;"></p>
<p><img src="/post/90466d95/image-20200922135257496.png" alt="建议实现步骤2" style="zoom:80%;"></p>
<p><strong><em>Tips:</em></strong></p>
<ol>
<li><p>第七章中的机器语言和第六章中的机器语言在结构上略有不同，这一章中的语言更加向高级语言靠拢，在有些地方显得“啰嗦”</p>
<p><code>push constant 7</code>需要如此多的汇编语言实现，但是其中每一句话都是有意义的，所以一定要理解每一句VM语言究竟做了哪些事</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="number">7</span>          <span class="comment">// constant 7</span></span><br><span class="line">D=A         <span class="comment">// D=7</span></span><br><span class="line">@SP         <span class="comment">// A=栈顶指针=RAM[0]</span></span><br><span class="line">A=M         <span class="comment">// A=Memory[A], A更新为M存储的数据所指向的地址</span></span><br><span class="line">M=D         <span class="comment">// Memory[A]=D</span></span><br><span class="line">@SP         <span class="comment">// A=栈顶指针</span></span><br><span class="line">M=M+<span class="number">1</span>       <span class="comment">// 栈顶指针++</span></span><br></pre></td></tr></table></figure>
<p><code>pop constant 7</code></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="number">7</span></span><br><span class="line">D=A</span><br><span class="line">@SP</span><br><span class="line">M=M<span class="number">-1</span></span><br><span class="line">A=M</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>因为一个vm文件中可能会同时出现许多<code>eq</code>，<code>lt</code>这样的涉及<code>jump</code>的语句，如果每一个<code>lable</code>都相同的话，那么<code>lable</code>就会产生重复冲突，如：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Label</span><br><span class="line">...</span><br><span class="line">(Label)</span><br><span class="line">...</span><br><span class="line">@Label</span><br><span class="line">...</span><br><span class="line">(Label)</span><br></pre></td></tr></table></figure>
<p>当机器到达第一个<code>@lable</code>点时，就会跳到最后一处<code>(lable)</code>。为了避免这种情况，需要给不同的<code>lable</code>依次加上编号，如<code>lable1</code>，<code>lable2</code>，这里可以使用定义全局变量来实现。</p>
</li>
</ol>
<ol>
<li>翻译<code>pop segment index</code>的过程中，首先需要获取<code>segment</code>中存储的地址，然后将<code>index</code>加在这个地址上，得到目标地址。最后把当前<code>SP</code>所指向的地址中的值弹入这个目标地址。这个过程是无法用机器语言直接实现的，因为当中涉及两次调用寄存器D。唯一的解决方案就是在翻译过程中用<code>index</code>控制循环语句，让其自动添加<code>index</code>次的<code>A=A+1</code>，这样的话就免去了多次调用D寄存器的困难。</li>
</ol>
<p><em>Parser.java</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析.vm文件，封装对输入代码的访问操作</span></span><br><span class="line"><span class="comment"> * 读取vm指令并解析，然后为它各个部分提供方便的访问入口</span></span><br><span class="line"><span class="comment"> * 移除代码中所有空格和注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span></span>&#123;</span><br><span class="line">    <span class="comment">// variable: 文件扫描、当前指令、当前文件名</span></span><br><span class="line">    <span class="comment">// 算术指令的字符串数组</span></span><br><span class="line">    <span class="comment">// Paser模块基本函数：构造函数、更多指令、advance()、commandType()区分指令类型、返回指令第一个参数、返回指令第二个参数</span></span><br><span class="line">    <span class="comment">// 当前指令长度</span></span><br><span class="line">    <span class="comment">// 返回完整指令</span></span><br><span class="line">    <span class="comment">// 设置和获取文件名</span></span><br><span class="line">    <span class="comment">// 关闭资源</span></span><br><span class="line">    <span class="comment">// 判断是否为算术指令  be used in commandType()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>CodeWriter.java</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeWriter</span></span>&#123;</span><br><span class="line">    <span class="comment">// PrintWriter对象、当前文件名、区分分支标签的数字</span></span><br><span class="line">    <span class="comment">// 构造函数(PrintWriter): 区分分支标签的数字置零</span></span><br><span class="line">    <span class="comment">// 设置翻译出来的的.vm文件的文件名(提取出文件名)</span></span><br><span class="line">    <span class="comment">// writeArithmetic(String command): 将给定的算术操作所对应的汇编写到输出文件</span></span><br><span class="line">    <span class="comment">// writePushAndPop(Parser.Command command, String segment, int index): </span></span><br><span class="line">    <span class="comment">//   1.constant: @idnex, D=A, 将D寄存器的值存储在SP所指向的内存单元, SP++</span></span><br><span class="line">    <span class="comment">//   2.local,argument,this,that: </span></span><br><span class="line">    <span class="comment">//     (1)push: (addr = segmentPointer+i, *SP = *addr, SP++)</span></span><br><span class="line">    <span class="comment">//             获取对应(segmentPointer+i)所指向的地址,M[SP]获取对应的值,SP++</span></span><br><span class="line">    <span class="comment">//     (2)pop: (addr = segmentPointer+i, SP--, *addr = *SP) 需要借助R13存储中间值</span></span><br><span class="line">    <span class="comment">//             获取对应(segmentPointer+i)所指向的地址,SP--,对应的内存单元获取M[SP]的值</span></span><br><span class="line">    <span class="comment">//   3.temp: </span></span><br><span class="line">    <span class="comment">//     (1)push: (*SP = 5+i, SP++)</span></span><br><span class="line">    <span class="comment">//     (2)pop: (SP--, 5+i = *SP)</span></span><br><span class="line">    <span class="comment">//   4.pointer: </span></span><br><span class="line">    <span class="comment">//     (1)push pointer 0/1: (*SP = THIS/THAT, SP++) 根据0/1决定THIS/THAT</span></span><br><span class="line">    <span class="comment">//     (2)pop  pointer 0/1: (SP--, THIS/THAT = *addr)</span></span><br><span class="line">    <span class="comment">//   5.static:</span></span><br><span class="line">    <span class="comment">//     (1)push: (*SP = fileName.index, SP++)</span></span><br><span class="line">    <span class="comment">//     (2)pop: (SP--, fileName.index = *SP)</span></span><br><span class="line">    <span class="comment">// segment: local,argument,this,that  </span></span><br><span class="line">    <span class="comment">//   void writeBasePush(String segmentPointer, int index)</span></span><br><span class="line">    <span class="comment">//   void writeBasePop(String segmentPointer, int index)</span></span><br><span class="line">    <span class="comment">// poiner, static, temp</span></span><br><span class="line">    <span class="comment">//   void writeMappedPush(String location)</span></span><br><span class="line">    <span class="comment">//   void writeMappedPop(String location)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>VMTranslator.java</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VMTranslator</span></span>&#123;</span><br><span class="line">    <span class="comment">// 需要解析的.vm文件数组链表，处理无.vm文件的情况</span></span><br><span class="line">    <span class="comment">// getParser(File): 根据File文件对象创建Parser对象，与chap6类似</span></span><br><span class="line">    <span class="comment">// printCommandLineErrorAndExit(): 命令行错误处理</span></span><br><span class="line">    <span class="comment">// 判断命令行是否正确，错误则调用函数处理</span></span><br><span class="line">    <span class="comment">// 检查提供的命令行参数，以确定它是有效的文件或目录(1.不存在，2.文件，3.目录)</span></span><br><span class="line">    <span class="comment">// if 1.输出错误</span></span><br><span class="line">    <span class="comment">// else if 2.确定是.vm文件，获取Parser对象，并解析指令参数(路径+文件名)初始化Parser对象的文件名; 调用翻译函数</span></span><br><span class="line">    <span class="comment">// else if 3.将指令参数arg[0]映射路径下的所有文件转换成File对象，并用File[]数组存储; 遍历所有文件，找出.vm文件并根据File获取Parser，依据.vm文件File对象设置Paser对象文件名，设置输出文件名(绝对路径+&#x27;/&#x27;+文件名+&#x27;.asm&#x27;)，调用函数翻译成.asm文件，并把该文件加入到数组链表</span></span><br><span class="line">    <span class="comment">// 			if 若Parser对象的数组链表为空则输出错误并退出</span></span><br><span class="line">    <span class="comment">// else 4.错误处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// writeVM2ASM(String, Parser): 空建CideWriter对象，根据String构造PrintWriter对象，再由其构造CodeWriter对象，并从parser获取文件名设置CodeWriter对象的文件名。</span></span><br><span class="line">    <span class="comment">// 还有命令:向前，跳空白，parser长度为0下一循环，若parser的命令类型是&#x27;push&#x27;或&#x27;pop&#x27;则调用codewriter对象写入Push和Pop相应的ASM指令，算术指令调用相应的函数</span></span><br><span class="line">    <span class="comment">// finally 释放parser和codewriter资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Alva</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://a1va.github.io/post/90466d95/">https://a1va.github.io/post/90466d95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://A1va.github.io" target="_blank">Alva</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/nand2tetris/">nand2tetris</a><a class="post-meta__tags" href="/tags/VirtualMachine/">VirtualMachine</a><a class="post-meta__tags" href="/tags/vm/">vm</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/35e94e02/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">nand2tetis C8-虚拟机Ⅱ程序控制</div></div></a></div><div class="next-post pull-right"><a href="/post/feff5e0b/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">nand2tetis C7-汇编编译器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/35e94e02/" title="nand2tetis C8-虚拟机Ⅱ程序控制"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-23</div><div class="title">nand2tetis C8-虚拟机Ⅱ程序控制</div></div></a></div><div><a href="/post/5b231705/" title="nand2tetis C1-布尔逻辑"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-22</div><div class="title">nand2tetis C1-布尔逻辑</div></div></a></div><div><a href="/post/e4fb99f5/" title="nand2tetis C2-布尔算法"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-23</div><div class="title">nand2tetis C2-布尔算法</div></div></a></div><div><a href="/post/778f3b2f/" title="nand2tetis C3-时序逻辑"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-23</div><div class="title">nand2tetis C3-时序逻辑</div></div></a></div><div><a href="/post/881a6736/" title="nand2tetis C5-计算机体系结构"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-23</div><div class="title">nand2tetis C5-计算机体系结构</div></div></a></div><div><a href="/post/dd2b6294/" title="nand2tetis C4-机器语言"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-23</div><div class="title">nand2tetis C4-机器语言</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By Alva</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const initData = {
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }

    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/customize.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>